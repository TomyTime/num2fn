/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @namespace egret
*/
var egret;
(function (egret) {
    /**
    * @class egret.HashObject
    * @classdesc
    * @implements egret.IHashObject
    */
    var HashObject = (function () {
        /**
        * @method egret.HashObject#constructor
        * @class egret.HashObject
        * @classdesc 哈希对象。引擎内所有对象的基类，为对象实例提供唯一的hashCode值,提高对象比较的性能。
        */
        function HashObject() {
            this._hashCode = HashObject.hashCount++;
        }
        Object.defineProperty(HashObject.prototype, "hashCode", {
            /**
            * 返回此对象唯一的哈希值,用于唯一确定一个对象。hashCode为大于等于1的整数。
            * @member {number} egret.HashObject#hashCode
            */
            get: function () {
                return this._hashCode;
            },
            enumerable: true,
            configurable: true
        });
        HashObject.hashCount = 1;
        return HashObject;
    })();
    egret.HashObject = HashObject;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * 对象缓存复用工具类，可用于构建对象池，一段时间后会自动回收对象。
    */
    var Recycler = (function (_super) {
        __extends(Recycler, _super);
        function Recycler(autoDisposeTime) {
            if (typeof autoDisposeTime === "undefined") { autoDisposeTime = 300; }
            _super.call(this);
            this.objectPool = [];
            this._length = 0;
            if (autoDisposeTime < 1)
                autoDisposeTime = 1;
            this.autoDisposeTime = autoDisposeTime;
            this.frameCount = 0;
        }
        Recycler.prototype._checkFrame = function () {
            this.frameCount--;
            if (this.frameCount <= 0) {
                this.dispose();
            }
        };

        Object.defineProperty(Recycler.prototype, "length", {
            /**
            * 缓存的对象数量
            */
            get: function () {
                return this._length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 缓存一个对象以复用
        * @param object
        */
        Recycler.prototype.push = function (object) {
            var pool = this.objectPool;
            if (pool.indexOf(object) == -1) {
                pool.push(object);
                this._length++;
                if (this.frameCount == 0) {
                    this.frameCount = this.autoDisposeTime;
                    Recycler._callBackList.push(this);
                }
            }
        };

        /**
        * 获取一个缓存的对象
        */
        Recycler.prototype.pop = function () {
            if (this._length == 0)
                return null;
            this._length--;
            return this.objectPool.pop();
        };

        /**
        * 立即清空所有缓存的对象。
        */
        Recycler.prototype.dispose = function () {
            if (this._length > 0) {
                this.objectPool = [];
                this._length = 0;
            }
            this.frameCount = 0;
            var list = Recycler._callBackList;
            var index = list.indexOf(this);
            if (index != -1) {
                list.splice(index, 1);
            }
        };
        Recycler._callBackList = [];
        return Recycler;
    })(egret.HashObject);
    egret.Recycler = Recycler;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    egret.__START_TIME;

    /**
    * 用于计算相对时间。此方法返回自启动 Egret 引擎以来经过的毫秒数。
    */
    function getTimer() {
        return Date.now() - egret.__START_TIME;
    }
    egret.getTimer = getTimer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    egret.__callLaterFunctionList = [];
    egret.__callLaterThisList = [];
    egret.__callLaterArgsList = [];

    /**
    * 延迟函数到屏幕重绘前执行。
    * @param method 要延迟执行的函数
    * @param thisObject 回调函数的this引用
    * @param args 函数参数列表
    */
    function callLater(method, thisObject) {
        var args = [];
        for (var _i = 0; _i < (arguments.length - 2); _i++) {
            args[_i] = arguments[_i + 2];
        }
        egret.__callLaterFunctionList.push(method);
        egret.__callLaterThisList.push(thisObject);
        egret.__callLaterArgsList.push(args);
    }
    egret.callLater = callLater;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var Event = (function (_super) {
        __extends(Event, _super);
        /**
        * @class egret.Event
        * @classdesc
        * Event 类作为创建 Event 对象的基类，当发生事件时，Event 对象将作为参数传递给事件侦听器。
        *
        * Event 类的属性包含有关事件的基本信息，例如事件的类型或者是否可以取消事件的默认行为。
        *
        * 对于许多事件（如由 Event 类常量表示的事件），此基本信息就足够了。但其他事件可能需要更详细的信息。
        * 例如，与触摸关联的事件需要包括有关触摸事件的位置以及在触摸事件期间是否按下了任何键的其他信息。
        * 您可以通过扩展 Event 类（TouchEvent 类执行的操作）将此类其他信息传递给事件侦听器。
        * Egret API 为需要其他信息的常见事件定义多个 Event 子类。与每个 Event 子类关联的事件将在每个类的文档中加以介绍。
        *
        * Event 类的方法可以在事件侦听器函数中使用以影响事件对象的行为。
        * 某些事件有关联的默认行为，通过调用 preventDefault() 方法，您的事件侦听器可以取消此行为。
        * 可以通过调用 stopPropagation() 或 stopImmediatePropagation() 方法，将当前事件侦听器作为处理事件的最后一个事件侦听器。
        * @param {string} type 事件的类型，可以作为 Event.type 访问。
        * @param bubbles{boolean} 确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
        * @param cancelable{boolean} 确定是否可以取消 Event 对象。默认值为 false。
        */
        function Event(type, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this);
            this._eventPhase = 2;
            this._isDefaultPrevented = false;
            this._isPropagationStopped = false;
            this._isPropagationImmediateStopped = false;
            this.isNew = true;
            this._type = type;
            this._bubbles = bubbles;
            this._cancelable = cancelable;
        }
        Object.defineProperty(Event.prototype, "type", {
            /**
            * 事件的类型。类型区分大小写。
            * @member {string} egret.Event#type
            */
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Event.prototype, "bubbles", {
            /**
            * 表示事件是否为冒泡事件。如果事件可以冒泡，则此值为 true；否则为 false。
            * @member {boolean} egret.Event#bubbles
            */
            get: function () {
                return this._bubbles;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Event.prototype, "cancelable", {
            /**
            * 表示是否可以阻止与事件相关联的行为。如果可以取消该行为，则此值为 true；否则为 false。
            * @member {boolean} egret.Event#cancelable
            */
            get: function () {
                return this._cancelable;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Event.prototype, "eventPhase", {
            /**
            * 事件流中的当前阶段。此属性可以包含以下数值：
            * 捕获阶段 (EventPhase.CAPTURING_PHASE)。
            * 目标阶段 (EventPhase.AT_TARGET)。
            * 冒泡阶段 (EventPhase.BUBBLING_PHASE)。
            * @member {boolean} egret.Event#eventPhase
            */
            get: function () {
                return this._eventPhase;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Event.prototype, "currentTarget", {
            /**
            * 当前正在使用某个事件侦听器处理 Event 对象的对象。例如，如果用户单击“确定”按钮，
            * 则当前目标可以是包含该按钮的节点，也可以是它的已为该事件注册了事件侦听器的始祖之一。
            * @member {any} egret.Event#currentTarget
            */
            get: function () {
                return this._currentTarget;
            },
            enumerable: true,
            configurable: true
        });

        Event.prototype._setCurrentTarget = function (target) {
            this._currentTarget = target;
        };

        Object.defineProperty(Event.prototype, "target", {
            /**
            * 事件目标。此属性包含目标节点。例如，如果用户单击“确定”按钮，则目标节点就是包含该按钮的显示列表节点。
            * @member {any} egret.Event#target
            */
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 检查是否已对事件调用 preventDefault() 方法。
        * @method egret.Event#isDefaultPrevented
        * @returns {boolean} 如果已调用 preventDefault() 方法，则返回 true；否则返回 false。
        */
        Event.prototype.isDefaultPrevented = function () {
            return this._isDefaultPrevented;
        };

        /**
        * 如果可以取消事件的默认行为，则取消该行为。
        * 许多事件都有默认执行的关联行为。例如，如果用户在文本字段中键入一个字符，则默认行为就是在文本字段中显示该字符。
        * 由于可以取消 TextEvent.TEXT_INPUT 事件的默认行为，因此您可以使用 preventDefault() 方法来防止显示该字符。
        * 注意：当cancelable属性为false时，此方法不可用。
        * @method egret.Event#preventDefault
        */
        Event.prototype.preventDefault = function () {
            if (this._cancelable)
                this._isDefaultPrevented = true;
        };

        /**
        * 防止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。
        * 相比之下，stopImmediatePropagation() 方法可以防止对当前节点中和后续节点中的事件侦听器进行处理。
        * 对此方法的其它调用没有任何效果。可以在事件流的任何阶段中调用此方法。
        * 注意：此方法不会取消与此事件相关联的行为；有关此功能的信息，请参阅 preventDefault()。
        * @method egret.Event#stopPropagation
        */
        Event.prototype.stopPropagation = function () {
            if (this._bubbles)
                this._isPropagationStopped = true;
        };

        /**
        * 防止对事件流中当前节点中和所有后续节点中的事件侦听器进行处理。此方法会立即生效，并且会影响当前节点中的事件侦听器。
        * 相比之下，在当前节点中的所有事件侦听器都完成处理之前，stopPropagation() 方法不会生效。
        * 注意：此方法不会取消与此事件相关联的行为；有关此功能的信息，请参阅 preventDefault()。
        * @method egret.Event#stopImmediatePropagation
        */
        Event.prototype.stopImmediatePropagation = function () {
            if (this._bubbles)
                this._isPropagationImmediateStopped = true;
        };

        Event.prototype._reset = function () {
            if (this.isNew) {
                this.isNew = false;
                return;
            }
            this._isDefaultPrevented = false;
            this._isPropagationStopped = false;
            this._isPropagationImmediateStopped = false;
            this._target = null;
            this._currentTarget = null;
            this._eventPhase = 2;
        };

        Event._dispatchByTarget = function (EventClass, target, type, props, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            var recycler = EventClass.eventRecycler;
            if (!recycler) {
                recycler = EventClass.eventRecycler = new egret.Recycler();
            }
            var event = recycler.pop();
            if (!event) {
                event = new EventClass(type);
            } else {
                event._type = type;
            }
            event._bubbles = bubbles;
            event._cancelable = cancelable;
            if (props) {
                for (var key in props) {
                    event[key] = props[key];
                    if (event[key] !== null) {
                        props[key] = null;
                    }
                }
            }
            var result = target.dispatchEvent(event);
            recycler.push(event);
            return result;
        };

        Event._getPropertyData = function (EventClass) {
            var props = EventClass._props;
            if (!props)
                props = EventClass._props = {};
            return props;
        };

        /**
        * 使用指定的EventDispatcher对象来抛出Event事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.Event.dispatchEvent
        */
        Event.dispatchEvent = function (target, type, bubbles, data) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            var eventClass = Event;
            var props = Event._getPropertyData(eventClass);
            if (data) {
                props.data = data;
            }
            Event._dispatchByTarget(eventClass, target, type, props, bubbles);
        };
        Event.ADDED_TO_STAGE = "addedToStage";

        Event.REMOVED_FROM_STAGE = "removedFromStage";

        Event.ADDED = "added";

        Event.REMOVED = "removed";

        Event.COMPLETE = "complete";

        Event.ENTER_FRAME = "enterFrame";

        Event.RENDER = "render";

        Event.FINISH_RENDER = "finishRender";

        Event.FINISH_UPDATE_TRANSFORM = "finishUpdateTransform";

        Event.LEAVE_STAGE = "leaveStage";

        Event.RESIZE = "resize";

        Event.CHANGE = "change";
        return Event;
    })(egret.HashObject);
    egret.Event = Event;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.IOErrorEvent
    * @classdesc
    * @extends egret.Event
    */
    var IOErrorEvent = (function (_super) {
        __extends(IOErrorEvent, _super);
        /**
        * @method egret.IOErrorEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        */
        function IOErrorEvent(type, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);
        }
        /**
        * 使用指定的EventDispatcher对象来抛出Event事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.IOErrorEvent.dispatchIOErrorEvent
        * @param target {egret.IEventDispatcher}
        */
        IOErrorEvent.dispatchIOErrorEvent = function (target) {
            var eventClass = IOErrorEvent;
            egret.Event._dispatchByTarget(eventClass, target, IOErrorEvent.IO_ERROR);
        };
        IOErrorEvent.IO_ERROR = "ioError";
        return IOErrorEvent;
    })(egret.Event);
    egret.IOErrorEvent = IOErrorEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var TouchEvent = (function (_super) {
        __extends(TouchEvent, _super);
        /**
        * 创建一个作为参数传递给事件侦听器的 Event 对象。
        *
        * @class egret.TouchEvent
        * @classdesc
        * TouchEvent数据类
        * @extends egret.Event
        * @constructor egret.TouchEvent
        * @param type {string} 事件的类型，可以作为 Event.type 访问。
        * @param bubbles {boolean} 确定 Event 对象是否参与事件流的冒泡阶段。默认值为 false。
        * @param cancelable {boolean} 确定是否可以取消 Event 对象。默认值为 false。
        * @param touchPointID {number}
        * @param stageX {number}
        * @param stageY {number}
        * @param ctrlKey {boolean}
        * @param altKey {boolean}
        * @param shiftKey {boolean}
        * @param touchDown {boolean}
        */
        function TouchEvent(type, bubbles, cancelable, touchPointID, stageX, stageY, ctrlKey, altKey, shiftKey, touchDown) {
            if (typeof bubbles === "undefined") { bubbles = true; }
            if (typeof cancelable === "undefined") { cancelable = true; }
            if (typeof touchPointID === "undefined") { touchPointID = 0; }
            if (typeof stageX === "undefined") { stageX = 0; }
            if (typeof stageY === "undefined") { stageY = 0; }
            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
            if (typeof altKey === "undefined") { altKey = false; }
            if (typeof shiftKey === "undefined") { shiftKey = false; }
            if (typeof touchDown === "undefined") { touchDown = false; }
            _super.call(this, type, bubbles, cancelable);
            this._stageX = 0;
            this._stageY = 0;
            this._localX = 0;
            this._localY = 0;
            this.touchPointID = touchPointID;
            this._stageX = stageX;
            this._stageY = stageY;
            this.ctrlKey = ctrlKey;
            this.altKey = altKey;
            this.touchDown = touchDown;
        }
        Object.defineProperty(TouchEvent.prototype, "stageX", {
            /**
            * 事件发生点在全局舞台坐标中的水平坐标。
            * @member {number} egret.TouchEvent#stageX
            */
            get: function () {
                return this._stageX;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TouchEvent.prototype, "stageY", {
            /**
            * 事件发生点在全局舞台坐标中的垂直坐标。
            * @member {number} egret.TouchEvent#stageY
            */
            get: function () {
                return this._stageY;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TouchEvent.prototype, "localX", {
            /**
            * 事件发生点相对于currentTarget的水平坐标。
            * @member {number} egret.TouchEvent#localX
            */
            get: function () {
                return this._localX;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TouchEvent.prototype, "localY", {
            /**
            * 事件发生点相对于currentTarget的垂直坐标。
            * @member {number} egret.TouchEvent#localY
            */
            get: function () {
                return this._localY;
            },
            enumerable: true,
            configurable: true
        });

        TouchEvent.prototype._setCurrentTarget = function (target) {
            _super.prototype._setCurrentTarget.call(this, target);
            if (target instanceof egret.DisplayObject) {
                var dp = target;
                var point = dp.globalToLocal(this._stageX, this._stageY, egret.Point.identity);
                this._localX = point.x;
                this._localY = point.y;
            }
        };

        /**
        * 使用指定的EventDispatcher对象来抛出Event事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.TouchEvent.dispatchTouchEvent
        * @param target {egret.IEventDispatcher}
        * @param type {string}
        * @param touchPointID {number}
        * @param stageX {number}
        * @param stageY {number}
        * @param ctrlKey {boolean}
        * @param altKey {boolean}
        * @param shiftKey {boolean}
        * @param touchDown {boolean}
        */
        TouchEvent.dispatchTouchEvent = function (target, type, touchPointID, stageX, stageY, ctrlKey, altKey, shiftKey, touchDown) {
            if (typeof touchPointID === "undefined") { touchPointID = 0; }
            if (typeof stageX === "undefined") { stageX = 0; }
            if (typeof stageY === "undefined") { stageY = 0; }
            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
            if (typeof altKey === "undefined") { altKey = false; }
            if (typeof shiftKey === "undefined") { shiftKey = false; }
            if (typeof touchDown === "undefined") { touchDown = false; }
            var eventClass = TouchEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.touchPointID = touchPointID;
            props._stageX = stageX;
            props._stageY = stageY;
            props.ctrlKey = ctrlKey;
            props.altKey = altKey;
            props.shiftKey = shiftKey;
            props.touchDown = touchDown;
            egret.Event._dispatchByTarget(eventClass, target, type, props, true, true);
        };
        TouchEvent.TOUCH_TAP = "touchTap";

        TouchEvent.TOUCH_MOVE = "touchMove";

        TouchEvent.TOUCH_BEGIN = "touchBegin";

        TouchEvent.TOUCH_END = "touchEnd";

        TouchEvent.TOUCH_RELEASE_OUTSIDE = "touchReleaseOutside";

        TouchEvent.TOUCH_ROLL_OUT = "touchRollOut";

        TouchEvent.TOUCH_ROLL_OVER = "touchRollOver";

        TouchEvent.TOUCH_OUT = "touchOut";

        TouchEvent.TOUCH_OVER = "touchOver";
        return TouchEvent;
    })(egret.Event);
    egret.TouchEvent = TouchEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/** @namespace egret */
var egret;
(function (egret) {
    /**
    * @class egret.TimerEvent
    * @classdesc
    * 创建一个 Event 对象，其中包含有关 timer 事件的特定信息。
    *
    * 每当 Timer 对象达到由 Timer.delay 属性指定的间隔时，Timer 对象即会调度 TimerEvent 对象。
    * @extends egret.Event
    */
    var TimerEvent = (function (_super) {
        __extends(TimerEvent, _super);
        /**
        *
        * @constructor egret.TimerEvent
        * @param type {string} 事件的类型。事件侦听器可以通过继承的 type 属性访问此信息。
        * @param bubbles {boolean} 确定 Event 对象是否冒泡。事件侦听器可以通过继承的 bubbles 属性访问此信息。
        * @param cancelable {boolean} 确定是否可以取消 Event 对象。事件侦听器可以通过继承的 cancelable 属性访问此信息。
        */
        function TimerEvent(type, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);
        }
        /**
        * 使用指定的EventDispatcher对象来抛出Event事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.TimerEvent.dispatchTimerEvent
        * @param target {egret.IEventDispatcher}
        * @param type {string}
        */
        TimerEvent.dispatchTimerEvent = function (target, type) {
            var eventClass = TimerEvent;
            egret.Event._dispatchByTarget(eventClass, target, type);
        };
        TimerEvent.TIMER = "timer";

        TimerEvent.TIMER_COMPLETE = "timerComplete";
        return TimerEvent;
    })(egret.Event);
    egret.TimerEvent = TimerEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.EventPhase
    * @classdesc
    * EventPhase 类可为 Event 类的 eventPhase 属性提供值。
    */
    var EventPhase = (function () {
        function EventPhase() {
        }
        EventPhase.CAPTURING_PHASE = 1;

        EventPhase.AT_TARGET = 2;

        EventPhase.BUBBLING_PHASE = 3;
        return EventPhase;
    })();
    egret.EventPhase = EventPhase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    *
    * @class egret.EventDispatcher
    * @classdesc
    * EventDispatcher是egret的事件派发器类，负责进行事件的发送和侦听。
    * @extends egret.HashObject
    * @implements egret.IEventDispatcher
    *
    */
    var EventDispatcher = (function (_super) {
        __extends(EventDispatcher, _super);
        /**
        * EventDispatcher 类是可调度事件的所有类的基类。EventDispatcher 类实现 IEventDispatcher 接口
        * ，并且是 DisplayObject 类的基类。EventDispatcher 类允许显示列表上的任何对象都是一个事件目标，
        * 同样允许使用 IEventDispatcher 接口的方法。
        */
        function EventDispatcher(target) {
            if (typeof target === "undefined") { target = null; }
            _super.call(this);
            if (target) {
                this._eventTarget = target;
            } else {
                this._eventTarget = this;
            }
        }
        /**
        * 添加事件侦听器
        * @method egret.EventDispatcher#addEventListener
        * @param type {string} 事件的类型。
        * @param listener {Function} 处理事件的侦听器函数。此函数必须接受 Event 对象作为其唯一的参数，并且不能返回任何结果，
        * 如下面的示例所示： function(evt:Event):void 函数可以有任何名称。
        * @param thisObject {any} 侦听函数绑定的this对象
        * @param useCapture {boolean} 确定侦听器是运行于捕获阶段还是运行于目标和冒泡阶段。如果将 useCapture 设置为 true，
        * 则侦听器只在捕获阶段处理事件，而不在目标或冒泡阶段处理事件。如果 useCapture 为 false，则侦听器只在目标或冒泡阶段处理事件。
        * 要在所有三个阶段都侦听事件，请调用 addEventListener 两次：一次将 useCapture 设置为 true，一次将 useCapture 设置为 false。
        * @param  priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
        */
        EventDispatcher.prototype.addEventListener = function (type, listener, thisObject, useCapture, priority) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            if (typeof priority === "undefined") { priority = 0; }
            if (typeof useCapture === "undefined") {
                useCapture = false;
            }
            if (typeof priority === "undefined") {
                priority = 0;
            }
            if (!listener) {
                egret.Logger.fatal("addEventListener侦听函数不能为空");
            }
            var eventMap;
            if (useCapture) {
                if (!this._captureEventsMap)
                    this._captureEventsMap = {};
                eventMap = this._captureEventsMap;
            } else {
                if (!this._eventsMap)
                    this._eventsMap = {};
                eventMap = this._eventsMap;
            }
            var list = eventMap[type];
            if (!list) {
                list = eventMap[type] = [];
            }
            this._insertEventBin(list, listener, thisObject, priority);
        };

        /**
        * 在一个事件列表中按优先级插入事件对象
        */
        EventDispatcher.prototype._insertEventBin = function (list, listener, thisObject, priority) {
            var insertIndex = -1;
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var bin = list[i];
                if (bin.listener === listener && bin.thisObject === thisObject) {
                    return false;
                }
                if (insertIndex == -1 && bin.priority < priority) {
                    insertIndex = i;
                }
            }
            var eventBin = { listener: listener, thisObject: thisObject, priority: priority };
            if (insertIndex != -1) {
                list.splice(insertIndex, 0, eventBin);
            } else {
                list.push(eventBin);
            }
            return true;
        };

        /**
        * 移除事件侦听器
        * @method egret.EventDispatcher#removeEventListener
        * @param type {string} 事件名
        * @param listener {Function} 侦听函数
        * @param thisObject {any} 侦听函数绑定的this对象
        * @param useCapture {boolean} 是否使用捕获，这个属性只在显示列表中生效。
        */
        EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject, useCapture) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            var eventMap = useCapture ? this._captureEventsMap : this._eventsMap;
            if (!eventMap)
                return;
            var list = eventMap[type];
            if (!list) {
                return;
            }
            this._removeEventBin(list, listener, thisObject);
            if (list.length == 0) {
                delete eventMap[type];
            }
        };

        /**
        * 在一个事件列表中按优先级插入事件对象
        */
        EventDispatcher.prototype._removeEventBin = function (list, listener, thisObject) {
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var bin = list[i];
                if (bin.listener === listener && bin.thisObject === thisObject) {
                    list.splice(i, 1);
                    return true;
                }
            }
            return false;
        };

        /**
        * 检测是否存在监听器
        * @method egret.EventDispatcher#hasEventListener
        * @param type 事件名
        * @returns {boolean}
        * @stable A
        */
        EventDispatcher.prototype.hasEventListener = function (type) {
            return (this._eventsMap && this._eventsMap[type] || this._captureEventsMap && this._captureEventsMap[type]);
        };

        /**
        * 检查是否用此 EventDispatcher 对象或其任何始祖为指定事件类型注册了事件侦听器。将指定类型的事件调度给此
        * EventDispatcher 对象或其任一后代时，如果在事件流的任何阶段触发了事件侦听器，则此方法返回 true。
        * hasEventListener() 与 willTrigger() 方法的区别是：hasEventListener() 只检查它所属的对象，
        * 而 willTrigger() 方法检查整个事件流以查找由 type 参数指定的事件。
        * @method egret.EventDispatcher#willTrigger
        * @param type 事件名
        * @returns {boolean}
        */
        EventDispatcher.prototype.willTrigger = function (type) {
            return this.hasEventListener(type);
        };

        /**
        * 将事件分派到事件流中。事件目标是对其调用 dispatchEvent() 方法的 EventDispatcher 对象。
        * @method egret.EventDispatcher#dispatchEvent
        * @param event {egret.Event} 调度到事件流中的 Event 对象。如果正在重新分派事件，则会自动创建此事件的一个克隆。 在调度了事件后，其 _eventTarget 属性将无法更改，因此您必须创建此事件的一个新副本以能够重新调度。
        * @returns {boolean} 如果成功调度了事件，则值为 true。值 false 表示失败或对事件调用了 preventDefault()。
        */
        EventDispatcher.prototype.dispatchEvent = function (event) {
            event._reset();
            event._target = this._eventTarget;
            event._setCurrentTarget(this._eventTarget);
            return this._notifyListener(event);
        };

        EventDispatcher.prototype._notifyListener = function (event) {
            var eventMap = event._eventPhase == 1 ? this._captureEventsMap : this._eventsMap;
            if (!eventMap)
                return true;
            var list = eventMap[event.type];
            if (!list) {
                return true;
            }
            list = list.concat();
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var eventBin = list[i];
                eventBin.listener.call(eventBin.thisObject, event);
                if (event._isPropagationImmediateStopped) {
                    break;
                }
            }
            return !event.isDefaultPrevented();
        };

        /**
        * 派发一个包含了特定参数的事件到所有注册了特定类型侦听器的对象中。 这个方法使用了一个内部的事件对象池因避免重复的分配导致的额外开销。
        * @method egret.EventDispatcher#dispatchEventWith
        * @param type {string} 事件类型
        * @param bubbles {boolean} 是否冒泡，默认false
        * @param data {any}附加数据(可选)
        */
        EventDispatcher.prototype.dispatchEventWith = function (type, bubbles, data) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            egret.Event.dispatchEvent(this, type, bubbles, data);
        };
        return EventDispatcher;
    })(egret.HashObject);
    egret.EventDispatcher = EventDispatcher;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.MainContext
    * @classdesc
    * MainContext是游戏的核心跨平台接口，组合了多个功能Context，并是游戏启动的主入口
    * @extends egret.EventDispatcher
    */
    var MainContext = (function (_super) {
        __extends(MainContext, _super);
        function MainContext() {
            _super.call(this);
            this.reuseEvent = new egret.Event("");
        }
        /**
        * 游戏启动，开启主循环，参考Flash的滑动跑道模型
        * @method egret.MainContext#run
        */
        MainContext.prototype.run = function () {
            egret.Ticker.getInstance().run();
            egret.Ticker.getInstance().register(this.renderLoop, this, Number.NEGATIVE_INFINITY);
            egret.Ticker.getInstance().register(this.broadcastEnterFrame, this, Number.POSITIVE_INFINITY);
            this.touchContext.run();
            egret.__invalidateModuleFlag = true;
        };

        /**
        * 滑动跑道模型，渲染部分
        */
        MainContext.prototype.renderLoop = function (frameTime) {
            var context = this.rendererContext;
            context.clearScreen();

            if (egret.__callLaterFunctionList.length > 0) {
                var functionList = egret.__callLaterFunctionList;
                egret.__callLaterFunctionList = [];
                var thisList = egret.__callLaterThisList;
                egret.__callLaterThisList = [];
                var argsList = egret.__callLaterArgsList;
                egret.__callLaterArgsList = [];
            }

            this.dispatchEventWith(egret.Event.RENDER);
            if (egret.Stage._invalidateRenderFlag) {
                this.broadcastRender();
                egret.Stage._invalidateRenderFlag = false;
            }
            if (functionList) {
                this.doCallLaterList(functionList, thisList, argsList);
            }

            this.stage._updateTransform();
            this.dispatchEventWith(egret.Event.FINISH_UPDATE_TRANSFORM);
            this.stage._draw(context);
            this.dispatchEventWith(egret.Event.FINISH_RENDER);
        };

        /**
        * 广播EnterFrame事件。
        */
        MainContext.prototype.broadcastEnterFrame = function (frameTime) {
            var event = this.reuseEvent;
            event._type = egret.Event.ENTER_FRAME;
            this.dispatchEvent(event);
            var list = egret.DisplayObject._enterFrameCallBackList.concat();
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var eventBin = list[i];
                event._target = eventBin.display;
                event._setCurrentTarget(eventBin.display);
                eventBin.listener.call(eventBin.thisObject, event);
            }

            list = egret.Recycler._callBackList;
            for (i = list.length - 1; i >= 0; i--) {
                list[i]._checkFrame();
            }
        };

        /**
        * 广播Render事件。
        */
        MainContext.prototype.broadcastRender = function () {
            var event = this.reuseEvent;
            event._type = egret.Event.RENDER;
            var list = egret.DisplayObject._renderCallBackList.concat();
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var eventBin = list[i];
                event._target = eventBin.display;
                event._setCurrentTarget(eventBin.display);
                eventBin.listener.call(eventBin.thisObject, event);
            }
        };

        /**
        * 执行callLater回调函数列表
        */
        MainContext.prototype.doCallLaterList = function (funcList, thisList, argsList) {
            var length = funcList.length;
            for (var i = 0; i < length; i++) {
                var func = funcList[i];
                if (func != null) {
                    func.apply(thisList[i], argsList[i]);
                }
            }
        };
        MainContext.DEVICE_PC = "web";
        MainContext.DEVICE_MOBILE = "native";
        return MainContext;
    })(egret.EventDispatcher);
    egret.MainContext = MainContext;
})(egret || (egret = {}));

var testDeviceType = function () {
    if (!this.hasOwnProperty("navigator")) {
        return true;
    }
    var ua = navigator.userAgent.toLowerCase();
    return (ua.indexOf('mobile') != -1 || ua.indexOf('android') != -1);
};

egret.MainContext.instance = new egret.MainContext();
egret.MainContext.deviceType = testDeviceType() ? egret.MainContext.DEVICE_MOBILE : egret.MainContext.DEVICE_PC;

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.Profiler
    * @classdesc
    * Profiler是egret的性能检测分析类
    * @todo GitHub文档，如何使用Profiler
    */
    var Profiler = (function () {
        function Profiler() {
            this._lastTime = 0;
            this._logicPerformanceCost = 0;
            this._renderPerformanceCost = 0;
            this._updateTransformPerformanceCost = 0;
            this._preDrawCount = 0;
            this._tick = 0;
            this._maxDeltaTime = 500;
            this._totalDeltaTime = 0;
        }
        Profiler.getInstance = function () {
            if (Profiler.instance == null) {
                Profiler.instance = new Profiler();
            }
            return Profiler.instance;
        };

        /**
        * 启动Profiler
        * @method egret.Profiler#run
        */
        Profiler.prototype.run = function () {
            //todo 加入debug参数
            egret.Ticker.getInstance().register(this.update, this);
            if (this._txt == null) {
                this._txt = new egret.TextField();
                this._txt.size = 28;

                egret.MainContext.instance.stage.addChild(this._txt);
            }
            var context = egret.MainContext.instance;
            context.addEventListener(egret.Event.ENTER_FRAME, this.onEnterFrame, this);
            context.addEventListener(egret.Event.RENDER, this.onStartRender, this);
            context.addEventListener(egret.Event.FINISH_RENDER, this.onFinishRender, this);
            context.addEventListener(egret.Event.FINISH_UPDATE_TRANSFORM, this.onFinishUpdateTransform, this);
        };

        /**
        * @private
        */
        Profiler.prototype.onEnterFrame = function (event) {
            this._lastTime = egret.getTimer();
        };

        /**
        * @private
        */
        Profiler.prototype.onStartRender = function (event) {
            var now = egret.getTimer();
            this._logicPerformanceCost = now - this._lastTime;
            this._lastTime = now;
        };

        Profiler.prototype.onFinishUpdateTransform = function (event) {
            var now = egret.getTimer();
            this._updateTransformPerformanceCost = now - this._lastTime;
            this._lastTime = now;
        };

        /**
        * @private
        */
        Profiler.prototype.onFinishRender = function (event) {
            var now = egret.getTimer();
            this._renderPerformanceCost = now - this._lastTime;
            this._lastTime = now;
        };

        /**
        * @private
        */
        Profiler.prototype.update = function (frameTime) {
            this._tick++;
            this._totalDeltaTime += frameTime;
            if (this._totalDeltaTime >= this._maxDeltaTime) {
                var drawStr = (this._preDrawCount - 1).toString();
                var timeStr = Math.ceil(this._logicPerformanceCost).toString() + "," + Math.ceil(this._updateTransformPerformanceCost).toString() + "," + Math.ceil(this._renderPerformanceCost).toString() + "," + Math.ceil(egret.MainContext.instance.rendererContext.renderCost).toString();
                var frameStr = Math.floor(this._tick * 1000 / this._totalDeltaTime).toString();

                this._txt.text = "draw:" + drawStr + "\n" + "cost:" + timeStr + "\n" + "FPS:" + frameStr;

                this._totalDeltaTime = 0;
                this._tick = 0;
            }
            this._preDrawCount = 0;
        };

        /**
        * @method egret.Profiler#onDrawImage
        * @private
        */
        Profiler.prototype.onDrawImage = function () {
            this._preDrawCount++;
        };
        return Profiler;
    })();
    egret.Profiler = Profiler;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Ticker
    * @classdesc
    * Ticker是egret引擎的心跳控制器，是游戏唯一的时间处理入口。开发者务必不要使用setTimeout / setInterval 等方法，而是统一使用Ticker
    * @extends egret.EventDispatcher
    */
    var Ticker = (function (_super) {
        __extends(Ticker, _super);
        function Ticker() {
            _super.apply(this, arguments);
            this._timeScale = 1;
            this._paused = false;
            this.callBackList = [];
        }
        /**
        * 启动心跳控制器。
        * 这个函数应只在游戏初始化时调用一次
        * @method egret.Ticker#run
        * @stable A
        */
        Ticker.prototype.run = function () {
            egret.__START_TIME = new Date().getTime();
            var context = egret.MainContext.instance.deviceContext;
            context.executeMainLoop(this.update, this);
        };

        Ticker.prototype.update = function (advancedTime) {
            var list = this.callBackList.concat();
            var length = list.length;

            var frameTime = advancedTime * this._timeScale;

            frameTime *= this._timeScale;
            for (var i = 0; i < length; i++) {
                var eventBin = list[i];
                eventBin.listener.call(eventBin.thisObject, frameTime);
            }
        };

        /**
        * 注册帧回调事件，同一函数的重复监听会被忽略。
        * @method egret.Ticker#register
        * @param listener {Function} 帧回调函数,参数返回上一帧和这帧的间隔时间。示例：onEnterFrame(frameTime:number):void
        * @param thisObject {any} 帧回调函数的this对象
        * @param priority {any} 事件优先级，开发者请勿传递 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY
        * @stable A-
        */
        Ticker.prototype.register = function (listener, thisObject, priority) {
            if (typeof priority === "undefined") { priority = 0; }
            var list = this.callBackList;
            this._insertEventBin(list, listener, thisObject, priority);
        };

        /**
        * 取消侦听enterFrame事件
        * @method egret.Ticker#unregister
        * @param listener {Function} 事件侦听函数
        * @param thisObject {any} 侦听函数的this对象
        * @stable A-
        */
        Ticker.prototype.unregister = function (listener, thisObject) {
            var list = this.callBackList;
            this._removeEventBin(list, listener, thisObject);
        };

        /**
        * 在指定的延迟（以毫秒为单位）后运行指定的函数。
        * @method egret.Ticker#setTimeout
        * @param listener {Function}
        * @param thisObject {any}
        * @param delay {number}
        * @param ...parameter {any}
        * @deprecated
        */
        Ticker.prototype.setTimeout = function (listener, thisObject, delay) {
            var parameters = [];
            for (var _i = 0; _i < (arguments.length - 3); _i++) {
                parameters[_i] = arguments[_i + 3];
            }
            egret.Logger.warning("Ticker#setTimeout方法即将废弃,请使用egret.setTimeout");
            egret.setTimeout.apply(null, [listener, thisObject, delay].concat(parameters));
        };

        /**
        * @method egret.Ticker#setTimeScale
        * @param timeScale {number}
        */
        Ticker.prototype.setTimeScale = function (timeScale) {
            this._timeScale = timeScale;
        };

        /**
        * @method egret.Ticker#getTimeScale
        */
        Ticker.prototype.getTimeScale = function () {
            return this._timeScale;
        };

        /**
        * @method egret.Ticker#pause
        */
        Ticker.prototype.pause = function () {
            this._paused = true;
        };

        /**
        * @method egret.Ticker#resume
        */
        Ticker.prototype.resume = function () {
            this._paused = false;
        };

        /**
        * @method egret.Ticker.getInstance
        * @returns {Ticker}
        */
        Ticker.getInstance = function () {
            if (Ticker.instance == null) {
                Ticker.instance = new Ticker();
            }
            return Ticker.instance;
        };
        return Ticker;
    })(egret.EventDispatcher);
    egret.Ticker = Ticker;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.HorizontalAlign
    * @classdesc
    */
    var HorizontalAlign = (function () {
        function HorizontalAlign() {
        }
        HorizontalAlign.LEFT = "left";

        HorizontalAlign.RIGHT = "right";

        HorizontalAlign.CENTER = "center";

        HorizontalAlign.JUSTIFY = "justify";

        HorizontalAlign.CONTENT_JUSTIFY = "contentJustify";
        return HorizontalAlign;
    })();
    egret.HorizontalAlign = HorizontalAlign;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.VerticalAlign
    * @classdesc
    */
    var VerticalAlign = (function () {
        function VerticalAlign() {
        }
        VerticalAlign.TOP = "top";

        VerticalAlign.BOTTOM = "bottom";

        VerticalAlign.MIDDLE = "middle";

        VerticalAlign.JUSTIFY = "justify";

        VerticalAlign.CONTENT_JUSTIFY = "contentJustify";
        return VerticalAlign;
    })();
    egret.VerticalAlign = VerticalAlign;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var Timer = (function (_super) {
        __extends(Timer, _super);
        function Timer(delay, repeatCount) {
            if (typeof repeatCount === "undefined") { repeatCount = 0; }
            _super.call(this);
            this._currentCount = 0;
            this.delay = delay;
            this.repeatCount = repeatCount;
        }
        Timer.prototype.currentCount = function () {
            return this._currentCount;
        };

        Object.defineProperty(Timer.prototype, "running", {
            get: function () {
                return this._running;
            },
            enumerable: true,
            configurable: true
        });

        Timer.prototype.reset = function () {
            this.stop();
            this._currentCount = 0;
        };

        Timer.prototype.start = function () {
            if (this._running)
                return;
            this.lastTime = egret.getTimer();
            if (this._currentCount != 0) {
                this._currentCount = 0;
            }
            egret.Ticker.getInstance().register(this.onEnterFrame, this);
            this._running = true;
        };

        Timer.prototype.stop = function () {
            if (!this._running)
                return;
            egret.Ticker.getInstance().unregister(this.onEnterFrame, this);
            this._running = false;
        };

        Timer.prototype.onEnterFrame = function (frameTime) {
            var now = egret.getTimer();
            var passTime = now - this.lastTime;
            if (passTime > this.delay) {
                this.lastTime = now;
                this._currentCount++;
                egret.TimerEvent.dispatchTimerEvent(this, egret.TimerEvent.TIMER);
                if (this.repeatCount > 0 && this._currentCount >= this.repeatCount) {
                    this.stop();
                    egret.TimerEvent.dispatchTimerEvent(this, egret.TimerEvent.TIMER_COMPLETE);
                }
            }
        };
        return Timer;
    })(egret.EventDispatcher);
    egret.Timer = Timer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * 在window上需要读取的命名空间属性列表
    */
    egret.__moduleNameList = ["egret", "RES", "dragonBones"];

    /**
    * 需要重新刷新类名的标志
    */
    egret.__invalidateModuleFlag = true;

    var __functionNameCache = {};

    /**
    * 返回一个对象的完全限定名<br/>
    * @param value 需要完全限定类名称的对象，可以将任何 TypeScript / JavaScript值传递给此方法，包括所有可用的TypeScript / JavaScript类型、对象实例、原始类型（如number）和类对象
    * @returns {string} 包含完全限定类名称的字符串<br />
    * @example
    *  egret.getQualifiedClassName(egret.DisplayObject) //返回 "egret.DisplayObject"
    */
    function getQualifiedClassName(value) {
        var constructorFunction = value.prototype ? value.prototype.constructor : value.__proto__.constructor;
        var key = constructorFunction.toString();
        var className = __functionNameCache[key];
        if (className) {
            return className;
        }
        if (egret.__invalidateModuleFlag) {
            updateModules();
            egret.__invalidateModuleFlag = false;
            className = __functionNameCache[key];
            if (className) {
                return className;
            }
        }
        __functionNameCache[key] = className = getFunctionName(constructorFunction);
        return className;
    }
    egret.getQualifiedClassName = getQualifiedClassName;

    function getFunctionName(constructorFunction) {
        var constructorString = constructorFunction.toString();
        var index = constructorString.indexOf("(");
        return constructorString.substring(9, index);
    }

    function updateModules() {
        var list = egret.__moduleNameList;
        var length = list.length;
        for (var i = 0; i < length; i++) {
            var key = list[i];
            var value = __global[key];
            if (value && typeof (value) == "object" && value.__proto__ && getFunctionName(value.__proto__.constructor) == "Object") {
                setModuleName(value, key);
            }
        }
    }

    function setModuleName(ns, name) {
        for (var key in ns) {
            var value = ns[key];
            var type = typeof (value);
            if (type == "function") {
                if (!value.prototype) {
                    continue;
                }
                var classKey = value.toString();
                if (!__functionNameCache[classKey]) {
                    __functionNameCache[classKey] = name + "." + getFunctionName(value);
                }
            } else if (type == "object" && !(value instanceof Array)) {
                setModuleName(value, name + "." + key);
            }
        }
    }
})(egret || (egret = {}));

var __global = __global || this;

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var __getDefinitionByName__cache = {};

    /**
    * 返回 name 参数指定的类的类对象引用。
    * @param name 类的名称。
    * @returns {any} 返回 name 参数指定的类的类对象引用。
    * @example
    * egret.getDefinitionByName("egret.DisplayObject") //返回 DisplayObject类定义
    */
    function getDefinitionByName(name) {
        if (!name)
            return null;
        var definition = __getDefinitionByName__cache[name];
        if (definition) {
            return definition;
        }
        var paths = name.split(".");
        var length = paths.length;
        definition = __global;
        for (var i = 0; i < length; i++) {
            var path = paths[i];
            definition = definition[path];
            if (!definition) {
                return null;
            }
        }
        __getDefinitionByName__cache[name] = definition;
        return definition;
    }
    egret.getDefinitionByName = getDefinitionByName;
})(egret || (egret = {}));

var __global = __global || this;

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var __setTimeout__cache = {};
    var __setTimeout__index = 0;

    /**
    * 在指定的延迟（以毫秒为单位）后运行指定的函数。
    * @method egret.setTimeout
    * @param listener {Function}
    * @param thisObject {any}
    * @param delay {number}
    * @param args {any}
    * @returns {number} 唯一引用
    */
    function setTimeout(listener, thisObject, delay) {
        var args = [];
        for (var _i = 0; _i < (arguments.length - 3); _i++) {
            args[_i] = arguments[_i + 3];
        }
        var data = { listener: listener, thisObject: thisObject, delay: delay, params: args };
        if (__setTimeout__index == 0) {
            egret.Ticker.getInstance().register(timeoutUpdate, null);
        }
        __setTimeout__index++;
        __setTimeout__cache[__setTimeout__index] = data;
        return __setTimeout__index;
    }
    egret.setTimeout = setTimeout;

    /**
    * 清除指定延迟后运行的函数。
    * @method egret.clearTimeout
    * @param key {number}
    */
    function clearTimeout(key) {
        delete __setTimeout__cache[key];
    }
    egret.clearTimeout = clearTimeout;

    function timeoutUpdate(dt) {
        for (var key in __setTimeout__cache) {
            var data = __setTimeout__cache[key];
            data.delay -= dt;
            if (data.delay <= 0) {
                data.listener.apply(data.thisObject, data.params);
                delete __setTimeout__cache[key];
            }
        }
    }
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * 检查指定的应用程序域之内是否存在一个公共定义。该定义可以是一个类、一个命名空间或一个函数的定义。
    * @param name 定义的名称。
    * @returns {boolean} 如果指定的定义存在，则返回 true 值；否则，返回 false。
    * @example
    * egret.hasDefinition("egret.DisplayObject") //返回 true
    */
    function hasDefinition(name) {
        var definition = egret.getDefinitionByName(name);
        return definition ? true : false;
    }
    egret.hasDefinition = hasDefinition;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * 转换数字为颜色字符串
    */
    function toColorString(value) {
        if (isNaN(value) || value < 0)
            value = 0;
        if (value > 16777215)
            value = 16777215;
        var color = value.toString(16).toUpperCase();
        while (color.length < 6) {
            color = "0" + color;
        }
        return "#" + color;
    }
    egret.toColorString = toColorString;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Matrix
    * @classdesc
    * 2D矩阵类，包括常见矩阵算法
    * @extends egret.HashObject
    */
    var Matrix = (function (_super) {
        __extends(Matrix, _super);
        /**
        * @method egret.Matrix#constructor
        * @constructor
        * @param a {number}
        * @param b {number}
        * @param c {number}
        * @param d {number}
        * @param tx {number}
        * @param ty {number}
        */
        function Matrix(a, b, c, d, tx, ty) {
            if (typeof a === "undefined") { a = 1; }
            if (typeof b === "undefined") { b = 0; }
            if (typeof c === "undefined") { c = 0; }
            if (typeof d === "undefined") { d = 1; }
            if (typeof tx === "undefined") { tx = 0; }
            if (typeof ty === "undefined") { ty = 0; }
            _super.call(this);
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        }
        /**
        * @member {any} egret.Matrix#
        */
        // public methods:
        /**
        * 前置矩阵
        * @method egret.Matrix#prepend
        * @param a {number}
        * @param b {number}
        * @param c {number}
        * @param d {number}
        * @param tx {number}
        * @param ty {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.prepend = function (a, b, c, d, tx, ty) {
            var tx1 = this.tx;
            if (a != 1 || b != 0 || c != 0 || d != 1) {
                var a1 = this.a;
                var c1 = this.c;
                this.a = a1 * a + this.b * c;
                this.b = a1 * b + this.b * d;
                this.c = c1 * a + this.d * c;
                this.d = c1 * b + this.d * d;
            }
            this.tx = tx1 * a + this.ty * c + tx;
            this.ty = tx1 * b + this.ty * d + ty;
            return this;
        };

        /**
        * 后置矩阵
        * @method egret.Matrix#append
        * @param a {number}
        * @param b {number}
        * @param c {number}
        * @param d {number}
        * @param tx {number}
        * @param ty {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.append = function (a, b, c, d, tx, ty) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;

            this.a = a * a1 + b * c1;
            this.b = a * b1 + b * d1;
            this.c = c * a1 + d * c1;
            this.d = c * b1 + d * d1;
            this.tx = tx * a1 + ty * c1 + this.tx;
            this.ty = tx * b1 + ty * d1 + this.ty;
            return this;
        };

        /**
        * 前置矩阵
        * @method egret.Matrix#prependMatrix
        * @param matrix {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.prependMatrix = function (matrix) {
            this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);

            //        this.prependProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
            return this;
        };

        /**
        * 后置矩阵
        * @method egret.Matrix#appendMatrix
        * @param matrix {egret.Matrix}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.appendMatrix = function (matrix) {
            this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);

            //        this.appendProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
            return this;
        };

        /**
        * 前置矩阵
        * @method egret.Matrix#prependTransform
        * @param x {number}
        * @param y {number}
        * @param scaleX {number}
        * @param scaleY {number}
        * @param rotation {number}
        * @param skewX {number}
        * @param skewY {number}
        * @param regX {number}
        * @param regY {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.prependTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
            if (rotation % 360) {
                var r = rotation * Matrix.DEG_TO_RAD;
                var cos = Math.cos(r);
                var sin = Math.sin(r);
            } else {
                cos = 1;
                sin = 0;
            }

            if (regX || regY) {
                // append the registration offset:
                this.tx -= regX;
                this.ty -= regY;
            }
            if (skewX || skewY) {
                // TODO: can this be combined into a single prepend operation?
                skewX *= Matrix.DEG_TO_RAD;
                skewY *= Matrix.DEG_TO_RAD;
                this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
                this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
            } else {
                this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
            }
            return this;
        };

        /**
        * 后置矩阵
        * @method egret.Matrix#appendTransform
        * @param x {number}
        * @param y {number}
        * @param scaleX {number}
        * @param scaleY {number}
        * @param rotation {number}
        * @param skewX {number}
        * @param skewY {number}
        * @param regX {number}
        * @param regY {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.appendTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
            if (rotation % 360) {
                var r = rotation * Matrix.DEG_TO_RAD;
                var cos = Math.cos(r);
                var sin = Math.sin(r);
            } else {
                cos = 1;
                sin = 0;
            }

            if (skewX || skewY) {
                // TODO: can this be combined into a single append?
                skewX *= Matrix.DEG_TO_RAD;
                skewY *= Matrix.DEG_TO_RAD;
                this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
                this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
            } else {
                this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
            }

            if (regX || regY) {
                // prepend the registration offset:
                this.tx -= regX * this.a + regY * this.c;
                this.ty -= regX * this.b + regY * this.d;
            }
            return this;
        };

        /**
        * 矩阵旋转，以角度制为单位
        * @method egret.Matrix#rotate
        * @param angle {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.rotate = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);

            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;

            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            return this;
        };

        /**
        * 矩阵斜切，以角度值为单位
        * @method egret.Matrix#skew
        * @param skewX {number}
        * @param skewY {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.skew = function (skewX, skewY) {
            skewX = skewX * Matrix.DEG_TO_RAD;
            skewY = skewY * Matrix.DEG_TO_RAD;
            this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
            return this;
        };

        /**
        * 矩阵缩放
        * @method egret.Matrix#scale
        * @param x {number}
        * @param y {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.scale = function (x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            return this;
        };

        /**
        * 矩阵唯一
        * @method egret.Matrix#translate
        * @param x {number}
        * @param y {number}
        * @returns {egret.Matrix}
        */
        Matrix.prototype.translate = function (x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        };

        /**
        * 矩阵重置
        * @method egret.Matrix#identity
        * @returns {egret.Matrix}
        */
        Matrix.prototype.identity = function () {
            this.a = this.d = 1;
            this.b = this.c = this.tx = this.ty = 0;
            return this;
        };

        /**
        * 矩阵翻转
        * @method egret.Matrix#invert
        * @returns {egret.Matrix}
        */
        Matrix.prototype.invert = function () {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;

            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        };

        /**
        * 根据一个矩阵，返回某个点在该矩阵上的坐标
        * @method egret.Matrix.transformCoords
        * @param matrix {egret.Matrix}
        * @param x {number}
        * @param y {number}
        * @returns {numberPoint}
        * @stable C 该方法以后可能删除
        */
        Matrix.transformCoords = function (matrix, x, y) {
            var resultPoint = egret.Point.identity;
            resultPoint.x = matrix.a * x + matrix.c * y + matrix.tx;
            resultPoint.y = matrix.d * y + matrix.b * x + matrix.ty;

            //        resultPoint.x = matrix.a * x + matrix.c * y - matrix.tx;
            //        resultPoint.y = matrix.d * y + matrix.b * x - matrix.ty;
            return resultPoint;
        };

        Matrix.prototype.toArray = function (transpose) {
            if (!this.array) {
                this.array = new Float32Array(9);
            }

            if (transpose) {
                this.array[0] = this.a;
                this.array[1] = this.b;
                this.array[2] = 0;
                this.array[3] = this.c;
                this.array[4] = this.d;
                this.array[5] = 0;
                this.array[6] = this.tx;
                this.array[7] = this.ty;
                this.array[8] = 1;
            } else {
                this.array[0] = this.a;
                this.array[1] = this.b;
                this.array[2] = this.tx;
                this.array[3] = this.c;
                this.array[4] = this.d;
                this.array[5] = this.ty;
                this.array[6] = 0;
                this.array[7] = 0;
                this.array[8] = 1;
            }

            return this.array;
        };
        Matrix.identity = new Matrix();

        Matrix.DEG_TO_RAD = Math.PI / 180;
        return Matrix;
    })(egret.HashObject);
    egret.Matrix = Matrix;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Point
    * @classdesc
    * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
    * @extends egret.HashObject
    */
    var Point = (function (_super) {
        __extends(Point, _super);
        /**
        * @method egret.Point#constructor
        * @param x {number}
        * @param y {number}
        */
        function Point(x, y) {
            if (typeof x === "undefined") { x = 0; }
            if (typeof y === "undefined") { y = 0; }
            _super.call(this);
            this.x = x;
            this.y = y;
        }
        /**
        * 克隆点对象
        * @method egret.Point#clone
        * @returns {egret.Point}
        */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };

        /**
        * 确定两个点是否相同。如果两个点具有相同的 x 和 y 值，则它们是相同的点。
        * @method egret.Point#equals
        * @param {egret.Point} toCompare 要比较的点。
        * @returns {boolean} 如果该对象与此 Point 对象相同，则为 true 值，如果不相同，则为 false。
        */
        Point.prototype.equals = function (toCompare) {
            return this.x == toCompare.x && this.y == toCompare.y;
        };

        /**
        * 返回 pt1 和 pt2 之间的距离。
        * @method egret.Point#distance
        * @param p1 第一个点
        * @param p2 第二个点
        * @returns {number} 第一个点和第二个点之间的距离。
        */
        Point.distance = function (p1, p2) {
            return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
        };
        Point.identity = new Point(0, 0);
        return Point;
    })(egret.HashObject);
    egret.Point = Point;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Rectangle
    * @classdesc
    * 矩形类
    * @extends egret.HashObject
    */
    var Rectangle = (function (_super) {
        __extends(Rectangle, _super);
        function Rectangle(x, y, width, height) {
            if (typeof x === "undefined") { x = 0; }
            if (typeof y === "undefined") { y = 0; }
            if (typeof width === "undefined") { width = 0; }
            if (typeof height === "undefined") { height = 0; }
            _super.call(this);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        Object.defineProperty(Rectangle.prototype, "right", {
            /**
            * x和width的和
            * @member {number} egret.Rectangle#right
            */
            get: function () {
                return this.x + this.width;
            },
            set: function (value) {
                this.width = value - this.x;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Rectangle.prototype, "bottom", {
            /**
            * y和height的和
            * @member {number} egret.Rectangle#bottom
            */
            get: function () {
                return this.y + this.height;
            },
            set: function (value) {
                this.height = value - this.y;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 举行类初始化赋值，开发者尽量调用此方法复用Rectangle对象，而不是每次需要的时候都重新创建
        * @method egret.Rectangle#initialize
        * @param x {number}
        * @param y {number}
        * @param width {number}
        * @param height {number}
        * @returns {egret.Rectangle}
        */
        Rectangle.prototype.initialize = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        };

        /**
        * 判断某坐标点是否存在于矩形内
        * @method egret.Rectangle#contains
        * @param x {number}
        * @param y {number}
        * @returns {boolean}
        */
        Rectangle.prototype.contains = function (x, y) {
            return this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y;
        };

        /**
        * 确定在 toIntersect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
        * @method egret.Rectangle#intersects
        * @param toIntersect {egret.Rectangle} 要与此 Rectangle 对象比较的 Rectangle 对象。
        * @returns {boolean}
        */
        Rectangle.prototype.intersects = function (toIntersect) {
            if (this.contains(toIntersect.x, toIntersect.y))
                return true;
            if (this.contains(toIntersect.x, toIntersect.bottom))
                return true;
            if (this.contains(toIntersect.right, toIntersect.y))
                return true;
            if (this.contains(toIntersect.right, toIntersect.bottom))
                return true;
            return false;
        };

        /**
        * 克隆矩形对象
        * @method egret.Rectangle#clone
        *
        */
        Rectangle.prototype.clone = function () {
            return new Rectangle(this.x, this.y, this.width, this.height);
        };

        /**
        * 是否包含某个点
        * @method egret.Rectangle#containsPoint
        * @param point {egret.Point}
        * @returns {boolean}
        */
        Rectangle.prototype.containsPoint = function (point) {
            if (this.x < point.x && this.x + this.width > point.x && this.y < point.y && this.y + this.height > point.y) {
                return true;
            }
            return false;
        };
        Rectangle.identity = new Rectangle(0, 0, 0, 0);
        return Rectangle;
    })(egret.HashObject);
    egret.Rectangle = Rectangle;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.Logger
    * @classdesc
    * Logger是引擎的日志处理模块入口
    * @stable B 目前Logger的接口设计没有问题，但是考虑到跨平台，需要将其改为一个Context，并且允许开发者自由扩展以实现自身游戏的日志分析收集需求
    * todo:GitHub文档，如何利用日志帮助游戏持续改进
    */
    var Logger = (function () {
        function Logger() {
        }
        /**
        * 表示出现了致命错误，开发者必须修复错误
        * @method egret.Logger.fatal
        * @param actionCode {string}
        * @param value {Object}
        */
        Logger.fatal = function (actionCode, value) {
            if (typeof value === "undefined") { value = null; }
            egret.Logger.traceToConsole("Fatal", actionCode, value);
            throw new Error(egret.Logger.getTraceCode("Fatal", actionCode, value));
        };

        /**
        * 记录正常的Log信息
        * @method egret.Logger.info
        * @param actionCode {string}
        * @param value {Object}
        */
        Logger.info = function (actionCode, value) {
            if (typeof value === "undefined") { value = null; }
            egret.Logger.traceToConsole("Info", actionCode, value);
        };

        /**
        * 记录可能会出现问题的Log信息
        * @method egret.Logger.warning
        * @param actionCode {string}
        * @param value {Object}
        */
        Logger.warning = function (actionCode, value) {
            if (typeof value === "undefined") { value = null; }
            egret.Logger.traceToConsole("Warning", actionCode, value);
        };

        /**
        * @private
        * @param type
        * @param actionCode
        * @param value
        */
        Logger.traceToConsole = function (type, actionCode, value) {
            console.log(egret.Logger.getTraceCode(type, actionCode, value));
        };

        /**
        * @private
        * @param type
        * @param actionCode
        * @param value
        * @returns {string}
        */
        Logger.getTraceCode = function (type, actionCode, value) {
            return "[" + type + "]" + actionCode + ":" + (value == null ? "" : value);
        };
        return Logger;
    })();
    egret.Logger = Logger;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.StageDelegate
    * @classdesc
    * StageDelegate负责处理屏幕适配策略
    * 有关屏幕适配策略，更多信息请了解 GitHub:理解egret的GameLauncher
    * @extends egret.HashObject
    */
    var StageDelegate = (function (_super) {
        __extends(StageDelegate, _super);
        /**
        * @method egret.StageDelegate#constructor
        */
        function StageDelegate() {
            _super.call(this);
            this._designWidth = 0;
            this._designHeight = 0;
            this._scaleX = 1;
            this._scaleY = 1;
            var canvas = document.getElementById(StageDelegate.canvas_name);
            var w = canvas.width, h = canvas.height;
            this._designWidth = w;
            this._designHeight = h;
        }
        /**
        * @method egret.StageDelegate.getInstance
        * @returns {StageDelegate}
        */
        StageDelegate.getInstance = function () {
            if (StageDelegate.instance == null) {
                ContainerStrategy.initialize();
                StageDelegate.instance = new StageDelegate();
            }
            return StageDelegate.instance;
        };

        /**
        * @method egret.StageDelegate#setDesignSize
        * @param width {number}
        * @param height {{number}}
        * @param resolutionPolicy {any}
        */
        StageDelegate.prototype.setDesignSize = function (width, height, resolutionPolicy) {
            this.setResolutionPolicy(resolutionPolicy);
            this._designWidth = width;
            this._designHeight = height;
            this._resolutionPolicy._apply(this, this._designWidth, this._designHeight);
        };

        /**
        * @method egret.StageDelegate#setResolutionPolicy
        * @param resolutionPolic {any}
        */
        StageDelegate.prototype.setResolutionPolicy = function (resolutionPolicy) {
            this._resolutionPolicy = resolutionPolicy;
            resolutionPolicy.init(this);
        };

        /**
        * @method egret.StageDelegate#getScaleX
        */
        StageDelegate.prototype.getScaleX = function () {
            return this._scaleX;
        };

        /**
        * @method egret.StageDelegate#getScaleY
        */
        StageDelegate.prototype.getScaleY = function () {
            return this._scaleY;
        };
        StageDelegate.canvas_name = "gameCanvas";

        StageDelegate.canvas_div_name = "gameDiv";
        return StageDelegate;
    })(egret.HashObject);
    egret.StageDelegate = StageDelegate;

    /**
    * @class egret.ResolutionPolicy
    * @classdesc
    */
    var ResolutionPolicy = (function () {
        function ResolutionPolicy(containerStg, contentStg) {
            this.setContainerStrategy(containerStg);
            this.setContentStrategy(contentStg);
        }
        /**
        * @method egret.ResolutionPolicy#init
        * @param view {egret.StageDelegate}
        */
        ResolutionPolicy.prototype.init = function (view) {
            this._containerStrategy.init(view);
            this._contentStrategy.init(view);
        };

        /**
        * @method egret.ResolutionPolicy#_apply
        * @param view {any}
        * @param designedResolutionWidth {any}
        * @param designedResolutionHeigh {any}
        */
        ResolutionPolicy.prototype._apply = function (view, designedResolutionWidth, designedResolutionHeight) {
            this._containerStrategy._apply(view, designedResolutionWidth, designedResolutionHeight);
            this._contentStrategy._apply(view, designedResolutionWidth, designedResolutionHeight);
        };

        /**
        * @method egret.ResolutionPolicy#setContainerStrategy
        * @param containerStg {any}
        */
        ResolutionPolicy.prototype.setContainerStrategy = function (containerStg) {
            if (containerStg instanceof ContainerStrategy)
                this._containerStrategy = containerStg;
        };

        /**
        * @method egret.ResolutionPolicy#setContentStrategy
        * @param contentStg {any}
        */
        ResolutionPolicy.prototype.setContentStrategy = function (contentStg) {
            if (contentStg instanceof ContentStrategy)
                this._contentStrategy = contentStg;
        };
        return ResolutionPolicy;
    })();
    egret.ResolutionPolicy = ResolutionPolicy;

    /**
    * @class egret.ContainerStrategy
    * @classdesc
    */
    var ContainerStrategy = (function () {
        function ContainerStrategy() {
        }
        /**
        * @method egret.ContainerStrategy.initialize
        */
        ContainerStrategy.initialize = function () {
            ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
        };

        /**
        * @method egret.ContainerStrategy#init
        * @param vie {any}
        */
        ContainerStrategy.prototype.init = function (view) {
        };

        /**
        * @method egret.ContainerStrategy#_apply
        * @param view {any}
        * @param designedWidth {any}
        * @param designedHeigh {any}
        */
        ContainerStrategy.prototype._apply = function (view, designedWidth, designedHeight) {
        };

        ContainerStrategy.prototype._setupContainer = function () {
            var body = document.body, style;
            if (body && (style = body.style)) {
                style.paddingTop = style.paddingTop || "0px";
                style.paddingRight = style.paddingRight || "0px";
                style.paddingBottom = style.paddingBottom || "0px";
                style.paddingLeft = style.paddingLeft || "0px";
                style.borderTop = style.borderTop || "0px";
                style.borderRight = style.borderRight || "0px";
                style.borderBottom = style.borderBottom || "0px";
                style.borderLeft = style.borderLeft || "0px";
                style.marginTop = style.marginTop || "0px";
                style.marginRight = style.marginRight || "0px";
                style.marginBottom = style.marginBottom || "0px";
                style.marginLeft = style.marginLeft || "0px";
            }
            //            var contStyle = document.getElementById(egret.StageDelegate.canvas_div_name).style;
            //            contStyle.position = "fixed";
            //            contStyle.left = contStyle.top = "0px";
            //            document.body.scrollTop = 0;
        };
        return ContainerStrategy;
    })();
    egret.ContainerStrategy = ContainerStrategy;

    /**
    * @class egret.EqualToFrame
    * @classdesc
    * @extends egret.ContainerStrategy
    */
    var EqualToFrame = (function (_super) {
        __extends(EqualToFrame, _super);
        function EqualToFrame() {
            _super.apply(this, arguments);
        }
        EqualToFrame.prototype._apply = function (view) {
            this._setupContainer();
        };
        return EqualToFrame;
    })(ContainerStrategy);
    egret.EqualToFrame = EqualToFrame;

    /**
    * @class egret.ContentStrategy
    * @classdesc
    */
    var ContentStrategy = (function () {
        function ContentStrategy() {
        }
        /**
        * @method egret.ContentStrategy#init
        * @param vie {any}
        */
        ContentStrategy.prototype.init = function (view) {
        };

        /**
        * @method egret.ContentStrategy#_apply
        * @param delegate {egret.StageDelegate}
        * @param designedResolutionWidth {number}
        * @param designedResolutionHeight {number}
        */
        ContentStrategy.prototype._apply = function (delegate, designedResolutionWidth, designedResolutionHeight) {
        };
        return ContentStrategy;
    })();
    egret.ContentStrategy = ContentStrategy;

    /**
    * @class egret.FixedHeight
    * @classdesc
    * @extends egret.ContentStrategy
    */
    var FixedHeight = (function (_super) {
        __extends(FixedHeight, _super);
        function FixedHeight() {
            _super.apply(this, arguments);
        }
        /**
        * @method egret.FixedHeight#_apply
        * @param delegate {any}
        * @param designedResolutionWidth {any}
        * @param designedResolutionHeight {any}
        */
        FixedHeight.prototype._apply = function (delegate, designedResolutionWidth, designedResolutionHeight) {
            var canvas = document.getElementById(StageDelegate.canvas_name);
            var container = document.getElementById(StageDelegate.canvas_div_name);
            var containerW = canvas.width, containerH = canvas.height, designW = designedResolutionWidth, designH = designedResolutionHeight, scale = containerH / designH, contentW = designW * scale, contentH = containerH;

            var viewPortHeight = window.innerHeight;
            scale = viewPortHeight / designH;
            var viewPortWidth = designW * scale;
            canvas.width = designW;
            canvas.height = designH;
            canvas.style.width = viewPortWidth + "px";
            canvas.style.height = viewPortHeight + "px";
            container.style.width = viewPortWidth + "px";
            container.style.height = viewPortHeight + "px";
            delegate._scaleX = scale;
            delegate._scaleY = scale;
        };
        return FixedHeight;
    })(ContentStrategy);
    egret.FixedHeight = FixedHeight;

    /**
    * @class egret.FixedWidth
    * @classdesc
    * @extends egret.ContentStrategy
    */
    var FixedWidth = (function (_super) {
        __extends(FixedWidth, _super);
        function FixedWidth() {
            _super.apply(this, arguments);
        }
        /**
        * @method egret.FixedWidth#_apply
        * @param delegate {egret.StageDelegate}
        * @param designedResolutionWidth {any}
        * @param designedResolutionHeight {any}
        */
        FixedWidth.prototype._apply = function (delegate, designedResolutionWidth, designedResolutionHeight) {
            var canvas = document.getElementById(StageDelegate.canvas_name);
            var container = document.getElementById(StageDelegate.canvas_div_name);
            var viewPortWidth = document.documentElement.clientWidth;
            var viewPortHeight = document.documentElement.clientHeight;
            var scale = viewPortWidth / designedResolutionWidth;
            canvas.width = designedResolutionWidth;
            canvas.height = viewPortHeight / scale;

            canvas.style.width = viewPortWidth + "px";
            canvas.style.height = viewPortHeight + "px";
            container.style.width = viewPortWidth + "px";
            container.style.height = viewPortHeight + "px";
            delegate._scaleX = scale;
            delegate._scaleY = scale;
        };
        return FixedWidth;
    })(ContentStrategy);
    egret.FixedWidth = FixedWidth;

    /**
    * @class egret.FixedSize
    * @classdesc
    * @extends egret.ContentStrategy
    */
    var FixedSize = (function (_super) {
        __extends(FixedSize, _super);
        function FixedSize(width, height) {
            _super.call(this);
            this.width = width;
            this.height = height;
        }
        /**
        * @method egret.FixedSize#_apply
        * @param delegate {egret.StageDelegate}
        * @param designedResolutionWidth {number}
        * @param designedResolutionHeight {number}
        */
        FixedSize.prototype._apply = function (delegate, designedResolutionWidth, designedResolutionHeight) {
            var canvas = document.getElementById(StageDelegate.canvas_name);
            var container = document.getElementById(StageDelegate.canvas_div_name);
            var viewPortWidth = this.width;
            var viewPortHeight = this.height;
            var scale = viewPortWidth / designedResolutionWidth;
            canvas.width = designedResolutionWidth;
            canvas.height = viewPortHeight / scale;

            canvas.style.width = viewPortWidth + "px";
            canvas.style.height = viewPortHeight + "px";
            container.style.width = viewPortWidth + "px";
            container.style.height = viewPortHeight + "px";
            delegate._scaleX = scale;
            delegate._scaleY = scale;
        };
        return FixedSize;
    })(ContentStrategy);
    egret.FixedSize = FixedSize;

    /**
    * @class egret.NoScale
    * @classdesc
    * @extends egret.ContentStrategy
    */
    var NoScale = (function (_super) {
        __extends(NoScale, _super);
        function NoScale(width, height) {
            _super.call(this);
            this.width = width;
            this.height = height;
        }
        /**
        * @method egret.NoScale#_apply
        * @param delegate {egret.StageDelegate}
        * @param designedResolutionWidth {number}
        * @param designedResolutionHeight {number}
        */
        NoScale.prototype._apply = function (delegate, designedResolutionWidth, designedResolutionHeight) {
            var canvas = document.getElementById(StageDelegate.canvas_name);
            canvas.style.width = canvas.width + "px";
            canvas.style.height = canvas.height + "px";
            delegate._scaleX = 1;
            delegate._scaleY = 1;
        };
        return NoScale;
    })(ContentStrategy);
    egret.NoScale = NoScale;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.RenderFilter
    * @classdesc
    * @extends egret.HashObject
    */
    var RenderFilter = (function (_super) {
        __extends(RenderFilter, _super);
        function RenderFilter() {
            _super.call(this);
            this._originalData = {};
            this._drawAreaList = [];
        }
        /**
        * @method egret.egret.getInstance
        * @returns {RenderFilter}
        */
        RenderFilter.getInstance = function () {
            if (RenderFilter.instance == null) {
                RenderFilter.instance = new RenderFilter();
            }
            return RenderFilter.instance;
        };

        /**
        * @method egret.egret#addDrawArea
        * @param area {egret.Rectangle}
        */
        RenderFilter.prototype.addDrawArea = function (area) {
            this._drawAreaList.push(area);
        };

        /**
        * @method egret.egret#clearDrawArea
        */
        RenderFilter.prototype.clearDrawArea = function () {
            this._drawAreaList = [];
        };

        /**
        * 先检查有没有不需要绘制的区域，再把需要绘制的区域绘制出来
        * @method egret.egret#drawImage
        * @param renderContext {any}
        * @param data {RenderData}
        * @param sourceX {any}
        * @param sourceY {any}
        * @param sourceWidth {any}
        * @param sourceHeight {any}
        * @param destX {any}
        * @param destY {any}
        * @param destWidth {any}
        * @param destHeight {any}
        */
        RenderFilter.prototype.drawImage = function (renderContext, data, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
            destX = destX || 0;
            destY = destY || 0;
            var locTexture = data._texture_to_render;
            if (locTexture == null || sourceHeight == 0 || sourceWidth == 0 || destWidth == 0 || destHeight == 0) {
                return;
            }
            if (!data._worldBounds) {
                renderContext.drawImage(locTexture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
                return;
            }
            var originalData = this._originalData;
            originalData.sourceX = sourceX;
            originalData.sourceY = sourceY;
            originalData.sourceWidth = sourceWidth;
            originalData.sourceHeight = sourceHeight;
            originalData.destX = destX;
            originalData.destY = destY;
            originalData.destWidth = destWidth;
            originalData.destHeight = destHeight;

            var locDrawAreaList = this.getDrawAreaList();
            for (var j = 0; j < locDrawAreaList.length; j++) {
                var drawArea = locDrawAreaList[j];
                if (this.ignoreRender(data, drawArea, originalData.destX, originalData.destY)) {
                    continue;
                }

                //在设置过重绘区域时算出不需要绘制的区域
                if (this._drawAreaList.length != 0) {
                    //不能允许有旋转和斜切的显示对象跨过重绘区域
                    if (data._worldTransform.b != 0 || data._worldTransform.c != 0) {
                        //之前已经判断过是否出了重绘区域了
                        if (data._worldBounds.x + originalData.destX < drawArea.x || data._worldBounds.y + originalData.destY < drawArea.y || data._worldBounds.x + data._worldBounds.width + originalData.destX > drawArea.x + drawArea.width || data._worldBounds.y + data._worldBounds.height + originalData.destY > drawArea.y + drawArea.height) {
                            egret.Logger.fatal("请不要让带有旋转和斜切的显示对象跨过重绘区域");
                            return;
                        }
                    } else {
                        //因为有旋转和斜切时候不允许跨过重绘区域，所以缩放属性可以直接这么取
                        var scaleX = data._worldTransform.a;
                        var scaleY = data._worldTransform.d;
                        var offset;
                        if (data._worldBounds.x + originalData.destX < drawArea.x) {
                            offset = (drawArea.x - data._worldBounds.x) / scaleX - originalData.destX;
                            sourceX += offset / (destWidth / sourceWidth);
                            sourceWidth -= offset / (destWidth / sourceWidth);
                            destWidth -= offset;
                            destX += offset;
                        }
                        if (data._worldBounds.y + originalData.destY < drawArea.y) {
                            offset = (drawArea.y - data._worldBounds.y) / scaleY - originalData.destY;
                            sourceY += offset / (destHeight / sourceHeight);
                            sourceHeight -= offset / (destHeight / sourceHeight);
                            destHeight -= offset;
                            destY += offset;
                        }
                        if (data._worldBounds.x + data._worldBounds.width + originalData.destX > drawArea.x + drawArea.width) {
                            offset = (data._worldBounds.x + data._worldBounds.width - drawArea.x - drawArea.width) / scaleX + originalData.destX;
                            sourceWidth -= offset / (destWidth / sourceWidth);
                            destWidth -= offset;
                        }
                        if (data._worldBounds.y + data._worldBounds.height + originalData.destY > drawArea.y + drawArea.height) {
                            offset = (data._worldBounds.y + data._worldBounds.height - drawArea.y - drawArea.height) / scaleY + originalData.destY;
                            sourceHeight -= offset / (destHeight / sourceHeight);
                            destHeight -= offset;
                        }
                    }
                }

                renderContext.drawImage(locTexture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
                //测试代码，把画出来的区域用红框标出来
                //                renderContext.strokeRect(destX, destY, destWidth, destHeight, "#ff0000");
            }
        };

        RenderFilter.prototype.ignoreRender = function (data, rect, destX, destY) {
            var bounds = data._worldBounds;
            var destX = destX * data._worldTransform.a;
            var destY = destY * data._worldTransform.d;
            if (bounds.x + bounds.width + destX <= rect.x || bounds.x + destX >= rect.x + rect.width || bounds.y + bounds.height + destY <= rect.y || bounds.y + destY >= rect.y + rect.height) {
                return true;
            }
            return false;
        };

        /**
        * @method egret.egret#getDrawAreaList
        * @returns {Rectangle}
        */
        RenderFilter.prototype.getDrawAreaList = function () {
            var locDrawAreaList;

            //默认整个舞台都是重绘区域
            if (this._drawAreaList.length == 0) {
                if (!this._defaultDrawAreaList) {
                    this._defaultDrawAreaList = [new egret.Rectangle(0, 0, egret.MainContext.instance.stage.stageWidth, egret.MainContext.instance.stage.stageHeight)];
                }
                locDrawAreaList = this._defaultDrawAreaList;
            } else {
                locDrawAreaList = this._drawAreaList;
            }
            return locDrawAreaList;
        };
        return RenderFilter;
    })(egret.HashObject);
    egret.RenderFilter = RenderFilter;

    
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.Injector
    */
    var Injector = (function () {
        function Injector() {
        }
        /**
        * 以类定义为值进行映射注入，当第一次用getInstance()请求它的单例时才会被实例化。
        * @method egret.Injector.mapClass
        * @param {any} whenAskedFor 传递类定义或类完全限定名作为需要映射的键。
        * @param {any} instantiateClass 传递类作为需要映射的值，它的构造函数必须为空。若不为空，请使用Injector.mapValue()方法直接注入实例。
        * @param {string} named 可选参数，在同一个类作为键需要映射多条规则时，可以传入此参数区分不同的映射。在调用getInstance()方法时要传入同样的参数。
        */
        Injector.mapClass = function (whenAskedFor, instantiateClass, named) {
            if (typeof named === "undefined") { named = ""; }
            var requestName = this.getKey(whenAskedFor) + "#" + named;
            this.mapClassDic[requestName] = instantiateClass;
        };

        /**
        * 获取完全限定类名
        */
        Injector.getKey = function (hostComponentKey) {
            if (typeof (hostComponentKey) == "string")
                return hostComponentKey;
            return egret.getQualifiedClassName(hostComponentKey);
        };

        /**
        * 以实例为值进行映射注入,当用getInstance()请求单例时始终返回注入的这个实例。
        * @method egret.Injector.mapValue
        * @param whenAskedFor {any} 传递类定义或类的完全限定名作为需要映射的键。
        * @param useValue {any} 传递对象实例作为需要映射的值。
        * @param named {string} 可选参数，在同一个类作为键需要映射多条规则时，可以传入此参数区分不同的映射。在调用getInstance()方法时要传入同样的参数。
        */
        Injector.mapValue = function (whenAskedFor, useValue, named) {
            if (typeof named === "undefined") { named = ""; }
            var requestName = this.getKey(whenAskedFor) + "#" + named;
            this.mapValueDic[requestName] = useValue;
        };

        /**
        * 检查指定的映射规则是否存在
        * @method egret.Injector.hasMapRule
        * @param whenAskedFor {any} 传递类定义或类的完全限定名作为需要映射的键。
        * @param named {string} 可选参数，在同一个类作为键需要映射多条规则时，可以传入此参数区分不同的映射。
        */
        Injector.hasMapRule = function (whenAskedFor, named) {
            if (typeof named === "undefined") { named = ""; }
            var requestName = this.getKey(whenAskedFor) + "#" + named;
            if (this.mapValueDic[requestName] || this.mapClassDic[requestName]) {
                return true;
            }
            return false;
        };

        /**
        * 获取指定类映射的单例，注意:这个方法总是返回全局唯一的实例，不会重复创建。
        * @method egret.Injector.getInstance
        * @param clazz {any} 类定义或类的完全限定名
        * @param named {string} 可选参数，若在调用mapClass()映射时设置了这个值，则要传入同样的字符串才能获取对应的单例
        */
        Injector.getInstance = function (clazz, named) {
            if (typeof named === "undefined") { named = ""; }
            var requestName = this.getKey(clazz) + "#" + named;
            if (this.mapValueDic[requestName])
                return this.mapValueDic[requestName];
            var returnClass = (this.mapClassDic[requestName]);
            if (returnClass) {
                var instance = new returnClass();
                this.mapValueDic[requestName] = instance;
                delete this.mapClassDic[requestName];
                return instance;
            }
            throw new Error("调用了未配置的注入规则:" + requestName + "。 请先在项目初始化里配置指定的注入规则，再调用对应单例。");
        };
        Injector.mapClassDic = {};

        Injector.mapValueDic = {};
        return Injector;
    })();
    egret.Injector = Injector;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written pemission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DisplayObject
    * @extends egret.EventDispatcher
    * @classdesc 类是可放在显示列表中的所有对象的基类。该显示列表管理运行时显示的所有对象。使用 DisplayObjectContainer 类排列显示列表中的显示对象。
    *
    * DisplayObjectContainer 对象可以有子显示对象，而其他显示对象是“叶”节点，只有父级和同级，没有子级。
    *
    * DisplayObject 类支持基本功能（如对象的 x 和 y 位置），也支持更高级的对象属性（如它的转换矩阵），所有显示对象都继承自 DisplayObject 类。
    *
    * DisplayObject 类包含若干广播事件。通常，任何特定事件的目标均为一个特定的 DisplayObject 实例。
    *
    * 若只有一个目标，则会将事件侦听器限制为只能放置到该目标上（在某些情况下，可放置到显示列表中该目标的祖代上），这意味着您可以向任何 DisplayObject 实例添加侦听器来侦听广播事件。
    *
    * 任何继承自DisplayObject的类都必须实现以下方法
    * _render();
    * _measureBounds()
    * 不允许重写以下方法
    * _draw();
    * getBounds();
    *
    */
    var DisplayObject = (function (_super) {
        __extends(DisplayObject, _super);
        function DisplayObject() {
            _super.call(this);
            this._parent = null;
            this._cacheAsBitmap = false;
            /**
            * 表示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 x 坐标。
            * @member {number} egret.DisplayObject#x
            */
            this._x = 0;
            /**
            * 表示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 y 坐标。
            * @member {number} egret.DisplayObject#y
            */
            this._y = 0;
            /**
            * 表示从注册点开始应用的对象的水平缩放比例（百分比）。
            * @member {number} egret.DisplayObject#scaleX
            * @default 1
            */
            this._scaleX = 1;
            /**
            * 表示从对象注册点开始应用的对象的垂直缩放比例（百分比）。
            * @member {number} egret.DisplayObject#scaleY
            * @default 1
            */
            this._scaleY = 1;
            /**
            * 表示从对象绝对锚点X。
            * @member {number} egret.DisplayObject#anchorOffsetX
            * @default 0
            */
            this._anchorOffsetX = 0;
            /**
            * 表示从对象绝对锚点Y。
            * @member {number} egret.DisplayObject#anchorOffsetY
            * @default 0
            */
            this._anchorOffsetY = 0;
            /**
            * 表示从对象相对锚点X。
            * @member {number} egret.DisplayObject#anchorX
            * @default 0
            */
            this._anchorX = 0;
            /**
            * 表示从对象相对锚点Y。
            * @member {number} egret.DisplayObject#anchorY
            * @default 0
            */
            this._anchorY = 0;
            /**
            * 显示对象是否可见。
            * @member {boolean} egret.DisplayObject#visible
            */
            this.visible = true;
            /**
            * 表示 DisplayObject 实例距其原始方向的旋转程度，以度为单位
            * @member {number} egret.DisplayObject#rotation
            * @default 0
            */
            this._rotation = 0;
            /**
            * 表示指定对象的 Alpha 透明度值
            * @member {number} egret.DisplayObject#alpha
            *  @default 1
            */
            this._alpha = 1;
            /**
            * 表示DisplayObject的x方向斜切
            * @member {number} egret.DisplayObject#skewX
            * @default 0
            */
            this._skewX = 0;
            /**
            * 表示DisplayObject的y方向斜切
            * @member {number} egret.DisplayObject#skewY
            * @default 0
            */
            this._skewY = 0;
            this._hasWidthSet = false;
            this._hasHeightSet = false;
            this.worldAlpha = 1;
            this._worldTransform = new egret.Matrix();

            //            this._worldBounds = new egret.Rectangle(0, 0, 0, 0);
            this._cacheBounds = new egret.Rectangle(0, 0, 0, 0);
        }
        Object.defineProperty(DisplayObject.prototype, "parent", {
            /**
            * 表示包含此显示对象的 DisplayObjectContainer 对象
            * @member {egret.DisplayObjectContainer} egret.DisplayObject#parent
            */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });

        DisplayObject.prototype._parentChanged = function (parent) {
            this._parent = parent;
        };

        Object.defineProperty(DisplayObject.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._x = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._y = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "scaleX", {
            get: function () {
                return this._scaleX;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._scaleX = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "scaleY", {
            get: function () {
                return this._scaleY;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._scaleY = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "anchorOffsetX", {
            get: function () {
                return this._anchorOffsetX;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._anchorOffsetX = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "anchorOffsetY", {
            get: function () {
                return this._anchorOffsetY;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._anchorOffsetY = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "anchorX", {
            get: function () {
                return this._anchorX;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._anchorX = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "anchorY", {
            get: function () {
                return this._anchorY;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._anchorY = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "rotation", {
            get: function () {
                return this._rotation;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._rotation = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._alpha = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "skewX", {
            get: function () {
                return this._skewX;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._skewX = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "skewY", {
            get: function () {
                return this._skewY;
            },
            set: function (value) {
                if (egret.NumberUtils.isNumber(value)) {
                    this._skewY = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "touchEnabled", {
            get: function () {
                return this._touchEnabled;
            },
            set: function (value) {
                this._touchEnabled = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "scrollRect", {
            get: function () {
                return this._scrollRect;
            },
            set: function (value) {
                this._scrollRect = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DisplayObject.prototype, "measuredWidth", {
            /**
            * 测量宽度
            * @returns {number}
            */
            get: function () {
                return this._measureBounds().width;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DisplayObject.prototype, "measuredHeight", {
            /**
            * 测量高度
            * @returns {number}
            */
            get: function () {
                return this._measureBounds().height;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DisplayObject.prototype, "explicitWidth", {
            get: function () {
                return this._explicitWidth;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DisplayObject.prototype, "explicitHeight", {
            get: function () {
                return this._explicitHeight;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DisplayObject.prototype, "width", {
            /**
            * 宽度，优先顺序为 显式设置宽度 > 测量宽度
            * @member {number} egret.DisplayObject#width
            * @returns {number}
            */
            get: function () {
                return this.getBounds(egret.Rectangle.identity).width;
            },
            /**
            * 显式设置宽度
            * @param value
            */
            set: function (value) {
                this._setWidth(value);
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DisplayObject.prototype, "height", {
            /**
            * 高度，优先顺序为 显式设置高度 > 测量高度
            * @member {number} egret.DisplayObject#height
            * @returns {number}
            */
            get: function () {
                return this.getBounds(egret.Rectangle.identity).height;
            },
            /**
            * 显式设置高度
            * @param value
            */
            set: function (value) {
                this._setHeight(value);
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @inheritDoc
        */
        DisplayObject.prototype._setWidth = function (value) {
            this._explicitWidth = value;
            this._hasWidthSet = egret.NumberUtils.isNumber(value);
        };


        /**
        * @inheritDoc
        */
        DisplayObject.prototype._setHeight = function (value) {
            this._explicitHeight = value;
            this._hasHeightSet = egret.NumberUtils.isNumber(value);
        };

        /**
        * @private
        * @param renderContext
        */
        DisplayObject.prototype._draw = function (renderContext) {
            if (!this.visible) {
                this.destroyCacheBounds();
                return;
            }
            var hasDrawCache = this.drawCacheTexture(renderContext);
            if (hasDrawCache) {
                this.destroyCacheBounds();
                return;
            }
            var o = this;
            renderContext.setAlpha(o.worldAlpha, o.blendMode);
            renderContext.setTransform(o._worldTransform);
            var mask = o.mask || o._scrollRect;
            if (mask) {
                renderContext.pushMask(mask);
            }
            this._render(renderContext);
            if (mask) {
                renderContext.popMask();
            }
            this.destroyCacheBounds();
        };

        DisplayObject.prototype.drawCacheTexture = function (renderContext) {
            var display = this;
            if (display._cacheAsBitmap) {
                var renderTexture = display._texture_to_render;
                var offsetX = renderTexture._offsetX;
                var offsetY = renderTexture._offsetY;
                var width = renderTexture._textureWidth;
                var height = renderTexture._textureHeight;
                display._updateTransform();
                renderContext.setAlpha(display.worldAlpha, display.blendMode);
                renderContext.setTransform(display._worldTransform);
                var scale_factor = egret.MainContext.instance.rendererContext.texture_scale_factor;
                var renderFilter = egret.RenderFilter.getInstance();
                renderFilter.drawImage(renderContext, display, 0, 0, width * scale_factor, height * scale_factor, offsetX, offsetY, width, height);
                return true;
            } else {
                return false;
            }
        };

        /**
        * @private
        * @param renderContext
        */
        DisplayObject.prototype._updateTransform = function () {
            var o = this;
            o._worldTransform.identity().appendMatrix(o._parent._worldTransform);
            var anchorX, anchorY;
            var resultPoint = o._getOffsetPoint();
            anchorX = resultPoint.x;
            anchorY = resultPoint.y;
            o._worldTransform.appendTransform(o._x, o._y, o._scaleX, o._scaleY, o._rotation, o._skewX, o._skewY, anchorX, anchorY);
            if (o._scrollRect) {
                o._worldTransform.append(1, 0, 0, 1, -o._scrollRect.x, -o._scrollRect.y);
            }
            if (false) {
                var bounds = DisplayObject.getTransformBounds(o._getSize(egret.Rectangle.identity), o._worldTransform);
                o._worldBounds.initialize(bounds.x, bounds.y, bounds.width, bounds.height);
            }
            o.worldAlpha = o._parent.worldAlpha * o._alpha;
        };

        /**
        * @private
        * @param renderContext
        */
        DisplayObject.prototype._render = function (renderContext) {
        };

        /**
        * 获取显示对象的测量边界
        * @method egret.DisplayObject#getBounds
        * @param resultRect {Rectangle} 可选参数，传入用于保存结果的Rectangle对象，避免重复创建对象。
        * @returns {Rectangle}
        */
        DisplayObject.prototype.getBounds = function (resultRect) {
            if (this._cacheBounds.x == 0 && this._cacheBounds.y == 0 && this._cacheBounds.width == 0 && this._cacheBounds.height == 0) {
                var rect = this._measureBounds();
                var w = this._hasWidthSet ? this._explicitWidth : rect.width;
                var h = this._hasHeightSet ? this._explicitHeight : rect.height;
                var x = rect.x;
                var y = rect.y;
                var anchorX, anchorY;
                if (this._anchorX != 0 || this._anchorY != 0) {
                    anchorX = w * this._anchorX;
                    anchorY = h * this._anchorY;
                } else {
                    anchorX = this._anchorOffsetX;
                    anchorY = this._anchorOffsetY;
                }
                this._cacheBounds.initialize(x - anchorX, y - anchorY, w, h);
            }
            var result = this._cacheBounds;
            if (!resultRect) {
                resultRect = new egret.Rectangle();
            }
            return resultRect.initialize(result.x, result.y, result.width, result.height);
        };

        DisplayObject.prototype.destroyCacheBounds = function () {
            this._cacheBounds.x = 0;
            this._cacheBounds.y = 0;
            this._cacheBounds.width = 0;
            this._cacheBounds.height = 0;
        };

        DisplayObject.prototype._getConcatenatedMatrix = function () {
            var matrix = DisplayObject.identityMatrixForGetConcatenated.identity();
            var o = this;
            while (o != null) {
                if (o._anchorX != 0 || o._anchorY != 0) {
                    var bounds = o._getSize(egret.Rectangle.identity);
                    matrix.prependTransform(o._x, o._y, o._scaleX, o._scaleY, o._rotation, o._skewX, o._skewY, bounds.width * o._anchorX, bounds.height * o._anchorY);
                } else {
                    matrix.prependTransform(o._x, o._y, o._scaleX, o._scaleY, o._rotation, o._skewX, o._skewY, o._anchorOffsetX, o._anchorOffsetY);
                }
                o = o._parent;
            }
            return matrix;
        };

        /**
        * 将 point 对象从显示对象的（本地）坐标转换为舞台（全局）坐标。
        * @method egret.DisplayObject#localToGlobal
        * @param x {number} 本地x坐标
        * @param y {number} 本地y坐标
        * @param resultPoint {Point} 可选参数，传入用于保存结果的Point对象，避免重复创建对象。
        * @returns {egret.Point}
        */
        DisplayObject.prototype.localToGlobal = function (x, y, resultPoint) {
            if (typeof x === "undefined") { x = 0; }
            if (typeof y === "undefined") { y = 0; }
            var mtx = this._getConcatenatedMatrix();
            mtx.append(1, 0, 0, 1, x, y);
            if (!resultPoint) {
                resultPoint = new egret.Point();
            }
            resultPoint.x = mtx.tx;
            resultPoint.y = mtx.ty;
            return resultPoint;
        };

        /**
        * 将指定舞台坐标（全局）转换为显示对象（本地）坐标。
        * @method egret.DisplayObject#globalToLocal
        * @param x {number} 全局x坐标
        * @param y {number} 全局y坐标
        * @param resultPoint {Point} 可选参数，传入用于保存结果的Point对象，避免重复创建对象。
        * @returns {egret.Point}
        */
        DisplayObject.prototype.globalToLocal = function (x, y, resultPoint) {
            if (typeof x === "undefined") { x = 0; }
            if (typeof y === "undefined") { y = 0; }
            var mtx = this._getConcatenatedMatrix();
            mtx.invert();
            mtx.append(1, 0, 0, 1, x, y);
            if (!resultPoint) {
                resultPoint = new egret.Point();
            }
            resultPoint.x = mtx.tx;
            resultPoint.y = mtx.ty;
            return resultPoint;
        };

        /**
        * 检测指定坐标是否在显示对象内
        * @method egret.DisplayObject#hitTest
        * @param x {number}
        * @param y {number}
        * @param ignoreTouchEnabled 是否忽略TouchEnabled
        * @returns {*}
        */
        DisplayObject.prototype.hitTest = function (x, y, ignoreTouchEnabled) {
            if (typeof ignoreTouchEnabled === "undefined") { ignoreTouchEnabled = false; }
            if (!this.visible || (!ignoreTouchEnabled && !this._touchEnabled)) {
                return null;
            }
            var bound = this._getSize(egret.Rectangle.identity);
            if (0 <= x && x < bound.width && 0 <= y && y < bound.height) {
                if (this.mask || this._scrollRect) {
                    if (this._scrollRect && x < this._scrollRect.width && y < this._scrollRect.height) {
                        return this;
                    } else if (this.mask && this.mask.x <= x && x < this.mask.x + this.mask.width && this.mask.y <= y && y < this.mask.y + this.mask.height) {
                        return this;
                    }
                    return null;
                }
                return this;
            } else {
                return null;
            }
        };

        DisplayObject.prototype.hitTestPoint = function (x, y, shapeFlag) {
            var p = this.globalToLocal(x, y);
            if (!shapeFlag) {
                return !!this.hitTest(p.x, p.y, true);
            } else {
                if (!this._hitTestPointTexture) {
                    this._hitTestPointTexture = new egret.RenderTexture();
                }
                var testTexture = this._hitTestPointTexture;
                testTexture.drawToTexture(this);
                var pixelData = testTexture.getPixel32(p.x - this._hitTestPointTexture._offsetX, p.y - this._hitTestPointTexture._offsetY);
                if (pixelData[3] != 0) {
                    return true;
                }
                return false;
            }
        };

        DisplayObject.prototype._getMatrix = function () {
            var matrix = egret.Matrix.identity.identity();
            var anchorX, anchorY;
            var resultPoint = this._getOffsetPoint();
            anchorX = resultPoint.x;
            anchorY = resultPoint.y;
            matrix.appendTransform(this._x, this._y, this._scaleX, this._scaleY, this._rotation, this._skewX, this._skewY, anchorX, anchorY);
            return matrix;
        };

        DisplayObject.prototype._getSize = function (resultRect) {
            if (this._hasHeightSet && this._hasWidthSet) {
                return resultRect.initialize(NaN, NaN, this._explicitWidth, this._explicitHeight);
            }
            return this._measureSize(egret.Rectangle.identity);
        };

        /**
        * 测量显示对象坐标与大小
        */
        DisplayObject.prototype._measureSize = function (resultRect) {
            return this._measureBounds();
        };

        /**
        * 测量显示对象坐标，这个方法需要子类重写
        * @returns {egret.Rectangle}
        * @private
        */
        DisplayObject.prototype._measureBounds = function () {
            return egret.Rectangle.identity.initialize(0, 0, 0, 0);
        };

        DisplayObject.prototype._getOffsetPoint = function () {
            var o = this;
            var regX = o._anchorOffsetX;
            var regY = o._anchorOffsetY;
            if (o._anchorX != 0 || o._anchorY != 0) {
                var bounds = o._getSize(egret.Rectangle.identity);
                regX = o._anchorX * bounds.width;
                regY = o._anchorY * bounds.height;
            }
            var result = egret.Point.identity;
            result.x = regX;
            result.y = regY;
            return result;
        };

        DisplayObject.prototype._onAddToStage = function () {
            this._stage = egret.MainContext.instance.stage;
            egret.DisplayObjectContainer.__EVENT__ADD_TO_STAGE_LIST.push(this);
        };

        DisplayObject.prototype._onRemoveFromStage = function () {
            this._stage = null;
            egret.DisplayObjectContainer.__EVENT__REMOVE_FROM_STAGE_LIST.push(this);
        };

        Object.defineProperty(DisplayObject.prototype, "stage", {
            /**
            * 获取舞台对象。当该显示对象不在舞台上时，此属性返回 undefined
            * @member {number} egret.DisplayObject#stage
            * @returns {egret.Stage}
            */
            get: function () {
                return this._stage;
            },
            enumerable: true,
            configurable: true
        });

        DisplayObject.prototype.addEventListener = function (type, listener, thisObject, useCapture, priority) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            if (typeof priority === "undefined") { priority = 0; }
            _super.prototype.addEventListener.call(this, type, listener, thisObject, useCapture, priority);
            var isEnterFrame = (type == egret.Event.ENTER_FRAME);
            if (isEnterFrame || type == egret.Event.RENDER) {
                var list = isEnterFrame ? DisplayObject._enterFrameCallBackList : DisplayObject._renderCallBackList;
                this._insertEventBin(list, listener, thisObject, priority);
            }
        };

        DisplayObject.prototype.removeEventListener = function (type, listener, thisObject, useCapture) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            _super.prototype.removeEventListener.call(this, type, listener, thisObject, useCapture);
            var isEnterFrame = (type == egret.Event.ENTER_FRAME);
            if (isEnterFrame || type == egret.Event.RENDER) {
                var list = isEnterFrame ? DisplayObject._enterFrameCallBackList : DisplayObject._renderCallBackList;
                this._removeEventBin(list, listener, thisObject);
            }
        };

        DisplayObject.prototype.dispatchEvent = function (event) {
            if (!event._bubbles) {
                return _super.prototype.dispatchEvent.call(this, event);
            }

            var list = [];
            var target = this;
            while (target) {
                list.unshift(target);
                target = target.parent;
            }

            var length = list.length;
            var targetIndex = length - 1;
            for (var i = length - 2; i >= 0; i--) {
                list.push(list[i]);
            }
            event._reset();
            this._dispatchPropagationEvent(event, list, targetIndex);
            return !event.isDefaultPrevented();
        };

        DisplayObject.prototype._dispatchPropagationEvent = function (event, list, targetIndex) {
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var currentTarget = list[i];
                event._setCurrentTarget(currentTarget);
                event._target = this;
                if (i < targetIndex)
                    event._eventPhase = 1;
                else if (i == targetIndex)
                    event._eventPhase = 2;
                else
                    event._eventPhase = 3;
                currentTarget._notifyListener(event);
                if (event._isPropagationStopped || event._isPropagationImmediateStopped) {
                    break;
                }
            }
        };

        DisplayObject.prototype.willTrigger = function (type) {
            var parent = this;
            while (parent) {
                if (parent.hasEventListener(type))
                    return true;
                parent = parent._parent;
            }
            return false;
        };

        Object.defineProperty(DisplayObject.prototype, "cacheAsBitmap", {
            get: function () {
                return this._cacheAsBitmap;
            },
            set: function (bool) {
                this._cacheAsBitmap = bool;
                if (bool) {
                    if (!this.renderTexture) {
                        this.renderTexture = new egret.RenderTexture();
                    }
                    this.renderTexture.drawToTexture(this);
                    this._texture_to_render = this.renderTexture;
                } else {
                    this._texture_to_render = null;
                }
            },
            enumerable: true,
            configurable: true
        });


        DisplayObject.getTransformBounds = function (bounds, mtx) {
            //            var x = bounds.x, y = bounds.y;
            var x, y;
            var width = bounds.width, height = bounds.height;

            //            if (x || y) {
            //                mtx.appendTransform(0, 0, 1, 1, 0, 0, 0, -x, -y);
            //            }
            //        if (matrix) { mtx.prependMatrix(matrix); }
            var x_a = width * mtx.a, x_b = width * mtx.b;
            var y_c = height * mtx.c, y_d = height * mtx.d;
            var tx = mtx.tx, ty = mtx.ty;

            var minX = tx, maxX = tx, minY = ty, maxY = ty;

            if ((x = x_a + tx) < minX) {
                minX = x;
            } else if (x > maxX) {
                maxX = x;
            }
            if ((x = x_a + y_c + tx) < minX) {
                minX = x;
            } else if (x > maxX) {
                maxX = x;
            }
            if ((x = y_c + tx) < minX) {
                minX = x;
            } else if (x > maxX) {
                maxX = x;
            }

            if ((y = x_b + ty) < minY) {
                minY = y;
            } else if (y > maxY) {
                maxY = y;
            }
            if ((y = x_b + y_d + ty) < minY) {
                minY = y;
            } else if (y > maxY) {
                maxY = y;
            }
            if ((y = y_d + ty) < minY) {
                minY = y;
            } else if (y > maxY) {
                maxY = y;
            }

            return bounds.initialize(minX, minY, maxX - minX, maxY - minY);
        };
        DisplayObject.identityMatrixForGetConcatenated = new egret.Matrix();

        DisplayObject._enterFrameCallBackList = [];
        DisplayObject._renderCallBackList = [];
        return DisplayObject;
    })(egret.EventDispatcher);
    egret.DisplayObject = DisplayObject;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DisplayObjectContainer
    * @classdesc
    * DisplayObjectContainer 类是显示列表中显示对象容器。
    */
    var DisplayObjectContainer = (function (_super) {
        __extends(DisplayObjectContainer, _super);
        function DisplayObjectContainer() {
            _super.call(this);
            this._touchChildren = true;
            this._children = [];
        }
        Object.defineProperty(DisplayObjectContainer.prototype, "touchChildren", {
            /**
            * 指定此对象的子项以及子孙项是否接收鼠标/触摸事件
            * @member {boolean} egret.DisplayObjectContainer#touchChildren
            */
            get: function () {
                return this._touchChildren;
            },
            set: function (value) {
                this._touchChildren = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
            /**
            * 返回此对象的子项数目。
            * @member {number} egret.DisplayObjectContainer#numChildren
            */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 更改现有子项在显示对象容器中的位置。这会影响子对象的分层。
        * @method egret.DisplayObjectContainer#setChildIndex
        * @param child {egret.DisplayObject} 要为其更改索引编号的 DisplayObject 子实例。
        * @param index {number} 生成的 child 显示对象的索引编号。当新的索引编号小于0或大于已有子元件数量时，新加入的DisplayObject对象将会放置于最上层。
        */
        DisplayObjectContainer.prototype.setChildIndex = function (child, index) {
            this.doSetChildIndex(child, index);
        };

        DisplayObjectContainer.prototype.doSetChildIndex = function (child, index) {
            var lastIdx = this._children.indexOf(child);
            if (lastIdx < 0) {
                egret.Logger.fatal("child不在当前容器内");
            }

            //从原来的位置删除
            this._children.splice(lastIdx, 1);

            //放到新的位置
            if (index < 0 || this._children.length <= index) {
                this._children.push(child);
            } else {
                this._children.splice(index, 0, child);
            }
        };

        /**
        * 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。子项将被添加到该 DisplayObjectContainer 实例中其他所有子项的前（上）面。（要将某子项添加到特定索引位置，请使用 addChildAt() 方法。）
        * @method egret.DisplayObjectContainer#addChild
        * @param child {egret.DisplayObject} 要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
        * @returns {egret.DisplayObject} 在 child 参数中传递的 DisplayObject 实例。
        */
        DisplayObjectContainer.prototype.addChild = function (child) {
            var index = this.numChildren;

            if (child._parent == this)
                index--;

            return this._doAddChild(child, index);
        };

        /**
        * 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。该子项将被添加到指定的索引位置。索引为 0 表示该 DisplayObjectContainer 对象的显示列表的后（底）部。如果索引值为-1，则表示该DisplayObjectContainer 对象的显示列表的前（上）部。
        * @method egret.DisplayObjectContainer#addChildAt
        * @param child {egret.DisplayObject} 要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
        * @param index {number} 添加该子项的索引位置。 如果指定当前占用的索引位置，则该位置以及所有更高位置上的子对象会在子级列表中上移一个位置。
        * @returns {egret.DisplayObject} 在 child 参数中传递的 DisplayObject 实例。
        */
        DisplayObjectContainer.prototype.addChildAt = function (child, index) {
            return this._doAddChild(child, index);
        };

        DisplayObjectContainer.prototype._doAddChild = function (child, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (child == this)
                return child;

            if (index < 0 || index > this._children.length) {
                egret.Logger.fatal("提供的索引超出范围");
                return child;
            }

            var host = child.parent;
            if (host == this) {
                this.doSetChildIndex(child, index);
                return child;
            }
            if (host) {
                host.removeChild(child);
            }

            this._children.splice(index, 0, child);
            child._parentChanged(this);
            if (notifyListeners)
                child.dispatchEventWith(egret.Event.ADDED, true);
            if (this._stage) {
                child._onAddToStage();
                var list = DisplayObjectContainer.__EVENT__ADD_TO_STAGE_LIST;
                while (list.length > 0) {
                    var childAddToStage = list.shift();
                    childAddToStage.dispatchEventWith(egret.Event.ADDED_TO_STAGE);
                }
            }

            return child;
        };

        /**
        * 将一个 DisplayObject 子实例从 DisplayObjectContainer 实例中移除。
        * @method egret.DisplayObjectContainer#removeChild
        * @param child {egret.DisplayObject} 要删除的 DisplayObject 实例。
        * @returns {egret.DisplayObject} 在 child 参数中传递的 DisplayObject 实例。
        */
        DisplayObjectContainer.prototype.removeChild = function (child) {
            var index = this._children.indexOf(child);
            if (index >= 0) {
                return this._doRemoveChild(index);
            } else {
                egret.Logger.fatal("child未被addChild到该parent");
                return null;
            }
        };

        /**
        * 从 DisplayObjectContainer 的子列表中指定的 index 位置删除子 DisplayObject。
        * @method egret.DisplayObjectContainer#removeChildAt
        * @param index {number} 要删除的 DisplayObject 的子索引。
        * @returns {egret.DisplayObject} 已删除的 DisplayObject 实例。
        */
        DisplayObjectContainer.prototype.removeChildAt = function (index) {
            if (index >= 0 && index < this._children.length) {
                return this._doRemoveChild(index);
            } else {
                egret.Logger.fatal("提供的索引超出范围");
                return null;
            }
        };

        DisplayObjectContainer.prototype._doRemoveChild = function (index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            var locChildren = this._children;
            var child = locChildren[index];
            if (notifyListeners)
                child.dispatchEventWith(egret.Event.REMOVED, true);
            if (this._stage) {
                child._onRemoveFromStage();
                var list = DisplayObjectContainer.__EVENT__REMOVE_FROM_STAGE_LIST;
                while (list.length > 0) {
                    var childAddToStage = list.shift();
                    childAddToStage.dispatchEventWith(egret.Event.REMOVED_FROM_STAGE);
                }
            }
            child._parentChanged(null);
            locChildren.splice(index, 1);
            return child;
        };

        /**
        * 返回位于指定索引处的子显示对象实例。
        * @method egret.DisplayObjectContainer#getChildAt
        * @param index {number} 子对象的索引位置。
        * @returns {egret.DisplayObject} 位于指定索引位置处的子显示对象。
        */
        DisplayObjectContainer.prototype.getChildAt = function (index) {
            if (index >= 0 && index < this._children.length) {
                return this._children[index];
            } else {
                egret.Logger.fatal("提供的索引超出范围");
                return null;
            }
        };

        /**
        * 确定指定显示对象是 DisplayObjectContainer 实例的子项还是该实例本身。搜索包括整个显示列表（其中包括此 DisplayObjectContainer 实例）。孙项、曾孙项等，每项都返回 true。
        * @method egret.DisplayObjectContainer#contains
        * @param child {egret.DisplayObject} 要测试的子对象。
        * @returns {boolean} 如果指定的显示对象为DisplayObjectContainer该实例本身，则返回true，如果指定的显示对象为当前实例子项，则返回false。
        */
        DisplayObjectContainer.prototype.contains = function (child) {
            while (child) {
                if (child == this) {
                    return true;
                }
                child = child._parent;
            }
            return false;
        };

        /**
        * 在子级列表中两个指定的索引位置，交换子对象的 Z 轴顺序（前后顺序）。显示对象容器中所有其他子对象的索引位置保持不变。
        * @method egret.DisplayObjectContainer#swapChildrenAt
        * @param index1 {number} 第一个子对象的索引位置。
        * @param index2 {number} 第二个子对象的索引位置。
        */
        DisplayObjectContainer.prototype.swapChildrenAt = function (index1, index2) {
            if (index1 >= 0 && index1 < this._children.length && index2 >= 0 && index2 < this._children.length) {
                this._swapChildrenAt(index1, index2);
            } else {
                egret.Logger.fatal("提供的索引超出范围");
            }
        };

        /**
        * 交换两个指定子对象的 Z 轴顺序（从前到后顺序）。显示对象容器中所有其他子对象的索引位置保持不变。
        * @method egret.DisplayObjectContainer#swapChildren
        * @param child1 {egret.DisplayObject} 第一个子对象。
        * @param child2 {egret.DisplayObject} 第二个子对象。
        */
        DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
            var index1 = this._children.indexOf(child1);
            var index2 = this._children.indexOf(child2);
            if (index1 == -1 || index2 == -1) {
                egret.Logger.fatal("child未被addChild到该parent");
            } else {
                this._swapChildrenAt(index1, index2);
            }
        };

        DisplayObjectContainer.prototype._swapChildrenAt = function (index1, index2) {
            if (index1 == index2) {
                return;
            }
            var list = this._children;
            var child = list[index1];
            list[index1] = list[index2];
            list[index2] = child;
        };

        /**
        * 返回 DisplayObject 的 child 实例的索引位置。
        * @method egret.DisplayObjectContainer#getChildIndex
        * @param child {egret.DisplayObject} 要标识的 DisplayObject 实例。
        * @returns {number} 要标识的子显示对象的索引位置。
        */
        DisplayObjectContainer.prototype.getChildIndex = function (child) {
            return this._children.indexOf(child);
        };

        /**
        * 从 DisplayObjectContainer 实例的子级列表中删除所有 child DisplayObject 实例。
        * @method egret.DisplayObjectContainer#removeChildren
        */
        DisplayObjectContainer.prototype.removeChildren = function () {
            var locChildren = this._children;
            for (var i = locChildren.length - 1; i >= 0; i--) {
                this._doRemoveChild(i);
            }
        };

        DisplayObjectContainer.prototype._updateTransform = function () {
            if (!this.visible) {
                return;
            }
            _super.prototype._updateTransform.call(this);
            for (var i = 0, length = this._children.length; i < length; i++) {
                var child = this._children[i];
                child._updateTransform();
            }
        };

        DisplayObjectContainer.prototype._render = function (renderContext) {
            for (var i = 0, length = this._children.length; i < length; i++) {
                var child = this._children[i];
                child._draw(renderContext);
            }
        };

        /**
        * @see egret.DisplayObject._measureBounds
        * @returns {null}
        * @private
        */
        DisplayObjectContainer.prototype._measureBounds = function () {
            var minX = 0, maxX = 0, minY = 0, maxY = 0;
            var l = this._children.length;
            for (var i = 0; i < l; i++) {
                var child = this._children[i];
                var bounds;
                if (!child.visible || !(bounds = egret.DisplayObject.getTransformBounds(child._getSize(egret.Rectangle.identity), child._getMatrix()))) {
                    continue;
                }
                var x1 = bounds.x, y1 = bounds.y, x2 = bounds.width + bounds.x, y2 = bounds.height + bounds.y;
                if (x1 < minX || i == 0) {
                    minX = x1;
                }
                if (x2 > maxX || i == 0) {
                    maxX = x2;
                }
                if (y1 < minY || i == 0) {
                    minY = y1;
                }
                if (y2 > maxY || i == 0) {
                    maxY = y2;
                }
            }

            return egret.Rectangle.identity.initialize(minX, minY, maxX - minX, maxY - minY);
        };

        /**
        * @method egret.DisplayObjectContainer#hitTest
        * @see egret.DisplayObject.hitTest
        * @param x {number}
        * @param y {number}
        * @param ignoreTouchEnabled {boolean}
        * @returns {egret.DisplayObject}
        */
        DisplayObjectContainer.prototype.hitTest = function (x, y, ignoreTouchEnabled) {
            if (typeof ignoreTouchEnabled === "undefined") { ignoreTouchEnabled = false; }
            var result;
            if (!this.visible) {
                return null;
            }
            if (this._scrollRect) {
                if (x > this._scrollRect.width || y > this._scrollRect.height) {
                    return null;
                }
            } else if (this.mask) {
                if (this.mask.x > x || x > this.mask.x + this.mask.width || this.mask.y > y || y > this.mask.y + this.mask.height) {
                    return null;
                }
            }
            var children = this._children;
            var l = children.length;
            var touchChildren = this._touchChildren;
            for (var i = l - 1; i >= 0; i--) {
                var child = children[i];
                var o = child;
                var offsetPoint = o._getOffsetPoint();
                var childX = o._x;
                var childY = o._y;
                if (this._scrollRect) {
                    childX -= this._scrollRect.x;
                    childY -= this._scrollRect.y;
                }
                var mtx = egret.Matrix.identity.identity().prependTransform(childX, childY, o._scaleX, o._scaleY, o._rotation, 0, 0, offsetPoint.x, offsetPoint.y);
                mtx.invert();
                var point = egret.Matrix.transformCoords(mtx, x, y);
                var childHitTestResult = child.hitTest(point.x, point.y, true);
                if (childHitTestResult) {
                    if (childHitTestResult._touchEnabled && touchChildren) {
                        return childHitTestResult;
                    } else if (this._touchEnabled) {
                        return this;
                    }
                    if (result == null) {
                        result = childHitTestResult;
                    }
                }
            }
            if (!result) {
                return _super.prototype.hitTest.call(this, x, y, ignoreTouchEnabled);
            }
            return result;
        };

        DisplayObjectContainer.prototype._onAddToStage = function () {
            _super.prototype._onAddToStage.call(this);
            var length = this.numChildren;
            for (var i = 0; i < length; i++) {
                var child = this._children[i];
                child._onAddToStage();
            }
        };

        DisplayObjectContainer.prototype._onRemoveFromStage = function () {
            _super.prototype._onRemoveFromStage.call(this);
            var length = this.numChildren;
            for (var i = 0; i < length; i++) {
                var child = this._children[i];
                child._onRemoveFromStage();
            }
        };

        /**
        * 返回具有指定名称的子显示对象。
        * @method egret.DisplayObjectContainer#getChildByName
        * @param name {string} 要返回的子项的名称。
        * @returns {egret.DisplayObject} 具有指定名称的子显示对象。
        */
        DisplayObjectContainer.prototype.getChildByName = function (name) {
            var locChildren = this._children;
            var count = this.numChildren;
            var displayObject;
            for (var i = 0; i < count; i++) {
                displayObject = locChildren[i];
                if (displayObject.name == name) {
                    return displayObject;
                }
            }
            return null;
        };
        DisplayObjectContainer.__EVENT__ADD_TO_STAGE_LIST = [];
        DisplayObjectContainer.__EVENT__REMOVE_FROM_STAGE_LIST = [];
        return DisplayObjectContainer;
    })(egret.DisplayObject);
    egret.DisplayObjectContainer = DisplayObjectContainer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Stage
    * @classdesc Stage 类代表主绘图区。
    */
    var Stage = (function (_super) {
        __extends(Stage, _super);
        function Stage(width, height) {
            _super.call(this);
            this.touchEnabled = true;
            this._stage = this;
            this._stageWidth = width;
            this._stageHeight = height;
        }
        /**
        * 调用 invalidate() 方法后，在显示列表下次呈现时，Egret 会向每个已注册侦听 render 事件的显示对象发送一个 render 事件。
        * 每次您希望 Egret 发送 render 事件时，都必须调用 invalidate() 方法。
        * @method egret.Stage#invalidate
        */
        Stage.prototype.invalidate = function () {
            Stage._invalidateRenderFlag = true;
        };

        /**
        * 设置舞台宽高
        */
        Stage.prototype._setStageSize = function (width, height) {
            if (this._stageWidth == width && this._stageHeight == height) {
                return;
            }
            this._stageWidth = width;
            this._stageHeight = height;
            this.dispatchEventWith(egret.Event.RESIZE);
        };

        Object.defineProperty(Stage.prototype, "stageWidth", {
            /**
            * @member {number} egret.Stage#stageWidth
            * 舞台宽度（坐标系宽度，非设备宽度）
            */
            get: function () {
                return this._stageWidth;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "stageHeight", {
            /**
            * @member {number} egret.Stage#stageHeight
            * 舞台高度（坐标系高度，非设备高度）
            */
            get: function () {
                return this._stageHeight;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @member egret.Stage#hitTest
        * @see egret.DisplayObject#hitTest
        * @param x
        * @param y
        * @returns {egret.DisplayObject}
        */
        Stage.prototype.hitTest = function (x, y) {
            if (!this.touchEnabled) {
                return null;
            }
            var result;
            if (!this.visible) {
                return this;
            }
            var children = this._children;
            var l = children.length;
            for (var i = l - 1; i >= 0; i--) {
                var child = children[i];
                var o = child;
                var offsetPoint = o._getOffsetPoint();
                var mtx = egret.Matrix.identity.identity().prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, 0, 0, offsetPoint.x, offsetPoint.y);
                mtx.invert();
                var point = egret.Matrix.transformCoords(mtx, x, y);
                result = child.hitTest(point.x, point.y, true);
                if (result) {
                    if (result.touchEnabled) {
                        return result;
                    }
                }
            }
            return this;
        };

        /**
        * @member egret.Stage#getBounds
        * @see egret.DisplayObject#getBounds
        * @param resultRect {egret.Rectangle} 可选参数，传入用于保存结果的Rectangle对象，避免重复创建对象。
        * @returns {egret.Rectangle}
        */
        Stage.prototype.getBounds = function (resultRect) {
            if (!resultRect) {
                resultRect = new egret.Rectangle();
            }
            return resultRect.initialize(0, 0, this._stageWidth, this._stageHeight);
        };

        Stage.prototype._updateTransform = function () {
            for (var i = 0, length = this._children.length; i < length; i++) {
                var child = this._children[i];
                child._updateTransform();
            }
        };
        Stage._invalidateRenderFlag = false;
        return Stage;
    })(egret.DisplayObjectContainer);
    egret.Stage = Stage;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.BitmapFillMode
    * @classdesc
    * BitmapFillMode 类定义Bitmap的图像填充方式。
    */
    var BitmapFillMode = (function () {
        function BitmapFillMode() {
        }
        BitmapFillMode.REPEAT = "repeat";

        BitmapFillMode.SCALE = "scale";
        return BitmapFillMode;
    })();
    egret.BitmapFillMode = BitmapFillMode;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Bitmap
    * @classdesc
    * Bitmap 类表示用于表示位图图像的显示对象。
    * @extends egret.DisplayObject
    */
    var Bitmap = (function (_super) {
        __extends(Bitmap, _super);
        function Bitmap(texture) {
            _super.call(this);
            /**
            * 单个Bitmap是否开启DEBUG模式
            * @member {boolean} egret.Bitmap#debug
            */
            this.debug = false;
            /**
            * debug边框颜色，默认值为红色
            * @member {number} egret.Bitmap#debugColor
            */
            this.debugColor = 0xff0000;
            /**
            * 确定位图填充尺寸的方式。默认值：BitmapFillMode.SCALE。
            * 设置为 BitmapFillMode.REPEAT时，位图将重复以填充区域。
            * 设置为 BitmapFillMode.SCALE时，位图将拉伸以填充区域。
            * @member {egret.Texture} egret.Bitmap#fillMode
            */
            this.fillMode = "scale";
            if (texture) {
                this.texture = texture;
            }
        }
        Bitmap.prototype._render = function (renderContext) {
            var texture = this.texture;
            if (!texture) {
                this._texture_to_render = null;
                return;
            }
            this._texture_to_render = texture;
            var destW = this._hasWidthSet ? this._explicitWidth : texture._textureWidth;
            var destH = this._hasHeightSet ? this._explicitHeight : texture._textureHeight;
            Bitmap._drawBitmap(renderContext, destW, destH, this);
        };

        Bitmap._drawBitmap = function (renderContext, destW, destH, thisObject) {
            var texture = thisObject._texture_to_render;
            if (!texture) {
                return;
            }
            var textureWidth = texture._textureWidth;
            var textureHeight = texture._textureHeight;
            if (thisObject.fillMode == "scale") {
                var s9g = thisObject.scale9Grid;
                if (s9g && textureWidth - s9g.width < destW && textureHeight - s9g.height < destH) {
                    Bitmap.drawScale9GridImage(renderContext, thisObject, thisObject.scale9Grid, destW, destH);
                } else {
                    var offsetX = texture._offsetX;
                    var offsetY = texture._offsetY;
                    var bitmapWidth = texture._bitmapWidth || textureWidth;
                    var bitmapHeight = texture._bitmapHeight || textureHeight;
                    if (thisObject._hasWidthSet) {
                        var scaleX = destW / textureWidth;
                        offsetX = Math.round(offsetX * scaleX);
                        destW = Math.round(bitmapWidth * scaleX);
                    } else {
                        destW = bitmapWidth;
                    }
                    if (thisObject._hasHeightSet) {
                        var scaleY = destH / textureHeight;
                        offsetY = Math.round(offsetY * scaleY);
                        destH = Math.round(bitmapHeight * scaleY);
                    } else {
                        destH = bitmapHeight;
                    }

                    egret.RenderFilter.getInstance().drawImage(renderContext, thisObject, texture._bitmapX, texture._bitmapY, bitmapWidth, bitmapHeight, offsetX, offsetY, destW, destH);
                }
            } else {
                Bitmap.drawRepeatImage(renderContext, thisObject, destW, destH);
            }
        };

        /**
        * 绘制平铺位图
        */
        Bitmap.drawRepeatImage = function (renderContext, data, destWidth, destHeight) {
            var texture = data._texture_to_render;
            if (!texture) {
                return;
            }
            var textureWidth = texture._textureWidth;
            var textureHeight = texture._textureHeight;
            var sourceX = texture._bitmapX;
            var sourceY = texture._bitmapY;
            var sourceWidth = texture._bitmapWidth || textureWidth;
            var sourceHeight = texture._bitmapHeight || textureHeight;
            var destX = texture._offsetX;
            var destY = texture._offsetY;

            var renderFilter = egret.RenderFilter.getInstance();
            for (var x = destX; x < destWidth; x += textureWidth) {
                for (var y = destY; y < destHeight; y += textureHeight) {
                    var destW = Math.min(sourceWidth, destWidth - x);
                    var destH = Math.min(sourceHeight, destHeight - y);
                    renderFilter.drawImage(renderContext, data, sourceX, sourceY, sourceWidth, sourceHeight, x, y, destW, destH);
                }
            }
        };

        /**
        * 绘制九宫格位图
        */
        Bitmap.drawScale9GridImage = function (renderContext, data, scale9Grid, destWidth, destHeight) {
            var texture = data._texture_to_render;
            if (!texture || !scale9Grid) {
                return;
            }
            var renderFilter = egret.RenderFilter.getInstance();
            var textureWidth = texture._textureWidth;
            var textureHeight = texture._textureHeight;
            var sourceX = texture._bitmapX;
            var sourceY = texture._bitmapY;
            var sourceWidth = texture._bitmapWidth || textureWidth;
            var sourceHeight = texture._bitmapHeight || textureHeight;
            var destX = texture._offsetX;
            var destY = texture._offsetY;

            var s9g = egret.Rectangle.identity.initialize(scale9Grid.x - Math.round(destX), scale9Grid.y - Math.round(destX), scale9Grid.width, scale9Grid.height);
            var roundedDrawX = Math.round(destX);
            var roundedDrawY = Math.round(destY);
            destWidth -= textureWidth - sourceWidth;
            destHeight -= textureHeight - sourceHeight;

            //防止空心的情况出现。
            if (s9g.y == s9g.bottom) {
                if (s9g.bottom < sourceHeight)
                    s9g.bottom++;
                else
                    s9g.y--;
            }
            if (s9g.x == s9g.right) {
                if (s9g.right < sourceWidth)
                    s9g.right++;
                else
                    s9g.x--;
            }

            var sourceX2 = sourceX + s9g.x;
            var sourceX3 = sourceX + s9g.right;
            var sourceRightW = sourceWidth - s9g.right;
            var sourceY2 = sourceY + s9g.y;
            var sourceY3 = sourceY + s9g.bottom;
            var sourceBottomH = sourceHeight - s9g.bottom;

            var destX1 = roundedDrawX + s9g.x;
            var destY1 = roundedDrawY + s9g.y;
            var destScaleGridBottom = destHeight - (sourceHeight - s9g.bottom);
            var destScaleGridRight = destWidth - (sourceWidth - s9g.right);

            renderFilter.drawImage(renderContext, data, sourceX, sourceY, s9g.x, s9g.y, roundedDrawX, roundedDrawY, s9g.x, s9g.y);
            renderFilter.drawImage(renderContext, data, sourceX2, sourceY, s9g.width, s9g.y, destX1, roundedDrawY, destScaleGridRight - s9g.x, s9g.y);
            renderFilter.drawImage(renderContext, data, sourceX3, sourceY, sourceRightW, s9g.y, roundedDrawX + destScaleGridRight, roundedDrawY, destWidth - destScaleGridRight, s9g.y);
            renderFilter.drawImage(renderContext, data, sourceX, sourceY2, s9g.x, s9g.height, roundedDrawX, destY1, s9g.x, destScaleGridBottom - s9g.y);
            renderFilter.drawImage(renderContext, data, sourceX2, sourceY2, s9g.width, s9g.height, destX1, destY1, destScaleGridRight - s9g.x, destScaleGridBottom - s9g.y);
            renderFilter.drawImage(renderContext, data, sourceX3, sourceY2, sourceRightW, s9g.height, roundedDrawX + destScaleGridRight, destY1, destWidth - destScaleGridRight, destScaleGridBottom - s9g.y);
            renderFilter.drawImage(renderContext, data, sourceX, sourceY3, s9g.x, sourceBottomH, roundedDrawX, roundedDrawY + destScaleGridBottom, s9g.x, destHeight - destScaleGridBottom);
            renderFilter.drawImage(renderContext, data, sourceX2, sourceY3, s9g.width, sourceBottomH, destX1, roundedDrawY + destScaleGridBottom, destScaleGridRight - s9g.x, destHeight - destScaleGridBottom);
            renderFilter.drawImage(renderContext, data, sourceX3, sourceY3, sourceRightW, sourceBottomH, roundedDrawX + destScaleGridRight, roundedDrawY + destScaleGridBottom, destWidth - destScaleGridRight, destHeight - destScaleGridBottom);
        };

        /**
        * @see egret.DisplayObject.measureBounds
        * @returns {egret.Rectangle}
        * @private
        */
        Bitmap.prototype._measureBounds = function () {
            var texture = this.texture;
            if (!texture) {
                return _super.prototype._measureBounds.call(this);
            }
            var x = texture._offsetX;
            var y = texture._offsetY;
            var w = texture._textureWidth;
            var h = texture._textureHeight;
            return egret.Rectangle.identity.initialize(x, y, w, h);
        };
        Bitmap.debug = false;
        return Bitmap;
    })(egret.DisplayObject);
    egret.Bitmap = Bitmap;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class BitmapText
    * 位图字体采用了Bitmap+SpriteSheet的方式来渲染文字
    */
    var BitmapText = (function (_super) {
        __extends(BitmapText, _super);
        function BitmapText() {
            _super.call(this);
            /**
            * 设置文本
            */
            this.text = "";
            this._bitmapPool = [];
        }
        BitmapText.prototype._updateTransform = function () {
            if (!this.visible) {
                return;
            }
            this._renderText();
            _super.prototype._updateTransform.call(this);
        };

        //todo:这里对bounds的处理和TextField非常类似，以后考虑重构
        BitmapText.prototype._renderText = function (forMeasureContentSize) {
            if (typeof forMeasureContentSize === "undefined") { forMeasureContentSize = false; }
            var tempW = 0;
            var tempH = 0;
            if (!forMeasureContentSize) {
                this.removeChildren();
            }
            for (var i = 0, l = this.text.length; i < l; i++) {
                var character = this.text.charAt(i);
                var texture = this.spriteSheet.getTexture(character);
                if (texture == null) {
                    console.log("当前没有位图文字：" + character);
                    continue;
                }
                var offsetX = texture._offsetX;
                var offsetY = texture._offsetY;
                var characterWidth = texture._textureWidth;
                if (!forMeasureContentSize) {
                    var bitmap = this._bitmapPool[i];
                    if (!bitmap) {
                        bitmap = new egret.Bitmap();
                        this._bitmapPool.push(bitmap);
                    }
                    bitmap.texture = texture;
                    this.addChild(bitmap);
                    bitmap.x = tempW;
                }
                tempW += characterWidth + offsetX;
                if (offsetY + texture._textureHeight > tempH) {
                    tempH = offsetY + texture._textureHeight;
                }
            }
            var rect = egret.Rectangle.identity.initialize(0, 0, tempW, tempH);
            return rect;
        };

        BitmapText.prototype._measureBounds = function () {
            return this._renderText(true);
        };
        return BitmapText;
    })(egret.DisplayObjectContainer);
    egret.BitmapText = BitmapText;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.Graphics
    * @classdesc Graphics 类包含一组可用来创建矢量形状的方法。支持绘制的显示对象包括 Sprite 和 Shape 对象。这些类中的每一个类都包括 graphics 属性，该属性是一个 Graphics 对象。
    */
    var Graphics = (function () {
        function Graphics() {
            this.commandQueue = [];
        }
        /**
        * 指定一种简单的单一颜色填充
        * @method egret.Graphics#beginFill
        * @param color {number} 填充的颜色
        * @param alpha {number} 填充的 Alpha 值
        */
        Graphics.prototype.beginFill = function (color, alpha) {
            if (typeof alpha === "undefined") { alpha = 1; }
        };

        Graphics.prototype._setStyle = function (colorStr) {
        };

        /**
        * 绘制一个矩形。
        * @method egret.Graphics#drawRect
        * @param x {number} 一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
        * @param y {number} 一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
        * @param width {number} 矩形的宽度（以像素为单位）。
        * @param height {number} 矩形的高度（以像素为单位）。
        */
        Graphics.prototype.drawRect = function (x, y, width, height) {
        };

        /**
        * 绘制一个圆。
        * @method egret.Graphics#drawCircle
        * @param x {number} 圆心相对于父显示对象注册点的 x 位置（以像素为单位）。
        * @param y {number} 相对于父显示对象注册点的圆心的 y 位置（以像素为单位）。
        * @param r {number} 圆的半径（以像素为单位）。
        */
        Graphics.prototype.drawCircle = function (x, y, r) {
        };

        /**
        * 指定一种线条样式以用于随后对 lineTo() 或 drawCircle() 等 Graphics 方法的调用。
        * @method egret.Graphics#lineStyle
        * @param thickness {number} 一个整数，以点为单位表示线条的粗细，有效值为 0 到 255。如果未指定数字，或者未定义该参数，则不绘制线条。如果传递的值小于 0，则默认值为 0。值 0 表示极细的粗细；最大粗细为 255。如果传递的值大于 255，则默认值为 255。
        * @param color {number} 线条的十六进制颜色值（例如，红色为 0xFF0000，蓝色为 0x0000FF 等）。如果未指明值，则默认值为 0x000000（黑色）。可选。
        * @param alpha {number} 表示线条颜色的 Alpha 值的数字；有效值为 0 到 1。如果未指明值，则默认值为 1（纯色）。如果值小于 0，则默认值为 0。如果值大于 1，则默认值为 1。
        * @param pixelHinting {boolean} 布尔型值，指定是否提示笔触采用完整像素。它同时影响曲线锚点的位置以及线条笔触大小本身。在 pixelHinting 设置为 true 的情况下，线条宽度会调整到完整像素宽度。在 pixelHinting 设置为 false 的情况下，对于曲线和直线可能会出现脱节。
        * @param scaleMode {string} 用于指定要使用的比例模式
        * @param caps {string} 用于指定线条末端处端点类型的 CapsStyle 类的值。
        * @param joints {string} 指定用于拐角的连接外观的类型。
        * @param miterLimit {number} 用于表示剪切斜接的极限值的数字。
        */
        Graphics.prototype.lineStyle = function (thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
            if (typeof thickness === "undefined") { thickness = NaN; }
            if (typeof color === "undefined") { color = 0; }
            if (typeof alpha === "undefined") { alpha = 1.0; }
            if (typeof pixelHinting === "undefined") { pixelHinting = false; }
            if (typeof scaleMode === "undefined") { scaleMode = "normal"; }
            if (typeof caps === "undefined") { caps = null; }
            if (typeof joints === "undefined") { joints = null; }
            if (typeof miterLimit === "undefined") { miterLimit = 3; }
        };

        /**
        * 使用当前线条样式绘制一条从当前绘图位置开始到 (x, y) 结束的直线；当前绘图位置随后会设置为 (x, y)。如果正在其中绘制的显示对象包含用 Flash 绘图工具创建的内容，则调用 lineTo() 方法将在该内容下面进行绘制。如果在对 moveTo() 方法进行任何调用之前调用了 lineTo()，则当前绘图的默认位置为 (0, 0)。如果缺少任何一个参数，则此方法将失败，并且当前绘图位置不改变。
        * @method egret.Graphics#lineTo
        * @param x {number} 一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
        * @param y {number} 一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
        */
        Graphics.prototype.lineTo = function (x, y) {
        };

        /**
        * 使用当前线条样式和由 (controlX, controlY) 指定的控制点绘制一条从当前绘图位置开始到 (anchorX, anchorY) 结束的二次贝塞尔曲线。当前绘图位置随后设置为 (anchorX, anchorY)。如果正在其中绘制的影片剪辑包含用 Flash 绘图工具创建的内容，则调用 curveTo() 方法将在该内容下面进行绘制。
        * 如果在调用 moveTo() 方法之前调用了 curveTo() 方法，则当前绘图位置的默认值为 (0, 0)。如果缺少任何一个参数，则此方法将失败，并且当前绘图位置不改变。
        * 绘制的曲线是二次贝塞尔曲线。二次贝塞尔曲线包含两个锚点和一个控制点。该曲线内插这两个锚点，并向控制点弯曲。
        * @method egret.Graphics#curveTo
        * @param controlX {number} 一个数字，指定控制点相对于父显示对象注册点的水平位置。
        * @param controlY {number} 一个数字，指定控制点相对于父显示对象注册点的垂直位置。
        * @param anchorX {number} 一个数字，指定下一个锚点相对于父显示对象注册点的水平位置。
        * @param anchorY {number} 一个数字，指定下一个锚点相对于父显示对象注册点的垂直位置。
        */
        Graphics.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
        };

        /**
        * 将当前绘图位置移动到 (x, y)。如果缺少任何一个参数，则此方法将失败，并且当前绘图位置不改变。
        * @method egret.Graphics#moveTo
        * @param x {number} 一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
        * @param y {number} 一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
        */
        Graphics.prototype.moveTo = function (x, y) {
        };

        /**
        * 清除绘制到此 Graphics 对象的图形，并重置填充和线条样式设置。
        * @method egret.Graphics#clear
        */
        Graphics.prototype.clear = function () {
        };

        /**
        * 对从上一次调用 beginFill()、beginGradientFill() 或 beginBitmapFill() 方法之后添加的直线和曲线应用填充。Flash 使用的是对 beginFill()、beginGradientFill() 或 beginBitmapFill() 方法的先前调用中指定的填充。如果当前绘图位置不等于 moveTo() 方法中指定的上一个位置，而且定义了填充，则用线条闭合该路径，然后进行填充。
        * @method egret.Graphics#endFill
        */
        Graphics.prototype.endFill = function () {
        };

        Graphics.prototype._draw = function (renderContext) {
        };
        return Graphics;
    })();
    egret.Graphics = Graphics;

    var Command = (function () {
        function Command(method, thisObject, args) {
            this.method = method;
            this.thisObject = thisObject;
            this.args = args;
        }
        return Command;
    })();
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Shape
    * @classdesc 此类用于使用 Egret 绘图应用程序编程接口 (API) 创建简单形状。Shape 类包括 graphics 属性，该属性使您可以从 Graphics 类访问方法。
    */
    var Shape = (function (_super) {
        __extends(Shape, _super);
        function Shape() {
            _super.call(this);
        }
        Object.defineProperty(Shape.prototype, "graphics", {
            get: function () {
                if (!this._graphics) {
                    var rendererContext = egret.MainContext.instance.rendererContext;
                    this._graphics = new egret.Graphics();
                }
                return this._graphics;
            },
            enumerable: true,
            configurable: true
        });

        Shape.prototype._render = function (renderContext) {
            if (this._graphics)
                this._graphics._draw(renderContext);
        };
        return Shape;
    })(egret.DisplayObject);
    egret.Shape = Shape;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Sprite
    * @classdesc Sprite 类是基本显示列表构造块：一个可显示图形并且也可包含子项的显示列表节点。Sprite 对象与影片剪辑类似，但没有时间轴。Sprite 是不需要时间轴的对象的相应基类。例如，Sprite 将是通常不使用时间轴的用户界面 (UI) 组件的逻辑基类。
    */
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        function Sprite() {
            _super.call(this);
        }
        Object.defineProperty(Sprite.prototype, "graphics", {
            get: function () {
                if (!this._graphics) {
                    this._graphics = new egret.Graphics();
                }
                return this._graphics;
            },
            enumerable: true,
            configurable: true
        });

        Sprite.prototype._render = function (renderContext) {
            if (this._graphics)
                this._graphics._draw(renderContext);
            _super.prototype._render.call(this, renderContext);
        };
        return Sprite;
    })(egret.DisplayObjectContainer);
    egret.Sprite = Sprite;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TextField
    * @classdesc
    * TextField是egret的文本渲染类，采用浏览器/设备的API进行渲染，在不同的浏览器/设备中由于字体渲染方式不一，可能会有渲染差异
    * 如果开发者希望所有平台完全无差异，请使用BitmapText
    * @extends egret.DisplayObject
    */
    var TextField = (function (_super) {
        __extends(TextField, _super);
        function TextField() {
            _super.call(this);
            this._textDirty = true;
            /**
            * 字体
            * @member {any} egret.TextField#fontFamily
            */
            this._fontFamily = "Arial";
            /**
            * 字号
            * @member {number} egret.TextField#size
            */
            this._size = 30;
            this._textColorString = "#FFFFFF";
            this._textColor = 0xFFFFFF;
            this._strokeColorString = "#000000";
            this._strokeColor = 0x000000;
            /**
            * 描边宽度，0为没有描边
            * @member {number} egret.TextField#stroke
            */
            this._stroke = 0;
            /**
            * 文本水平对齐方式,使用HorizontalAlign定义的常量，默认值HorizontalAlign.LEFT。
            * @member {string} egret.TextField#textAlign
            */
            this._textAlign = "left";
            /**
            * 文本垂直对齐方式,使用VerticalAlign定义的常量，默认值VerticalAlign.TOP。
            * @member {string} egret.TextField#verticalAlign
            */
            this._verticalAlign = "top";
            /**
            * 行间距
            * @member {number} egret.TextField#lineSpacing
            */
            this._lineSpacing = 0;
            this._numLines = 0;
            this.measuredWidths = [];
        }
        Object.defineProperty(TextField.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (value) {
                if (this._text != value) {
                    this._textDirty = true;
                    this._text = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "fontFamily", {
            get: function () {
                return this._fontFamily;
            },
            set: function (value) {
                if (this._fontFamily != value) {
                    this._textDirty = true;
                    this._fontFamily = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (value) {
                if (this._size != value) {
                    this._textDirty = true;
                    this._size = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "italic", {
            get: function () {
                return this._italic;
            },
            set: function (value) {
                if (this._italic != value) {
                    this._textDirty = true;
                    this._italic = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "bold", {
            get: function () {
                return this._bold;
            },
            set: function (value) {
                if (this._bold != value) {
                    this._textDirty = true;
                    this._bold = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "textColor", {
            /**
            * 文字颜色
            * @member {number} egret.TextField#textColor
            */
            get: function () {
                return this._textColor;
            },
            set: function (value) {
                if (this._textColor != value) {
                    this._textDirty = true;
                    this._textColor = value;
                    this._textColorString = egret.toColorString(value);
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "strokeColor", {
            /**
            * 描边颜色
            * @member {number} egret.TextField#strokeColor
            */
            get: function () {
                return this._strokeColor;
            },
            set: function (value) {
                if (this._strokeColor != value) {
                    this._textDirty = true;
                    this._strokeColor = value;
                    this._strokeColorString = egret.toColorString(value);
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            set: function (value) {
                if (this._stroke != value) {
                    this._textDirty = true;
                    this._stroke = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "textAlign", {
            get: function () {
                return this._textAlign;
            },
            set: function (value) {
                if (this._textAlign != value) {
                    this._textDirty = true;
                    this._textAlign = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "verticalAlign", {
            get: function () {
                return this._verticalAlign;
            },
            set: function (value) {
                if (this._verticalAlign != value) {
                    this._textDirty = true;
                    this._verticalAlign = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "lineSpacing", {
            get: function () {
                return this._lineSpacing;
            },
            set: function (value) {
                if (this._lineSpacing != value) {
                    this._textDirty = true;
                    this._lineSpacing = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextField.prototype, "numLines", {
            /**
            * 文本行数
            * @member {number} egret.TextField#numLines
            */
            get: function () {
                return this._numLines;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @see egret.DisplayObject._render
        * @param renderContext
        */
        TextField.prototype._render = function (renderContext) {
            this.drawText(renderContext, false);
            this._textDirty = false;
        };

        /**
        * 测量显示对象坐标与大小
        */
        TextField.prototype._measureBounds = function () {
            var renderContext = egret.MainContext.instance.rendererContext;
            return this.drawText(renderContext, true);
        };

        /**
        * @private
        * @param renderContext
        * @returns {Rectangle}
        */
        TextField.prototype.drawText = function (renderContext, forMeasure) {
            var lines = this.getTextLines(renderContext);
            if (!lines) {
                return egret.Rectangle.identity.initialize(0, 0, 0, 0);
            }
            var length = lines.length;
            var drawY = this._size * 0.5;
            var hGap = this._size + this._lineSpacing;
            var textHeight = length * hGap - this._lineSpacing;
            this._textHeight = textHeight;
            var explicitHeight = this._explicitHeight;
            if (this._hasHeightSet && textHeight < explicitHeight) {
                var valign = 0;
                if (this._verticalAlign == egret.VerticalAlign.MIDDLE)
                    valign = 0.5;
                else if (this._verticalAlign == egret.VerticalAlign.BOTTOM)
                    valign = 1;
                drawY += valign * (explicitHeight - textHeight);
            } else {
                explicitHeight = Number.POSITIVE_INFINITY;
            }
            drawY = Math.round(drawY);
            var minY = drawY;
            var halign = 0;
            if (this._textAlign == egret.HorizontalAlign.CENTER) {
                halign = 0.5;
            } else if (this._textAlign == egret.HorizontalAlign.RIGHT) {
                halign = 1;
            }
            var measuredWidths = this.measuredWidths;
            var maxWidth;
            if (this._hasWidthSet) {
                maxWidth = this._explicitWidth;
            } else {
                maxWidth = this._textWidth;
            }
            var minX = Number.POSITIVE_INFINITY;
            for (var i = 0; i < length; i++) {
                var line = lines[i];
                var measureW = measuredWidths[i];
                var drawX = Math.round((maxWidth - measureW) * halign);
                if (drawX < minX) {
                    minX = drawX;
                }
                if (!forMeasure && drawY < explicitHeight) {
                    renderContext.drawText(this, line, drawX, drawY, maxWidth);
                }
                drawY += hGap;
            }
            return egret.Rectangle.identity.initialize(minX, minY, maxWidth, textHeight);
        };

        TextField.prototype.getTextLines = function (renderContext) {
            var text = this.text ? this.text.toString() : "";
            if (!text) {
                return null;
            }
            var measuredWidths = this.measuredWidths;
            measuredWidths.length = 0;
            renderContext.setupFont(this);
            var lines = text.split(/(?:\r\n|\r|\n)/);
            var length = lines.length;
            var maxWidth = 0;
            if (this._hasWidthSet) {
                var explicitWidth = this._explicitWidth;
                for (var i = 0; i < length; i++) {
                    var line = lines[i];
                    var measureW = renderContext.measureText(line);
                    if (measureW > explicitWidth) {
                        var newLine = "";
                        var lineWidth = 0;
                        var len = line.length;
                        for (var j = 0; j < len; j++) {
                            var word = line.charAt(j);
                            measureW = renderContext.measureText(word);
                            if (lineWidth + measureW > explicitWidth) {
                                if (lineWidth == 0) {
                                    lines.splice(i, 0, word);
                                    measuredWidths[i] = measureW;
                                    if (maxWidth < measureW) {
                                        maxWidth = measureW;
                                    }
                                    measureW = 0;
                                    word = "";
                                } else {
                                    lines.splice(i, 0, newLine);
                                    measuredWidths[i] = lineWidth;
                                    if (maxWidth < lineWidth) {
                                        maxWidth = lineWidth;
                                    }
                                    newLine = "";
                                    lineWidth = 0;
                                }
                                i++;
                                length++;
                            }
                            lineWidth += measureW;
                            newLine += word;
                        }
                        lines[i] = newLine;
                        measuredWidths[i] = lineWidth;
                    } else {
                        measuredWidths[i] = measureW;
                        if (maxWidth < measureW) {
                            maxWidth = measureW;
                        }
                    }
                }
            } else {
                for (i = 0; i < length; i++) {
                    line = lines[i];
                    measureW = renderContext.measureText(line);
                    measuredWidths[i] = measureW;
                    if (maxWidth < measureW) {
                        maxWidth = measureW;
                    }
                }
            }
            this._textWidth = maxWidth;
            return lines;
        };
        return TextField;
    })(egret.DisplayObject);
    egret.TextField = TextField;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.TextFieldType
    * @classdesc
    * TextFieldType 类是在设置 TextField 类的 type 属性时使用的常数值的枚举。
    */
    var TextFieldType = (function () {
        function TextFieldType() {
        }
        TextFieldType.DYNAMIC = "dynamic";

        TextFieldType.INPUT = "input";
        return TextFieldType;
    })();
    egret.TextFieldType = TextFieldType;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SpriteSheet
    * @classdesc SpriteSheet是一张由多个子位图拼接而成的集合位图，它包含多个Texture对象。
    * 每一个Texture都共享SpriteSheet的集合位图，但是指向它的不同的区域。
    * 在WebGL / OpenGL上，这种做法可以显著提升性能
    * 同时，SpriteSheet可以很方便的进行素材整合，降低HTTP请求数量
    * SpriteSheet 格式的具体规范可以参见此文档  https://github.com/egret-labs/egret-core/wiki/Egret-SpriteSheet-Specification
    *
    */
    var SpriteSheet = (function (_super) {
        __extends(SpriteSheet, _super);
        function SpriteSheet(texture) {
            _super.call(this);
            var bitmapData = texture.bitmapData;
            this.bitmapData = bitmapData;
            this._textureMap = {};

            this._sourceWidth = bitmapData.width;
            this._sourceHeight = bitmapData.height;

            this._bitmapX = texture._bitmapX;
            this._bitmapY = texture._bitmapY;
        }
        /**
        * 根据指定纹理名称获取一个缓存的Texture对象
        * @method egret.SpriteSheet#getTexture
        * @param name {string} 缓存这个Texture对象所使用的名称
        * @returns {egret.Texture} Texture对象
        */
        SpriteSheet.prototype.getTexture = function (name) {
            return this._textureMap[name];
        };

        /**
        * 为SpriteSheet上的指定区域创建一个新的Texture对象并缓存它
        * @method egret.SpriteSheet#createTexture
        * @param name {string} 缓存这个Texture对象所使用的名称，如果名称已存在，将会覆盖之前的Texture对象
        * @param bitmapX {number} 纹理区域在bitmapData上的起始坐标x
        * @param bitmapY {number} 纹理区域在bitmapData上的起始坐标y
        * @param bitmapWidth {number} 纹理区域在bitmapData上的宽度
        * @param bitmapHeight {number} 纹理区域在bitmapData上的高度
        * @param offsetX {number} 原始位图的非透明区域x起始点
        * @param offsetY {number} 原始位图的非透明区域y起始点
        * @param textureWidth {number} 原始位图的高度，若不传入，则使用bitmapWidth的值。
        * @param textureHeight {number} 原始位图的宽度，若不传入，这使用bitmapHeight值。
        * @returns {egret.Texture} 创建的Texture对象
        */
        SpriteSheet.prototype.createTexture = function (name, bitmapX, bitmapY, bitmapWidth, bitmapHeight, offsetX, offsetY, textureWidth, textureHeight) {
            if (typeof offsetX === "undefined") { offsetX = 0; }
            if (typeof offsetY === "undefined") { offsetY = 0; }
            if (typeof textureWidth === "undefined") {
                textureWidth = offsetX + bitmapWidth;
            }
            if (typeof textureHeight === "undefined") {
                textureHeight = offsetY + bitmapHeight;
            }
            var texture = new egret.Texture();

            texture._bitmapData = this.bitmapData;
            texture._bitmapX = this._bitmapX + bitmapX;
            texture._bitmapY = this._bitmapY + bitmapY;
            texture._bitmapWidth = bitmapWidth;
            texture._bitmapHeight = bitmapHeight;
            texture._offsetX = offsetX;
            texture._offsetY = offsetY;
            texture._textureWidth = textureWidth;
            texture._textureHeight = textureHeight;
            texture._sourceWidth = this._sourceWidth;
            texture._sourceHeight = this._sourceHeight;
            this._textureMap[name] = texture;
            return texture;
        };
        return SpriteSheet;
    })(egret.HashObject);
    egret.SpriteSheet = SpriteSheet;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var TextInput = (function (_super) {
        __extends(TextInput, _super);
        function TextInput() {
            _super.apply(this, arguments);
            this._placeholderText = "";
            this._edFontSize = 14;
            this._textColor = 0xff0000;
            this._placeholderFontSize = 14;
            this._placeholderColor = 0xffff00;
            this._preX = 0;
            this._preY = 0;
        }
        TextInput.prototype._onAddToStage = function () {
            _super.prototype._onAddToStage.call(this);
            var point = this.localToGlobal();
            var stageText = new egret.StageText();
            stageText._open(point.x, point.y, this._explicitWidth, this._explicitHeight);
            this.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onMouseDownHandler, this);
            this.stageText = stageText;
        };

        TextInput.prototype.setText = function (value) {
            this.stageText._setText(value);
        };

        TextInput.prototype.getText = function () {
            return this.stageText._getText();
        };

        TextInput.prototype.setTextType = function (type) {
            this.stageText._setTextType(type);
        };

        TextInput.prototype.getTextType = function () {
            return this.stageText._getTextType();
        };

        TextInput.prototype.onMouseDownHandler = function (event) {
        };

        TextInput.prototype._onRemoveFromStage = function () {
            this.stageText._remove();
        };

        TextInput.prototype._measureBounds = function () {
            return egret.Rectangle.identity;
        };

        TextInput.prototype.hitTest = function (x, y, ignoreTouchEnabled) {
            if (typeof ignoreTouchEnabled === "undefined") { ignoreTouchEnabled = false; }
            //它不能被点击
            return null;
        };
        return TextInput;
    })(egret.DisplayObject);
    egret.TextInput = TextInput;

    var TextInputDegelete = (function () {
        function TextInputDegelete() {
        }
        TextInputDegelete.prototype.editBoxEditingDidBegin = function (sender) {
        };

        TextInputDegelete.prototype.editBoxEditingDidEnd = function (sender) {
        };

        TextInputDegelete.prototype.editBoxTextChanged = function (sender, text) {
        };

        TextInputDegelete.prototype.editBoxReturn = function (sender) {
        };
        return TextInputDegelete;
    })();
    egret.TextInputDegelete = TextInputDegelete;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var BitmapTextSpriteSheet = (function (_super) {
        __extends(BitmapTextSpriteSheet, _super);
        function BitmapTextSpriteSheet(texture, fntText) {
            _super.call(this, texture);
            this.charList = this.parseConfig(fntText);
        }
        BitmapTextSpriteSheet.prototype.getTexture = function (name) {
            var texture = this._textureMap[name];
            if (!texture) {
                var c = this.charList[name];
                if (!c) {
                    return null;
                }
                texture = this.createTexture(name, c.x, c.y, c.width, c.height, c.offsetX, c.offsetY);
                this._textureMap[name] = texture;
            }
            return texture;
        };

        BitmapTextSpriteSheet.prototype.parseConfig = function (fntText) {
            fntText = fntText.split("\r\n").join("\n");
            var lines = fntText.split("\n");
            var charsCount = this.getConfigByKey(lines[3], "count");

            var chars = {};
            for (var i = 4; i < 4 + charsCount; i++) {
                var charText = lines[i];
                var letter = String.fromCharCode(this.getConfigByKey(charText, "id"));
                var c = {};
                chars[letter] = c;
                c["x"] = this.getConfigByKey(charText, "x");
                c["y"] = this.getConfigByKey(charText, "y");
                c["width"] = this.getConfigByKey(charText, "width");
                c["height"] = this.getConfigByKey(charText, "height");
                c["offsetX"] = this.getConfigByKey(charText, "xoffset");
                c["offsetY"] = this.getConfigByKey(charText, "yoffset");
            }
            return chars;
        };

        BitmapTextSpriteSheet.prototype.getConfigByKey = function (configText, key) {
            var itemConfigTextList = configText.split(" ");
            for (var i = 0, length = itemConfigTextList.length; i < length; i++) {
                var itemConfigText = itemConfigTextList[i];
                if (key == itemConfigText.substring(0, key.length)) {
                    var value = itemConfigText.substring(key.length + 1);
                    return parseInt(value);
                }
            }
            return 0;
        };
        return BitmapTextSpriteSheet;
    })(egret.SpriteSheet);
    egret.BitmapTextSpriteSheet = BitmapTextSpriteSheet;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../context/MainContext.ts"/>
/// <reference path="../context/Ticker.ts"/>
/// <reference path="Bitmap.ts"/>
/// <reference path="DisplayObjectContainer.ts"/>
/// <reference path="SpriteSheet.ts"/>
/// <reference path="Texture.ts"/>
/// <reference path="../utils/Logger.ts"/>
var egret;
(function (egret) {
    var MovieClip = (function (_super) {
        __extends(MovieClip, _super);
        function MovieClip(data, texture) {
            _super.call(this);
            this.frameRate = 60;
            if (texture != null && texture instanceof egret.Texture) {
                egret.Logger.warning("MovieClip#constructor接口参数已经变更，请尽快调整用法为 new MovieClip(new DefaultMovieClipDelegate(data,texture))");
                this.delegate = new DefaultMovieClipDelegate(data, texture);
            } else {
                this.delegate = data;
            }
            this.delegate.setMovieClip(this);
        }
        /**
        * 播放指定动画
        * @param frameName
        */
        MovieClip.prototype.gotoAndPlay = function (frameName) {
            this.delegate.gotoAndPlay(frameName);
        };

        /**
        * 播放并暂停指定动画
        * @param frameName
        */
        MovieClip.prototype.gotoAndStop = function (frameName) {
            this.delegate.gotoAndStop(frameName);
        };

        /**
        * 暂停动画
        */
        MovieClip.prototype.stop = function () {
            this.delegate.stop();
        };

        MovieClip.prototype.dispose = function () {
            this.delegate.dispose();
        };

        /**
        * 方法名改为 dispose
        * @deprecated
        */
        MovieClip.prototype.release = function () {
            egret.Logger.warning("MovieClip#release方法即将废弃");
            this.dispose();
        };

        /**
        * @deprecated
        */
        MovieClip.prototype.getCurrentFrameIndex = function () {
            egret.Logger.warning("MovieClip#getCurrentFrameIndex方法即将废弃");
            return this.delegate["_currentFrameIndex"];
        };

        /**
        * @deprecated
        */
        MovieClip.prototype.getTotalFrame = function () {
            egret.Logger.warning("MovieClip#getTotalFrame方法即将废弃");
            return this.delegate["_totalFrame"];
        };

        /**
        * @deprecated
        */
        MovieClip.prototype.setInterval = function (value) {
            egret.Logger.warning("MovieClip#setInterval方法即将废弃,请使用MovieClip#frameRate代替");
            this.frameRate = 60 / value;
        };

        /**
        * @deprecated
        */
        MovieClip.prototype.getIsPlaying = function () {
            egret.Logger.warning("MovieClip#getIsPlaying方法即将废弃");
            return this.delegate["isPlaying"];
        };
        return MovieClip;
    })(egret.DisplayObjectContainer);
    egret.MovieClip = MovieClip;

    var DefaultMovieClipDelegate = (function () {
        function DefaultMovieClipDelegate(data, texture) {
            this.data = data;
            this._totalFrame = 0;
            this._passTime = 0;
            this._currentFrameIndex = 0;
            this._isPlaying = false;
            this._frameData = data;
            this._spriteSheet = new egret.SpriteSheet(texture);
        }
        DefaultMovieClipDelegate.prototype.setMovieClip = function (movieClip) {
            this.movieClip = movieClip;
            this.bitmap = new egret.Bitmap();
            this.movieClip.addChild(this.bitmap);
        };

        DefaultMovieClipDelegate.prototype.gotoAndPlay = function (frameName) {
            this.checkHasFrame(frameName);
            this._isPlaying = true;
            this._currentFrameIndex = 0;
            this._currentFrameName = frameName;

            this.playNextFrame();
            this._passTime = 0;
            egret.Ticker.getInstance().register(this.update, this);
            this._totalFrame = this._frameData.frames[frameName].totalFrame;
        };

        DefaultMovieClipDelegate.prototype.gotoAndStop = function (frameName) {
            this.checkHasFrame(frameName);
            this.stop();
            this._passTime = 0;
            this._currentFrameIndex = 0;
            this._currentFrameName = frameName;
            this._totalFrame = this._frameData.frames[frameName].totalFrame;
            this.playNextFrame();
        };

        DefaultMovieClipDelegate.prototype.stop = function () {
            this._isPlaying = false;
            egret.Ticker.getInstance().unregister(this.update, this);
        };

        DefaultMovieClipDelegate.prototype.dispose = function () {
        };

        DefaultMovieClipDelegate.prototype.checkHasFrame = function (name) {
            if (this._frameData.frames[name] == undefined) {
                egret.Logger.fatal("MovieClip没有对应的frame：", name);
            }
        };

        DefaultMovieClipDelegate.prototype.update = function (advancedTime) {
            var oneFrameTime = 1000 / this.movieClip.frameRate;
            var last = this._passTime % oneFrameTime;
            var num = Math.floor((last + advancedTime) / oneFrameTime);
            while (num >= 1) {
                if (num == 1) {
                    this.playNextFrame();
                } else {
                    this.playNextFrame(false);
                }
                num--;
            }
            this._passTime += advancedTime;
        };

        DefaultMovieClipDelegate.prototype.playNextFrame = function (needShow) {
            if (typeof needShow === "undefined") { needShow = true; }
            var frameData = this._frameData.frames[this._currentFrameName].childrenFrame[this._currentFrameIndex];
            if (needShow) {
                var texture = this.getTexture(frameData.res);
                var bitmap = this.bitmap;
                bitmap.x = frameData.x;
                bitmap.y = frameData.y;
                bitmap.texture = texture;
            }

            if (frameData.action != null) {
                this.movieClip.dispatchEventWith(frameData.action);
            }

            this._currentFrameIndex++;
            if (this._currentFrameIndex == this._totalFrame) {
                this._currentFrameIndex = 0;
            }
        };

        DefaultMovieClipDelegate.prototype.getTexture = function (name) {
            var resData = this._frameData.res[name];
            var texture = this._spriteSheet.getTexture(name);
            if (!texture) {
                texture = this._spriteSheet.createTexture(name, resData.x, resData.y, resData.w, resData.h);
            }
            return texture;
        };
        return DefaultMovieClipDelegate;
    })();
    egret.DefaultMovieClipDelegate = DefaultMovieClipDelegate;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.StageText
    * @classdesc
    * @extends egret.HashObject
    */
    var StageText = (function (_super) {
        __extends(StageText, _super);
        function StageText() {
            _super.call(this);
        }
        /**
        * @method egret.StageText#getText
        * @returns {string}
        */
        StageText.prototype._getText = function () {
            return this.inputElement.value;
        };

        /**
        * @method egret.StageText#setText
        * @param value {string}
        */
        StageText.prototype._setText = function (value) {
            this.inputElement.value = value;
        };

        /**
        * @method egret.StageText#setTextType
        * @param type {string}
        */
        StageText.prototype._setTextType = function (type) {
            this.inputElement.type = type;
        };

        /**
        * @method egret.StageText#getTextType
        * @returns {string}
        */
        StageText.prototype._getTextType = function () {
            return this.inputElement.type;
        };

        /**
        * @method egret.StageText#open
        * @param x {number}
        * @param y {number}
        * @param width {number}
        * @param height {number}
        */
        StageText.prototype._open = function (x, y, width, height) {
            if (typeof width === "undefined") { width = 160; }
            if (typeof height === "undefined") { height = 21; }
            var scaleX = egret.StageDelegate.getInstance().getScaleX();
            var scaleY = egret.StageDelegate.getInstance().getScaleY();

            var inputElement = document.createElement("input");
            inputElement.type = "text";
            inputElement.style.fontSize = "20px";
            inputElement.style.color = "#FFFFFF";
            inputElement.style.borderStyle = "none";
            inputElement.style.background = "none";
            inputElement.style.width = width * scaleX + "px";
            inputElement.style.height = height * scaleY + "px";
            inputElement.style.outline = "medium";

            var div = egret.Browser.getInstance().$new("div");
            div.style.position = 'absolute';
            div.position.x = x * scaleX;
            div.style.width = width * scaleX + "px";
            div.style.height = height * scaleY + "px";
            div.position.y = y * scaleY;
            div.transforms();
            div.appendChild(inputElement);

            var stageDelegateDiv = egret.Browser.getInstance().$("#StageDelegateDiv");
            if (!stageDelegateDiv) {
                var container = document.getElementById(egret.StageDelegate.canvas_div_name);
                var height = container.clientHeight;
                var width = container.clientWidth;
                stageDelegateDiv = egret.Browser.getInstance().$new("div");
                stageDelegateDiv.id = "StageDelegateDiv";
                stageDelegateDiv.style.position = 'absolute';
                stageDelegateDiv.style.width = width + "px";
                stageDelegateDiv.style.maxHeight = height + "px";
                stageDelegateDiv.style.margin = 0 + "px";

                var canvas = document.getElementById(egret.StageDelegate.canvas_div_name);
                canvas.appendChild(stageDelegateDiv);
                stageDelegateDiv.position.y = -height;
                stageDelegateDiv.transforms();
            }
            stageDelegateDiv.appendChild(div);
            this.div = div;
            this.inputElement = inputElement;
        };

        /**
        * @method egret.StageText#remove
        */
        StageText.prototype._remove = function () {
            var div = this.div;
            if (div && div.parentNode) {
                div.parentNode.removeChild(div);
            }
        };
        return StageText;
    })(egret.HashObject);
    egret.StageText = StageText;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.URLRequestMethod
    * @classdesc
    */
    var URLRequestMethod = (function () {
        function URLRequestMethod() {
        }
        URLRequestMethod.GET = "GET";

        URLRequestMethod.POST = "POST";
        return URLRequestMethod;
    })();
    egret.URLRequestMethod = URLRequestMethod;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.URLLoaderDataFormat
    * @classdesc
    */
    var URLLoaderDataFormat = (function () {
        function URLLoaderDataFormat() {
        }
        URLLoaderDataFormat.BINARY = "binary";

        URLLoaderDataFormat.TEXT = "text";

        URLLoaderDataFormat.VARIABLES = "variables";

        URLLoaderDataFormat.TEXTURE = "texture";

        URLLoaderDataFormat.SOUND = "sound";
        return URLLoaderDataFormat;
    })();
    egret.URLLoaderDataFormat = URLLoaderDataFormat;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.URLVariables
    * @classdesc
    * 使用 URLVariables 类可以在应用程序和服务器之间传输变量。
    * 将 URLVariables 对象与 URLLoader 类的方法、URLRequest 类的 data 属性一起使用。
    * @extends egret.HashObject
    */
    var URLVariables = (function (_super) {
        __extends(URLVariables, _super);
        /**
        * @method egret.URLVariables#constructor
        * @param source {String} 包含名称/值对的 URL 编码的字符串。
        */
        function URLVariables(source) {
            if (typeof source === "undefined") { source = null; }
            _super.call(this);
            if (source !== null) {
                this.decode(source);
            }
        }
        /**
        * 将变量字符串转换为此 URLVariables.variables 对象的属性。
        * @method egret.URLVariables#decode
        * @param source {string}
        */
        URLVariables.prototype.decode = function (source) {
            if (!this.variables) {
                this.variables = {};
            }
            source = source.split("+").join(" ");
            var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
            while (tokens = re.exec(source)) {
                this.variables[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
            }
        };

        /**
        * 以 MIME 内容编码格式 application/x-www-form-urlencoded 返回包含所有可枚举变量的字符串。
        * @method egret.URLVariables#toString
        */
        URLVariables.prototype.toString = function () {
            if (!this.variables) {
                return "";
            }
            var variables = this.variables;
            var str = "";
            var isFirst = true;
            for (var key in variables) {
                if (isFirst) {
                    isFirst = false;
                } else {
                    str += "&";
                }
                str += key + "=" + variables[key];
            }
            return str;
        };
        return URLVariables;
    })(egret.HashObject);
    egret.URLVariables = URLVariables;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.URLRequest
    * @classdesc
    * @extends egret.HashObject
    */
    var URLRequest = (function (_super) {
        __extends(URLRequest, _super);
        /**
        * @method egret.URLRequest#constructor
        * @param url {string}
        */
        function URLRequest(url) {
            if (typeof url === "undefined") { url = null; }
            _super.call(this);
            /**
            * 请求方式，有效值为URLRequestMethod.GET 或 URLRequestMethod.POST。
            * @member {string} egret.URLRequest#method
            */
            this.method = egret.URLRequestMethod.GET;
            this.url = url;
        }
        return URLRequest;
    })(egret.HashObject);
    egret.URLRequest = URLRequest;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.URLLoader
    * @classdesc
    * URLLoader 类以文本、二进制数据或 URL 编码变量的形式从 URL 下载数据。在下载文本文件、XML 或其他用于动态数据驱动应用程序的信息时，它很有用。
    * URLLoader 对象会先从 URL 中下载所有数据，然后才将数据用于应用程序中的代码。它会发出有关下载进度的通知，
    * 通过 bytesLoaded 和 bytesTotal 属性以及已调度的事件，可以监视下载进度。
    * @extends egret.EventDispatcher
    */
    var URLLoader = (function (_super) {
        __extends(URLLoader, _super);
        /**
        * @method egret.URLLoader#constructor
        * @param request {URLRequest} 一个 URLRequest 对象，指定要下载的 URL。
        * 如果省略该参数，则不开始加载操作。如果已指定参数，则立即开始加载操作
        */
        function URLLoader(request) {
            if (typeof request === "undefined") { request = null; }
            _super.call(this);
            /**
            * 控制是以文本 (URLLoaderDataFormat.TEXT)、原始二进制数据 (URLLoaderDataFormat.BINARY) 还是 URL 编码变量 (URLLoaderDataFormat.VARIABLES) 接收下载的数据。
            * 如果 dataFormat 属性的值是 URLLoaderDataFormat.TEXT，则所接收的数据是一个包含已加载文件文本的字符串。
            * 如果 dataFormat 属性的值是 URLLoaderDataFormat.BINARY，则所接收的数据是一个包含原始二进制数据的 ByteArray 对象。
            * 如果 dataFormat 属性的值是 URLLoaderDataFormat.TEXTURE，则所接收的数据是一个包含位图数据的Texture对象。
            * 如果 dataFormat 属性的值是 URLLoaderDataFormat.VARIABLES，则所接收的数据是一个包含 URL 编码变量的 URLVariables 对象。
            * 默认值:URLLoaderDataFormat.TEXT
            * @member {string} egret.URLLoader#dataFormat
            */
            this.dataFormat = egret.URLLoaderDataFormat.TEXT;
            if (request) {
                this.load(request);
            }
        }
        /**
        * 从指定的 URL 发送和加载数据。可以以文本、原始二进制数据或 URL 编码变量格式接收数据，这取决于为 dataFormat 属性所设置的值。
        * 请注意 dataFormat 属性的默认值为文本。如果想将数据发送至指定的 URL，则可以在 URLRequest 对象中设置 data 属性。
        * @method egret.URLLoader#load
        * @param request {URLRequest}
        */
        URLLoader.prototype.load = function (request) {
            this._request = request;
            this.data = null;
            egret.MainContext.instance.netContext.proceed(this);
        };
        return URLLoader;
    })(egret.EventDispatcher);
    egret.URLLoader = URLLoader;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Texture
    * @classdesc 纹理类是对不同平台不同的图片资源的封装
    * 在HTML5中，资源是一个HTMLElement对象
    * 在OpenGL / WebGL中，资源是一个提交GPU后获取的纹理id
    * Texture类封装了这些底层实现的细节，开发者只需要关心接口即可
    */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            _super.call(this);
            /**
            * 表示这个纹理在bitmapData上的x起始位置
            */
            this._bitmapX = 0;
            /**
            * 表示这个纹理在bitmapData上的y起始位置
            */
            this._bitmapY = 0;
            /**
            * 表示这个纹理在bitmapData上的宽度
            */
            this._bitmapWidth = 0;
            /**
            * 表示这个纹理在bitmapData上的高度
            */
            this._bitmapHeight = 0;
            /**
            * 表示这个纹理显示了之后在x方向的渲染偏移量
            */
            this._offsetX = 0;
            /**
            * 表示这个纹理显示了之后在y方向的渲染偏移量
            */
            this._offsetY = 0;
            this._textureWidth = 0;
            this._textureHeight = 0;
        }
        Object.defineProperty(Texture.prototype, "textureWidth", {
            /**
            * 纹理宽度
            * @member {number} egret.Texture#textureWidth
            */
            get: function () {
                return this._textureWidth;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Texture.prototype, "textureHeight", {
            /**
            * 纹理高度
            * @member {number} egret.Texture#textureWidth
            */
            get: function () {
                return this._textureHeight;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Texture.prototype, "bitmapData", {
            /**
            * 纹理对象中得位图数据
            * @member {any} egret.Texture#bitmapData
            */
            get: function () {
                return this._bitmapData;
            },
            enumerable: true,
            configurable: true
        });

        Texture.prototype._setBitmapData = function (value) {
            var scale = egret.MainContext.instance.rendererContext.texture_scale_factor;
            this._bitmapData = value;
            this._sourceWidth = value.width;
            this._sourceHeight = value.height;
            this._textureWidth = this._sourceWidth * scale;
            this._textureHeight = this._sourceHeight * scale;
            this._bitmapWidth = this._textureWidth;
            this._bitmapHeight = this._textureHeight;
            this._offsetX = this._offsetY = this._bitmapX = this._bitmapY = 0;
        };

        /**
        * 获取某一点像素的颜色值
        * @method egret.Texture#getPixel32
        * @param x 像素点的X轴坐标
        * @param y 像素点的Y轴坐标
        * @returns {number} 指定像素点的颜色值
        */
        Texture.prototype.getPixel32 = function (x, y) {
            var result = this._bitmapData.getContext("2d").getImageData(x, y, 1, 1);
            return result.data;
        };
        return Texture;
    })(egret.HashObject);
    egret.Texture = Texture;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        function RenderTexture() {
            _super.call(this);
            this._bitmapData = document.createElement("canvas");
            this.renderContext = egret.RendererContext.createRendererContext(this._bitmapData);
        }
        RenderTexture.prototype.drawToTexture = function (displayObject) {
            var cacheCanvas = this._bitmapData;
            var bounds = displayObject.getBounds(egret.Rectangle.identity);
            cacheCanvas.width = bounds.width;
            cacheCanvas.height = bounds.height;

            displayObject._worldTransform.identity();
            displayObject.worldAlpha = 1;
            if (displayObject instanceof egret.DisplayObjectContainer) {
                this._offsetX = bounds.x;
                this._offsetY = bounds.y;
                displayObject._worldTransform.append(1, 0, 0, 1, -bounds.x, -bounds.y);
                var list = displayObject._children;
                for (var i = 0, length = list.length; i < length; i++) {
                    var child = list[i];
                    child._updateTransform();
                }
            }

            var renderFilter = egret.RenderFilter.getInstance();
            var drawAreaList = renderFilter._drawAreaList.concat();
            renderFilter._drawAreaList.length = 0;
            this.renderContext.clearScreen();

            this.webGLTexture = null; //gl.deleteTexture(this.webGLTexture);
            var mask = displayObject.mask || displayObject._scrollRect;
            if (mask) {
                this.renderContext.pushMask(mask);
            }
            displayObject._render(this.renderContext);
            if (mask) {
                this.renderContext.popMask();
            }
            renderFilter._drawAreaList = drawAreaList;

            this._textureWidth = this._bitmapData.width;
            this._textureHeight = this._bitmapData.height;
            this._sourceWidth = this._textureWidth;
            this._sourceHeight = this._textureHeight;
            //测试代码
            //            this.renderContext.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            //            this.renderContext.strokeRect(0, 0,cacheCanvas.width,cacheCanvas.height,"#ff0000");
            //            document.documentElement.appendChild(cacheCanvas);
        };
        return RenderTexture;
    })(egret.Texture);
    egret.RenderTexture = RenderTexture;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.RendererContext
    * @classdesc
    * RenderContext是游戏的渲染上下文。
    * 这是一个抽象基类，制定主要的接口
    * @extends egret.HashObject
    */
    var RendererContext = (function (_super) {
        __extends(RendererContext, _super);
        /**
        * @method egret.RendererContext#constructor
        */
        function RendererContext() {
            _super.call(this);
            /**
            * 渲染全部纹理的时间开销
            * @member egret.RendererContext#renderCost
            */
            this.renderCost = 0;
            /**
            * 绘制纹理的缩放比率，默认值为1
            * @member egret.RendererContext#texture_scale_factor
            */
            this.texture_scale_factor = 1;
        }
        /**
        * @method egret.RendererContext#clearScreen
        * @private
        */
        RendererContext.prototype.clearScreen = function () {
        };

        /**
        * 清除Context的渲染区域
        * @method egret.RendererContext#clearRect
        * @param x {number}
        * @param y {number}
        * @param w {number}
        * @param h {numbe}
        */
        RendererContext.prototype.clearRect = function (x, y, w, h) {
        };

        /**
        * 绘制图片
        * @method egret.RendererContext#drawImage
        * @param texture {Texture}
        * @param sourceX {any}
        * @param sourceY {any}
        * @param sourceWidth {any}
        * @param sourceHeight {any}
        * @param destX {any}
        * @param destY {any}
        * @param destWidth {any}
        * @param destHeigh {any}
        */
        RendererContext.prototype.drawImage = function (texture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
            egret.Profiler.getInstance().onDrawImage();
        };

        /**
        * 变换Context的当前渲染矩阵
        * @method egret.RendererContext#setTransform
        * @param matrix {egret.Matri}
        */
        RendererContext.prototype.setTransform = function (matrix) {
        };

        /**
        * 设置渲染alpha
        * @method egret.RendererContext#setAlpha
        * @param value {number}
        * @param blendMode {egret.BlendMod}
        */
        RendererContext.prototype.setAlpha = function (value, blendMode) {
        };

        /**
        * 设置渲染文本参数
        * @method egret.RendererContext#setupFont
        * @param textField {TextField}
        */
        RendererContext.prototype.setupFont = function (textField) {
        };

        /**
        * 测量文本
        * @method egret.RendererContext#measureText
        * @param text {string}
        * @returns {number}
        * @stable B 参数很可能会需要调整，和setupFont整合
        */
        RendererContext.prototype.measureText = function (text) {
            return 0;
        };

        /**
        * 绘制文本
        * @method egret.RendererContext#drawText
        * @param textField {egret.TextField}
        * @param text {string}
        * @param x {number}
        * @param y {number}
        * @param maxWidth {numbe}
        */
        RendererContext.prototype.drawText = function (textField, text, x, y, maxWidth) {
            egret.Profiler.getInstance().onDrawImage();
        };

        RendererContext.prototype.strokeRect = function (x, y, w, h, color) {
        };

        RendererContext.prototype.pushMask = function (mask) {
        };

        RendererContext.prototype.popMask = function () {
        };

        RendererContext.createRendererContext = function (canvas) {
            return null;
        };
        return RendererContext;
    })(egret.HashObject);
    egret.RendererContext = RendererContext;

    /**
    * @class egret.BlendMode
    * @classdesc
    */
    var BlendMode = (function () {
        function BlendMode(type) {
            this.type = type;
            switch (type) {
                case "add":
                case "layer":
                    this.value = "lighter";
                    break;
                default:
                    this.value = "source-over";
            }
        }
        /**
        * @method egret.BlendMode.getBlendMode
        * @param typ {any}
        */
        BlendMode.getBlendMode = function (type) {
            if (!type) {
                return egret.BlendMode.NORMAL;
            }
            return egret.BlendMode[type.toUpperCase()];
        };
        BlendMode.NORMAL = new BlendMode("normal");
        BlendMode.ADD = new BlendMode("add");
        BlendMode.LAYER = new BlendMode("layer");
        return BlendMode;
    })();
    egret.BlendMode = BlendMode;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var InteractionMode = (function () {
        function InteractionMode() {
        }
        InteractionMode.MOUSE = "mouse";

        InteractionMode.TOUCH = "touch";

        InteractionMode.mode = "touch";
        return InteractionMode;
    })();
    egret.InteractionMode = InteractionMode;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    *
    * @class egret.TouchContext
    * @classdesc TouchContext是egret的触摸Context
    */
    var TouchContext = (function (_super) {
        __extends(TouchContext, _super);
        function TouchContext() {
            _super.call(this);
            this._currentTouchTarget = {};
            this.maxTouches = 2;
            this.touchDownTarget = {};
            this.lastTouchX = -1;
            this.lastTouchY = -1;
        }
        /**
        * 启动触摸检测
        * @method egret.TouchContext#run
        */
        TouchContext.prototype.run = function () {
        };

        TouchContext.prototype.getTouchData = function (identifier, x, y) {
            var obj = this._currentTouchTarget[identifier];
            if (obj == null) {
                obj = {};
                this._currentTouchTarget[identifier] = obj;
            }
            obj.stageX = x;
            obj.stageY = y;
            obj.identifier = identifier;
            return obj;
        };

        TouchContext.prototype.dispatchEvent = function (type, data) {
            var touchDown = (this.touchDownTarget[data.identifier] == true);
            egret.TouchEvent.dispatchTouchEvent(data.target, type, data.identifier, data.stageX, data.stageY, false, false, false, touchDown);
        };

        TouchContext.prototype.onTouchBegan = function (x, y, identifier) {
            var stage = egret.MainContext.instance.stage;
            var result = stage.hitTest(x, y);
            if (result) {
                var obj = this.getTouchData(identifier, x, y);
                this.touchDownTarget[identifier] = true;
                obj.target = result;
                obj.beginTarget = result;
                this.dispatchEvent(egret.TouchEvent.TOUCH_BEGIN, obj);
            }
        };

        TouchContext.prototype.onTouchMove = function (x, y, identifier) {
            if (x == this.lastTouchX && y == this.lastTouchY) {
                return;
            }
            this.lastTouchX = x;
            this.lastTouchY = y;
            var stage = egret.MainContext.instance.stage;
            var result = stage.hitTest(x, y);
            if (result) {
                var obj = this.getTouchData(identifier, x, y);
                obj.target = result;
                this.dispatchEvent(egret.TouchEvent.TOUCH_MOVE, obj);
            }
        };

        TouchContext.prototype.onTouchEnd = function (x, y, identifier) {
            var stage = egret.MainContext.instance.stage;
            var result = stage.hitTest(x, y);
            if (result) {
                var obj = this.getTouchData(identifier, x, y);
                delete this.touchDownTarget[identifier];
                var oldTarget = obj.beginTarget;
                obj.target = result;
                this.dispatchEvent(egret.TouchEvent.TOUCH_END, obj);
                if (oldTarget == result) {
                    this.dispatchEvent(egret.TouchEvent.TOUCH_TAP, obj);
                } else if (obj.beginTarget) {
                    obj.target = obj.beginTarget;
                    this.dispatchEvent(egret.TouchEvent.TOUCH_RELEASE_OUTSIDE, obj);
                }
                delete this._currentTouchTarget[obj.identifier];
            }
        };
        return TouchContext;
    })(egret.HashObject);
    egret.TouchContext = TouchContext;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.NetContext
    * @classdesc
    * @extends egret.HashObject
    */
    var NetContext = (function (_super) {
        __extends(NetContext, _super);
        function NetContext() {
            _super.call(this);
        }
        NetContext.prototype.proceed = function (loader) {
        };
        return NetContext;
    })(egret.HashObject);
    egret.NetContext = NetContext;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DeviceContext
    * @classdesc
    * @extends egret.HashObject
    */
    var DeviceContext = (function (_super) {
        __extends(DeviceContext, _super);
        /**
        * @method egret.DeviceContext#constructor
        */
        function DeviceContext() {
            _super.call(this);
            /**
            * @member egret.DeviceContext#frameRate
            */
            this.frameRate = 60;
        }
        /**
        * @method egret.DeviceContext#executeMainLoop
        * @param callback {Function}
        * @param thisObject {any}
        */
        DeviceContext.prototype.executeMainLoop = function (callback, thisObject) {
        };
        return DeviceContext;
    })(egret.HashObject);
    egret.DeviceContext = DeviceContext;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * 这个类是HTML5的WebWrapper的第一个版本
    * @stable C 目前只是实现需求，大部分API需要考虑重新设计
    */
    var Browser = (function (_super) {
        __extends(Browser, _super);
        function Browser() {
            _super.call(this);
            this.translate = (this.isHD) ? function (a) {
                return "translate3d(" + a.x + "px, " + (a.y - egret.MainContext.instance.stage.stageHeight) + "px, 0) ";
            } : function (a) {
                console.log("translate(" + a.x + "px, " + a.y + "px) ");
                return "translate(" + a.x + "px, " + a.y + "px) ";
            };
            this.rotate = (this.isHD) ? function (a) {
                return "rotateZ(" + a + "deg) ";
            } : function (a) {
                return "rotate(" + a + "deg) ";
            };
            this.ua = navigator.userAgent.toLowerCase();
            var browserTypes = this.ua.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baidubrowser|maxthon|ie|opera|firefox/) || this.ua.match(/chrome|safari/);
            if (browserTypes && browserTypes.length > 0) {
                var el = browserTypes[0];
                if (el == 'micromessenger') {
                    this.type = 'wechat';
                }
                this.type = el;
            }
            this.type = "unknow";
            switch (this.type) {
                case "firefox":
                    this.pfx = "Moz";
                    this.isHD = true;
                    break;
                case "chrome":
                case "safari":
                    this.pfx = "webkit";
                    this.isHD = true;
                    break;
                case "opera":
                    this.pfx = "O";
                    this.isHD = false;
                    break;
                case "ie":
                    this.pfx = "ms";
                    this.isHD = false;
                    break;
                default:
                    this.pfx = "webkit";
                    this.isHD = true;
            }
            this.trans = this.pfx + "Transform";
            this.isMobile = (this.ua.indexOf('mobile') != -1 || this.ua.indexOf('android') != -1);
        }
        Browser.getInstance = function () {
            if (Browser.instance == null) {
                Browser.instance = new Browser();
            }
            return Browser.instance;
        };

        Browser.prototype.$new = function (x) {
            return this.$(document.createElement(x));
        };

        Browser.prototype.$ = function (x) {
            var parent = document;
            var el = (x instanceof HTMLElement) ? x : parent.querySelector(x);
            if (el) {
                el.find = el.find || this.$;
                el.hasClass = el.hasClass || function (cls) {
                    return this.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
                };
                el.addClass = el.addClass || function (cls) {
                    if (!this.hasClass(cls)) {
                        if (this.className) {
                            this.className += " ";
                        }
                        this.className += cls;
                    }
                    return this;
                };
                el.removeClass = el.removeClass || function (cls) {
                    if (this.hasClass(cls)) {
                        this.className = this.className.replace(cls, '');
                    }
                    return this;
                };
                el.remove = el.remove || function () {
                    //                    if (this.parentNode)
                    //                        this.parentNode.removeChild(this);
                    //                        return this;
                };
                el.appendTo = el.appendTo || function (x) {
                    x.appendChild(this);
                    return this;
                };
                el.prependTo = el.prependTo || function (x) {
                    (x.childNodes[0]) ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
                    return this;
                };
                el.transforms = el.transforms || function () {
                    this.style[Browser.getInstance().trans] = Browser.getInstance().translate(this.position) + Browser.getInstance().rotate(this.rotation) + Browser.getInstance().scale(this.scale) + Browser.getInstance().skew(this.skew);
                    return this;
                };

                el.position = el.position || { x: 0, y: 0 };
                el.rotation = el.rotation || 0;
                el.scale = el.scale || { x: 1, y: 1 };
                el.skew = el.skew || { x: 0, y: 0 };

                el.translates = function (x, y) {
                    this.position.x = x;
                    this.position.y = y - egret.MainContext.instance.stage.stageHeight;
                    this.transforms();
                    return this;
                };

                el.rotate = function (x) {
                    this.rotation = x;
                    this.transforms();
                    return this;
                };

                el.resize = function (x, y) {
                    this.scale.x = x;
                    this.scale.y = y;
                    this.transforms();
                    return this;
                };

                el.setSkew = function (x, y) {
                    this.skew.x = x;
                    this.skew.y = y;
                    this.transforms();
                    return this;
                };
            }
            return el;
        };

        Browser.prototype.scale = function (a) {
            return "scale(" + a.x + ", " + a.y + ") ";
        };

        Browser.prototype.skew = function (a) {
            return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)";
        };
        return Browser;
    })(egret.HashObject);
    egret.Browser = Browser;
})(egret || (egret = {}));

egret.Codec = {name:'Jacob__Codec'};
egret.Utils = {};
/**
 * Unpack a gzipped byte array
 * @param {Array} input Byte array
 * @returns {String} Unpacked byte string
 */
egret.Utils.unzip = function () {
    return egret.Codec.GZip.gunzip.apply(egret.Codec.GZip, arguments);
};

/**
 * Unpack a gzipped byte string encoded as base64
 * @param {String} input Byte string encoded as base64
 * @returns {String} Unpacked byte string
 */
egret.Utils.unzipBase64 = function () {
    var tmpInput = egret.Codec.Base64.decode.apply(egret.Codec.Base64, arguments);
    return   egret.Codec.GZip.gunzip.apply(egret.Codec.GZip, [tmpInput]);
};

/**
 * Unpack a gzipped byte string encoded as base64
 * @param {String} input Byte string encoded as base64
 * @param {Number} bytes Bytes per array item
 * @returns {Array} Unpacked byte array
 */
egret.Utils.unzipBase64AsArray = function (input, bytes) {
    bytes = bytes || 1;

    var dec = this.unzipBase64(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }
    return ar;
};

/**
 * Unpack a gzipped byte array
 * @param {Array} input Byte array
 * @param {Number} bytes Bytes per array item
 * @returns {Array} Unpacked byte array
 */
egret.Utils.unzipAsArray = function (input, bytes) {
    bytes = bytes || 1;

    var dec = this.unzip(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }
    return ar;
};

/**
 * string to array
 * @param {String} input
 * @returns {Array} array
 */
egret.Utils.StringToArray = function (input) {
    var tmp = input.split(","), ar = [], i;
    for (i = 0; i < tmp.length; i++) {
        ar.push(parseInt(tmp[i]));
    }
    return ar;
};

egret.Codec.Base64 = {name:'Jacob__Codec__Base64'};

egret.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * <p>
 *    egret.Codec.Base64.decode(input[, unicode=false]) -> String (http://en.wikipedia.org/wiki/Base64).
 * </p>
 * @function
 * @param {String} input The base64 encoded string to decode
 * @return {String} Decodes a base64 encoded String
 * @example
 * //decode string
 * egret.Codec.Base64.decode("U29tZSBTdHJpbmc="); // => "Some String"
 */
egret.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
    var output = [],
        chr1, chr2, chr3,
        enc1, enc2, enc3, enc4,
        i = 0;

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    while (i < input.length) {
        enc1 = this._keyStr.indexOf(input.charAt(i++));
        enc2 = this._keyStr.indexOf(input.charAt(i++));
        enc3 = this._keyStr.indexOf(input.charAt(i++));
        enc4 = this._keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output.push(String.fromCharCode(chr1));

        if (enc3 != 64) {
            output.push(String.fromCharCode(chr2));
        }
        if (enc4 != 64) {
            output.push(String.fromCharCode(chr3));
        }
    }

    output = output.join('');

    return output;
};

/**
 * <p>
 *    Converts an input string encoded in base64 to an array of integers whose<br/>
 *    values represent the decoded string's characters' bytes.
 * </p>
 * @function
 * @param {String} input The String to convert to an array of Integers
 * @param {Number} bytes
 * @return {Array}
 * @example
 * //decode string to array
 * var decodeArr = egret.Codec.Base64.decodeAsArray("U29tZSBTdHJpbmc=");
 */
egret.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
    var dec = this.decode(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }

    return ar;
};

egret.Utils.uint8ArrayToUint32Array = function(uint8Arr){
    if(uint8Arr.length % 4 != 0)
        return null;

    var arrLen = uint8Arr.length /4;
    var retArr = window.Uint32Array? new Uint32Array(arrLen) : [];
    for(var i = 0; i < arrLen; i++){
        var offset = i * 4;
        retArr[i] = uint8Arr[offset]  + uint8Arr[offset + 1] * (1 << 8) + uint8Arr[offset + 2] * (1 << 16) + uint8Arr[offset + 3] * (1<<24);
    }
    return retArr;
};

egret.Codec.GZip = function Jacob__GZip(data) {
    this.data = data;

    this.debug = false;
    this.gpflags = undefined;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = new Array(32768);
    this.bIdx = 0;
    this.modeZIP = false;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = undefined;
    this.literalTree = new Array(egret.Codec.GZip.LITERALS);
    this.distanceTree = new Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = new Array(17);
    this.fpos[0] = 0;
    this.flens = undefined;
    this.fmax = undefined;
};

/**
 * Unzips the gzipped data of the 'data' argument.
 * @param string  The bytestream to decompress. Either an array of Integers between 0 and 255, or a String.
 * @return {String}
 */
egret.Codec.GZip.gunzip = function (string) {
    if (string.constructor === Array) {
    } else if (string.constructor === String) {
    }
    var gzip = new egret.Codec.GZip(string);
    return gzip.gunzip()[0][0];
};

egret.Codec.GZip.HufNode = function () {
    this.b0 = 0;
    this.b1 = 0;
    this.jump = null;
    this.jumppos = -1;
};

/**
 * @constant
 * @type Number
 */
egret.Codec.GZip.LITERALS = 288;
/**
 * @constant
 * @type Number
 */
egret.Codec.GZip.NAMEMAX = 256;

egret.Codec.GZip.bitReverse = [
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
];
egret.Codec.GZip.cplens = [
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];
egret.Codec.GZip.cplext = [
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
];
/* 99==invalid */
egret.Codec.GZip.cpdist = [
    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
    0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
    0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
    0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
];
egret.Codec.GZip.cpdext = [
    0, 0, 0, 0, 1, 1, 2, 2,
    3, 3, 4, 4, 5, 5, 6, 6,
    7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13
];
egret.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


/**
 * gunzip
 * @return {Array}
 */
egret.Codec.GZip.prototype.gunzip = function () {
    this.outputArr = [];

    //convertToByteArray(input);
    //if (this.debug) alert(this.data);

    this.nextFile();
    return this.unzipped;
};

egret.Codec.GZip.prototype.readByte = function () {
    this.bits += 8;
    if (this.bytepos < this.data.length) {
        //return this.data[this.bytepos++]; // Array
        return this.data.charCodeAt(this.bytepos++);
    } else {
        return -1;
    }
};

egret.Codec.GZip.prototype.byteAlign = function () {
    this.bb = 1;
};

egret.Codec.GZip.prototype.readBit = function () {
    var carry;
    this.bits++;
    carry = (this.bb & 1);
    this.bb >>= 1;
    if (this.bb == 0) {
        this.bb = this.readByte();
        carry = (this.bb & 1);
        this.bb = (this.bb >> 1) | 0x80;
    }
    return carry;
};

egret.Codec.GZip.prototype.readBits = function (a) {
    var res = 0,
        i = a;

    while (i--) res = (res << 1) | this.readBit();
    if (a) res = egret.Codec.GZip.bitReverse[res] >> (8 - a);

    return res;
};

egret.Codec.GZip.prototype.flushBuffer = function () {
    this.bIdx = 0;
};

egret.Codec.GZip.prototype.addBuffer = function (a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    if (this.bIdx == 0x8000) this.bIdx = 0;
};

egret.Codec.GZip.prototype.IsPat = function () {
    while (1) {
        if (this.fpos[this.len] >= this.fmax)       return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++;
    }
};

egret.Codec.GZip.prototype.Rec = function () {
    var curplace = this.Places[this.treepos];
    var tmp;
    //if (this.debug) document.write("<br>len:"+this.len+" treepos:"+this.treepos);
    if (this.len == 17) { //war 17
        return -1;
    }
    this.treepos++;
    this.len++;

    tmp = this.IsPat();
    //if (this.debug) document.write("<br>IsPat "+tmp);
    if (tmp >= 0) {
        curplace.b0 = tmp;
        /* leaf cell for 0-bit */
        //if (this.debug) document.write("<br>b0 "+curplace.b0);
    } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        //if (this.debug) document.write("<br>b0 "+curplace.b0);
        if (this.Rec()) return -1;
    }
    tmp = this.IsPat();
    if (tmp >= 0) {
        curplace.b1 = tmp;
        /* leaf cell for 1-bit */
        //if (this.debug) document.write("<br>b1 "+curplace.b1);
        curplace.jump = null;
        /* Just for the display routine */
    } else {
        /* Not a Leaf cell */
        curplace.b1 = 0x8000;
        //if (this.debug) document.write("<br>b1 "+curplace.b1);
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec()) return -1;
    }
    this.len--;
    return 0;
};

egret.Codec.GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
    var i;
    /* Create the Huffman decode tree/table */
    //if (this.debug) document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
    this.Places = currentTree;
    this.treepos = 0;
    this.flens = lengths;
    this.fmax = numval;
    for (i = 0; i < 17; i++) this.fpos[i] = 0;
    this.len = 0;
    if (this.Rec()) {
        //if (this.debug) alert("invalid huffman tree\n");
        return -1;
    }
    // if (this.debug) {
    //   document.write('<br>Tree: '+this.Places.length);
    //   for (var a=0;a<32;a++){
    //     document.write("Places["+a+"].b0="+this.Places[a].b0+"<br>");
    //     document.write("Places["+a+"].b1="+this.Places[a].b1+"<br>");
    //   }
    // }

    return 0;
};

egret.Codec.GZip.prototype.DecodeValue = function (currentTree) {
    var len, i,
        xtreepos = 0,
        X = currentTree[xtreepos],
        b;

    /* decode one symbol of the data */
    while (1) {
        b = this.readBit();
        // if (this.debug) document.write("b="+b);
        if (b) {
            if (!(X.b1 & 0x8000)) {
                // if (this.debug) document.write("ret1");
                return X.b1;
                /* If leaf node, return data */
            }
            X = X.jump;
            len = currentTree.length;
            for (i = 0; i < len; i++) {
                if (currentTree[i] === X) {
                    xtreepos = i;
                    break;
                }
            }
        } else {
            if (!(X.b0 & 0x8000)) {
                // if (this.debug) document.write("ret2");
                return X.b0;
                /* If leaf node, return data */
            }
            xtreepos++;
            X = currentTree[xtreepos];
        }
    }
    // if (this.debug) document.write("ret3");

    return -1;
};

egret.Codec.GZip.prototype.DeflateLoop = function () {
    var last, c, type, i, len;
    do {
        last = this.readBit();
        type = this.readBits(2);

        if (type == 0) {
            var blockLen, cSum;

            // Stored
            this.byteAlign();
            blockLen = this.readByte();
            blockLen |= (this.readByte() << 8);

            cSum = this.readByte();
            cSum |= (this.readByte() << 8);

            if (((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n"); // FIXME: use throw
            }
            while (blockLen--) {
                c = this.readByte();
                this.addBuffer(c);
            }
        } else if (type == 1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while (1) {
                /*
                 256    0000000        0
                 :   :     :
                 279    0010111        23
                 0   00110000    48
                 :    :      :
                 143    10111111    191
                 280 11000000    192
                 :    :      :
                 287 11000111    199
                 144    110010000    400
                 :    :       :
                 255    111111111    511

                 Note the bit order!
                 */
                j = (egret.Codec.GZip.bitReverse[this.readBits(7)] >> 1);
                if (j > 23) {
                    j = (j << 1) | this.readBit();
                    /* 48..255 */

                    if (j > 199) {              /* 200..255 */
                        j -= 128;
                        /*  72..127 */
                        j = (j << 1) | this.readBit();
                        /* 144..255 << */
                    } else {                    /*  48..199 */
                        j -= 48;
                        /*   0..151 */
                        if (j > 143) {
                            j = j + 136;
                            /* 280..287 << */
                            /*   0..143 << */
                        }
                    }
                } else {                      /*   0..23 */
                    j += 256;
                    /* 256..279 << */
                }
                if (j < 256) {
                    this.addBuffer(j);
                } else if (j == 256) {
                    /* EOF */
                    break; // FIXME: make this the loop-condition
                } else {
                    var len, dist;

                    j -= 256 + 1;
                    /* bytes + EOF */
                    len = this.readBits(egret.Codec.GZip.cplext[j]) + egret.Codec.GZip.cplens[j];

                    j = egret.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
                    if (egret.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= (this.readBits(egret.Codec.GZip.cpdext[j] - 8) << 8);
                    } else {
                        dist = this.readBits(egret.Codec.GZip.cpdext[j]);
                    }
                    dist += egret.Codec.GZip.cpdist[j];

                    for (j = 0; j < len; j++) {
                        var c = this.buf32k[(this.bIdx - dist) & 0x7fff];
                        this.addBuffer(c);
                    }
                }
            } // while

        } else if (type == 2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288 + 32);    // "static" just to preserve stack

            // Dynamic Huffman tables

            literalCodes = 257 + this.readBits(5);
            distCodes = 1 + this.readBits(5);
            lenCodes = 4 + this.readBits(4);
            for (j = 0; j < 19; j++) {
                ll[j] = 0;
            }

            // Get the decode tree code lengths

            for (j = 0; j < lenCodes; j++) {
                ll[egret.Codec.GZip.border[j]] = this.readBits(3);
            }
            len = this.distanceTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new egret.Codec.GZip.HufNode();
            if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                this.flushBuffer();
                return 1;
            }
            // if (this.debug) {
            //   document.write("<br>distanceTree");
            //   for(var a=0;a<this.distanceTree.length;a++){
            //     document.write("<br>"+this.distanceTree[a].b0+" "+this.distanceTree[a].b1+" "+this.distanceTree[a].jump+" "+this.distanceTree[a].jumppos);
            //   }
            // }

            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z = -1;
            // if (this.debug) document.write("<br>n="+n+" bits: "+this.bits+"<br>");
            while (i < n) {
                z++;
                j = this.DecodeValue(this.distanceTree);
                // if (this.debug) document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+this.bits+"<br>");
                if (j < 16) {    // length of code in bits (0..15)
                    ll[i++] = j;
                } else if (j == 16) {    // repeat last length 3 to 6 times
                    var l;
                    j = 3 + this.readBits(2);
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i - 1] : 0;
                    while (j--) {
                        ll[i++] = l;
                    }
                } else {
                    if (j == 17) {        // 3 to 10 zero length codes
                        j = 3 + this.readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes
                        j = 11 + this.readBits(7);
                    }
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                    }
                    while (j--) {
                        ll[i++] = 0;
                    }
                }
            } // while

            // Can overwrite tree decode tree as it is not used anymore
            len = this.literalTree.length;
            for (i = 0; i < len; i++)
                this.literalTree[i] = new egret.Codec.GZip.HufNode();
            if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                this.flushBuffer();
                return 1;
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new egret.Codec.GZip.HufNode();
            var ll2 = new Array();
            for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
            if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                this.flushBuffer();
                return 1;
            }
            // if (this.debug) document.write("<br>literalTree");
            while (1) {
                j = this.DecodeValue(this.literalTree);
                if (j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if (j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = this.readBits(egret.Codec.GZip.cplext[j]) + egret.Codec.GZip.cplens[j];

                    j = this.DecodeValue(this.distanceTree);
                    if (egret.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= (this.readBits(egret.Codec.GZip.cpdext[j] - 8) << 8);
                    } else {
                        dist = this.readBits(egret.Codec.GZip.cpdext[j]);
                    }
                    dist += egret.Codec.GZip.cpdist[j];
                    while (len--) {
                        var c = this.buf32k[(this.bIdx - dist) & 0x7fff];
                        this.addBuffer(c);
                    }
                } else {
                    this.addBuffer(j);
                }
            } // while
        }
    } while (!last);
    this.flushBuffer();

    this.byteAlign();
    return 0;
};

egret.Codec.GZip.prototype.unzipFile = function (name) {
    var i;
    this.gunzip();
    for (i = 0; i < this.unzipped.length; i++) {
        if (this.unzipped[i][1] == name) {
            return this.unzipped[i][0];
        }
    }
};

egret.Codec.GZip.prototype.nextFile = function () {
    // if (this.debug) alert("NEXTFILE");

    this.outputArr = [];
    this.modeZIP = false;

    var tmp = [];
    tmp[0] = this.readByte();
    tmp[1] = this.readByte();
    // if (this.debug) alert("type: "+tmp[0]+" "+tmp[1]);

    if (tmp[0] == 0x78 && tmp[1] == 0xda) { //GZIP
        // if (this.debug) alert("GEONExT-GZIP");
        this.DeflateLoop();
        // if (this.debug) alert(this.outputArr.join(''));
        this.unzipped[this.files] = [this.outputArr.join(''), "geonext.gxt"];
        this.files++;
    }
    if (tmp[0] == 0x1f && tmp[1] == 0x8b) { //GZIP
        // if (this.debug) alert("GZIP");
        this.skipdir();
        // if (this.debug) alert(this.outputArr.join(''));
        this.unzipped[this.files] = [this.outputArr.join(''), "file"];
        this.files++;
    }
    if (tmp[0] == 0x50 && tmp[1] == 0x4b) { //ZIP
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (tmp[2] == 0x03 && tmp[3] == 0x04) {
            //MODE_ZIP
            tmp[0] = this.readByte();
            tmp[1] = this.readByte();
            // if (this.debug) alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);

            this.gpflags = this.readByte();
            this.gpflags |= (this.readByte() << 8);
            // if (this.debug) alert("gpflags: "+this.gpflags);

            var method = this.readByte();
            method |= (this.readByte() << 8);
            // if (this.debug) alert("method: "+method);

            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();

//       var crc = this.readByte();
//       crc |= (this.readByte()<<8);
//       crc |= (this.readByte()<<16);
//       crc |= (this.readByte()<<24);

            var compSize = this.readByte();
            compSize |= (this.readByte() << 8);
            compSize |= (this.readByte() << 16);
            compSize |= (this.readByte() << 24);

            var size = this.readByte();
            size |= (this.readByte() << 8);
            size |= (this.readByte() << 16);
            size |= (this.readByte() << 24);

            // if (this.debug) alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);

            var filelen = this.readByte();
            filelen |= (this.readByte() << 8);

            var extralen = this.readByte();
            extralen |= (this.readByte() << 8);

            // if (this.debug) alert("filelen "+filelen);
            i = 0;
            this.nameBuf = [];
            while (filelen--) {
                var c = this.readByte();
                if (c == "/" | c == ":") {
                    i = 0;
                } else if (i < egret.Codec.GZip.NAMEMAX - 1) {
                    this.nameBuf[i++] = String.fromCharCode(c);
                }
            }
            // if (this.debug) alert("nameBuf: "+this.nameBuf);

            if (!this.fileout) this.fileout = this.nameBuf;

            var i = 0;
            while (i < extralen) {
                c = this.readByte();
                i++;
            }

            // if (size = 0 && this.fileOut.charAt(this.fileout.length-1)=="/"){
            //   //skipdir
            //   // if (this.debug) alert("skipdir");
            // }
            if (method == 8) {
                this.DeflateLoop();
                // if (this.debug) alert(this.outputArr.join(''));
                this.unzipped[this.files] = [this.outputArr.join(''), this.nameBuf.join('')];
                this.files++;
            }
            this.skipdir();
        }
    }
};

egret.Codec.GZip.prototype.skipdir = function () {
    var tmp = [];
    var compSize, size, os, i, c;

    if ((this.gpflags & 8)) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();

//     if (tmp[0] == 0x50 && tmp[1] == 0x4b && tmp[2] == 0x07 && tmp[3] == 0x08) {
//       crc = this.readByte();
//       crc |= (this.readByte()<<8);
//       crc |= (this.readByte()<<16);
//       crc |= (this.readByte()<<24);
//     } else {
//       crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
//     }

        compSize = this.readByte();
        compSize |= (this.readByte() << 8);
        compSize |= (this.readByte() << 16);
        compSize |= (this.readByte() << 24);

        size = this.readByte();
        size |= (this.readByte() << 8);
        size |= (this.readByte() << 16);
        size |= (this.readByte() << 24);
    }

    if (this.modeZIP) this.nextFile();

    tmp[0] = this.readByte();
    if (tmp[0] != 8) {
        // if (this.debug) alert("Unknown compression method!");
        return 0;
    }

    this.gpflags = this.readByte();
    // if (this.debug && (this.gpflags & ~(0x1f))) alert("Unknown flags set!");

    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();

    this.readByte();
    os = this.readByte();

    if ((this.gpflags & 4)) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        // if (this.debug) alert("Extra field size: "+this.len);
        for (i = 0; i < this.len; i++)
            this.readByte();
    }

    if ((this.gpflags & 8)) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
            if (c == "7" || c == ":")
                i = 0;
            if (i < egret.Codec.GZip.NAMEMAX - 1)
                this.nameBuf[i++] = c;
        }
        //this.nameBuf[i] = "\0";
        // if (this.debug) alert("original file name: "+this.nameBuf);
    }

    if ((this.gpflags & 16)) {
        while (c = this.readByte()) { // FIXME: looks like they read to the end of the stream, should be doable more efficiently
            //FILE COMMENT
        }
    }

    if ((this.gpflags & 2)) {
        this.readByte();
        this.readByte();
    }

    this.DeflateLoop();

//   crc = this.readByte();
//   crc |= (this.readByte()<<8);
//   crc |= (this.readByte()<<16);
//   crc |= (this.readByte()<<24);

    size = this.readByte();
    size |= (this.readByte() << 8);
    size |= (this.readByte() << 16);
    size |= (this.readByte() << 24);

    if (this.modeZIP) this.nextFile();
};

/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {'use strict';function i(a){throw a;}var r=void 0,v=!0,aa=this;function y(a,c){var b=a.split("."),e=aa;!(b[0]in e)&&e.execScript&&e.execScript("var "+b[0]);for(var f;b.length&&(f=b.shift());)!b.length&&c!==r?e[f]=c:e=e[f]?e[f]:e[f]={}};var H="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array;function ba(a){if("string"===typeof a){var c=a.split(""),b,e;b=0;for(e=c.length;b<e;b++)c[b]=(c[b].charCodeAt(0)&255)>>>0;a=c}for(var f=1,d=0,g=a.length,h,m=0;0<g;){h=1024<g?1024:g;g-=h;do f+=a[m++],d+=f;while(--h);f%=65521;d%=65521}return(d<<16|f)>>>0};function J(a,c){this.index="number"===typeof c?c:0;this.i=0;this.buffer=a instanceof(H?Uint8Array:Array)?a:new (H?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&i(Error("invalid index"));this.buffer.length<=this.index&&this.f()}J.prototype.f=function(){var a=this.buffer,c,b=a.length,e=new (H?Uint8Array:Array)(b<<1);if(H)e.set(a);else for(c=0;c<b;++c)e[c]=a[c];return this.buffer=e};
J.prototype.d=function(a,c,b){var e=this.buffer,f=this.index,d=this.i,g=e[f],h;b&&1<c&&(a=8<c?(N[a&255]<<24|N[a>>>8&255]<<16|N[a>>>16&255]<<8|N[a>>>24&255])>>32-c:N[a]>>8-c);if(8>c+d)g=g<<c|a,d+=c;else for(h=0;h<c;++h)g=g<<1|a>>c-h-1&1,8===++d&&(d=0,e[f++]=N[g],g=0,f===e.length&&(e=this.f()));e[f]=g;this.buffer=e;this.i=d;this.index=f};J.prototype.finish=function(){var a=this.buffer,c=this.index,b;0<this.i&&(a[c]<<=8-this.i,a[c]=N[a[c]],c++);H?b=a.subarray(0,c):(a.length=c,b=a);return b};
var ca=new (H?Uint8Array:Array)(256),ha;for(ha=0;256>ha;++ha){for(var R=ha,ia=R,ja=7,R=R>>>1;R;R>>>=1)ia<<=1,ia|=R&1,--ja;ca[ha]=(ia<<ja&255)>>>0}var N=ca;var ka=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,
2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,
2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,
2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,
3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,
936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];H&&new Uint32Array(ka);function la(a){this.buffer=new (H?Uint16Array:Array)(2*a);this.length=0}la.prototype.getParent=function(a){return 2*((a-2)/4|0)};la.prototype.push=function(a,c){var b,e,f=this.buffer,d;b=this.length;f[this.length++]=c;for(f[this.length++]=a;0<b;)if(e=this.getParent(b),f[b]>f[e])d=f[b],f[b]=f[e],f[e]=d,d=f[b+1],f[b+1]=f[e+1],f[e+1]=d,b=e;else break;return this.length};
la.prototype.pop=function(){var a,c,b=this.buffer,e,f,d;c=b[0];a=b[1];this.length-=2;b[0]=b[this.length];b[1]=b[this.length+1];for(d=0;;){f=2*d+2;if(f>=this.length)break;f+2<this.length&&b[f+2]>b[f]&&(f+=2);if(b[f]>b[d])e=b[d],b[d]=b[f],b[f]=e,e=b[d+1],b[d+1]=b[f+1],b[f+1]=e;else break;d=f}return{index:a,value:c,length:this.length}};function S(a){var c=a.length,b=0,e=Number.POSITIVE_INFINITY,f,d,g,h,m,j,s,n,l;for(n=0;n<c;++n)a[n]>b&&(b=a[n]),a[n]<e&&(e=a[n]);f=1<<b;d=new (H?Uint32Array:Array)(f);g=1;h=0;for(m=2;g<=b;){for(n=0;n<c;++n)if(a[n]===g){j=0;s=h;for(l=0;l<g;++l)j=j<<1|s&1,s>>=1;for(l=j;l<f;l+=m)d[l]=g<<16|n;++h}++g;h<<=1;m<<=1}return[d,b,e]};function ma(a,c){this.h=pa;this.w=0;this.input=a;this.b=0;c&&(c.lazy&&(this.w=c.lazy),"number"===typeof c.compressionType&&(this.h=c.compressionType),c.outputBuffer&&(this.a=H&&c.outputBuffer instanceof Array?new Uint8Array(c.outputBuffer):c.outputBuffer),"number"===typeof c.outputIndex&&(this.b=c.outputIndex));this.a||(this.a=new (H?Uint8Array:Array)(32768))}var pa=2,qa={NONE:0,r:1,j:pa,N:3},ra=[],T;
for(T=0;288>T;T++)switch(v){case 143>=T:ra.push([T+48,8]);break;case 255>=T:ra.push([T-144+400,9]);break;case 279>=T:ra.push([T-256+0,7]);break;case 287>=T:ra.push([T-280+192,8]);break;default:i("invalid literal: "+T)}
ma.prototype.n=function(){var a,c,b,e,f=this.input;switch(this.h){case 0:b=0;for(e=f.length;b<e;){c=H?f.subarray(b,b+65535):f.slice(b,b+65535);b+=c.length;var d=c,g=b===e,h=r,m=r,j=r,s=r,n=r,l=this.a,q=this.b;if(H){for(l=new Uint8Array(this.a.buffer);l.length<=q+d.length+5;)l=new Uint8Array(l.length<<1);l.set(this.a)}h=g?1:0;l[q++]=h|0;m=d.length;j=~m+65536&65535;l[q++]=m&255;l[q++]=m>>>8&255;l[q++]=j&255;l[q++]=j>>>8&255;if(H)l.set(d,q),q+=d.length,l=l.subarray(0,q);else{s=0;for(n=d.length;s<n;++s)l[q++]=
d[s];l.length=q}this.b=q;this.a=l}break;case 1:var E=new J(new Uint8Array(this.a.buffer),this.b);E.d(1,1,v);E.d(1,2,v);var t=sa(this,f),z,K,A;z=0;for(K=t.length;z<K;z++)if(A=t[z],J.prototype.d.apply(E,ra[A]),256<A)E.d(t[++z],t[++z],v),E.d(t[++z],5),E.d(t[++z],t[++z],v);else if(256===A)break;this.a=E.finish();this.b=this.a.length;break;case pa:var x=new J(new Uint8Array(this.a),this.b),B,k,p,D,C,da=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],W,Ma,ea,Na,na,va=Array(19),Oa,$,oa,F,Pa;B=pa;x.d(1,
1,v);x.d(B,2,v);k=sa(this,f);W=ta(this.L,15);Ma=ua(W);ea=ta(this.K,7);Na=ua(ea);for(p=286;257<p&&0===W[p-1];p--);for(D=30;1<D&&0===ea[D-1];D--);var Qa=p,Ra=D,M=new (H?Uint32Array:Array)(Qa+Ra),u,O,w,fa,L=new (H?Uint32Array:Array)(316),I,G,P=new (H?Uint8Array:Array)(19);for(u=O=0;u<Qa;u++)M[O++]=W[u];for(u=0;u<Ra;u++)M[O++]=ea[u];if(!H){u=0;for(fa=P.length;u<fa;++u)P[u]=0}u=I=0;for(fa=M.length;u<fa;u+=O){for(O=1;u+O<fa&&M[u+O]===M[u];++O);w=O;if(0===M[u])if(3>w)for(;0<w--;)L[I++]=0,P[0]++;else for(;0<
w;)G=138>w?w:138,G>w-3&&G<w&&(G=w-3),10>=G?(L[I++]=17,L[I++]=G-3,P[17]++):(L[I++]=18,L[I++]=G-11,P[18]++),w-=G;else if(L[I++]=M[u],P[M[u]]++,w--,3>w)for(;0<w--;)L[I++]=M[u],P[M[u]]++;else for(;0<w;)G=6>w?w:6,G>w-3&&G<w&&(G=w-3),L[I++]=16,L[I++]=G-3,P[16]++,w-=G}a=H?L.subarray(0,I):L.slice(0,I);na=ta(P,7);for(F=0;19>F;F++)va[F]=na[da[F]];for(C=19;4<C&&0===va[C-1];C--);Oa=ua(na);x.d(p-257,5,v);x.d(D-1,5,v);x.d(C-4,4,v);for(F=0;F<C;F++)x.d(va[F],3,v);F=0;for(Pa=a.length;F<Pa;F++)if($=a[F],x.d(Oa[$],
na[$],v),16<=$){F++;switch($){case 16:oa=2;break;case 17:oa=3;break;case 18:oa=7;break;default:i("invalid code: "+$)}x.d(a[F],oa,v)}var Sa=[Ma,W],Ta=[Na,ea],Q,Ua,ga,ya,Va,Wa,Xa,Ya;Va=Sa[0];Wa=Sa[1];Xa=Ta[0];Ya=Ta[1];Q=0;for(Ua=k.length;Q<Ua;++Q)if(ga=k[Q],x.d(Va[ga],Wa[ga],v),256<ga)x.d(k[++Q],k[++Q],v),ya=k[++Q],x.d(Xa[ya],Ya[ya],v),x.d(k[++Q],k[++Q],v);else if(256===ga)break;this.a=x.finish();this.b=this.a.length;break;default:i("invalid compression type")}return this.a};
function wa(a,c){this.length=a;this.G=c}
function xa(){var a=za;switch(v){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,a-
31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:i("invalid length: "+a)}}var Aa=[],za,Ba;
for(za=3;258>=za;za++)Ba=xa(),Aa[za]=Ba[2]<<24|Ba[1]<<16|Ba[0];var Ca=H?new Uint32Array(Aa):Aa;
function sa(a,c){function b(a,c){var b=a.G,d=[],e=0,f;f=Ca[a.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(v){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===b:g=[3,b-4,0];break;case 6>=b:g=[4,b-5,1];break;case 8>=b:g=[5,b-7,1];break;case 12>=b:g=[6,b-9,2];break;case 16>=b:g=[7,b-13,2];break;case 24>=b:g=[8,b-17,3];break;case 32>=b:g=[9,b-25,3];break;case 48>=b:g=[10,b-33,4];break;case 64>=b:g=[11,b-49,4];break;case 96>=b:g=[12,b-
65,5];break;case 128>=b:g=[13,b-97,5];break;case 192>=b:g=[14,b-129,6];break;case 256>=b:g=[15,b-193,6];break;case 384>=b:g=[16,b-257,7];break;case 512>=b:g=[17,b-385,7];break;case 768>=b:g=[18,b-513,8];break;case 1024>=b:g=[19,b-769,8];break;case 1536>=b:g=[20,b-1025,9];break;case 2048>=b:g=[21,b-1537,9];break;case 3072>=b:g=[22,b-2049,10];break;case 4096>=b:g=[23,b-3073,10];break;case 6144>=b:g=[24,b-4097,11];break;case 8192>=b:g=[25,b-6145,11];break;case 12288>=b:g=[26,b-8193,12];break;case 16384>=
b:g=[27,b-12289,12];break;case 24576>=b:g=[28,b-16385,13];break;case 32768>=b:g=[29,b-24577,13];break;default:i("invalid distance")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,j;h=0;for(j=d.length;h<j;++h)l[q++]=d[h];t[d[0]]++;z[d[3]]++;E=a.length+c-1;n=null}var e,f,d,g,h,m={},j,s,n,l=H?new Uint16Array(2*c.length):[],q=0,E=0,t=new (H?Uint32Array:Array)(286),z=new (H?Uint32Array:Array)(30),K=a.w,A;if(!H){for(d=0;285>=d;)t[d++]=0;for(d=0;29>=d;)z[d++]=0}t[256]=1;e=0;for(f=c.length;e<f;++e){d=h=0;
for(g=3;d<g&&e+d!==f;++d)h=h<<8|c[e+d];m[h]===r&&(m[h]=[]);j=m[h];if(!(0<E--)){for(;0<j.length&&32768<e-j[0];)j.shift();if(e+3>=f){n&&b(n,-1);d=0;for(g=f-e;d<g;++d)A=c[e+d],l[q++]=A,++t[A];break}if(0<j.length){var x=r,B=r,k=0,p=r,D=r,C=r,da=r,W=c.length,D=0,da=j.length;a:for(;D<da;D++){x=j[da-D-1];p=3;if(3<k){for(C=k;3<C;C--)if(c[x+C-1]!==c[e+C-1])continue a;p=k}for(;258>p&&e+p<W&&c[x+p]===c[e+p];)++p;p>k&&(B=x,k=p);if(258===p)break}s=new wa(k,e-B);n?n.length<s.length?(A=c[e-1],l[q++]=A,++t[A],b(s,
0)):b(n,-1):s.length<K?n=s:b(s,0)}else n?b(n,-1):(A=c[e],l[q++]=A,++t[A])}j.push(e)}l[q++]=256;t[256]++;a.L=t;a.K=z;return H?l.subarray(0,q):l}
function ta(a,c){function b(a){var c=z[a][K[a]];c===n?(b(a+1),b(a+1)):--E[c];++K[a]}var e=a.length,f=new la(572),d=new (H?Uint8Array:Array)(e),g,h,m,j,s;if(!H)for(j=0;j<e;j++)d[j]=0;for(j=0;j<e;++j)0<a[j]&&f.push(j,a[j]);g=Array(f.length/2);h=new (H?Uint32Array:Array)(f.length/2);if(1===g.length)return d[f.pop().index]=1,d;j=0;for(s=f.length/2;j<s;++j)g[j]=f.pop(),h[j]=g[j].value;var n=h.length,l=new (H?Uint16Array:Array)(c),q=new (H?Uint8Array:Array)(c),E=new (H?Uint8Array:Array)(n),t=Array(c),z=
Array(c),K=Array(c),A=(1<<c)-n,x=1<<c-1,B,k,p,D,C;l[c-1]=n;for(k=0;k<c;++k)A<x?q[k]=0:(q[k]=1,A-=x),A<<=1,l[c-2-k]=(l[c-1-k]/2|0)+n;l[0]=q[0];t[0]=Array(l[0]);z[0]=Array(l[0]);for(k=1;k<c;++k)l[k]>2*l[k-1]+q[k]&&(l[k]=2*l[k-1]+q[k]),t[k]=Array(l[k]),z[k]=Array(l[k]);for(B=0;B<n;++B)E[B]=c;for(p=0;p<l[c-1];++p)t[c-1][p]=h[p],z[c-1][p]=p;for(B=0;B<c;++B)K[B]=0;1===q[c-1]&&(--E[0],++K[c-1]);for(k=c-2;0<=k;--k){D=B=0;C=K[k+1];for(p=0;p<l[k];p++)D=t[k+1][C]+t[k+1][C+1],D>h[B]?(t[k][p]=D,z[k][p]=n,C+=2):
(t[k][p]=h[B],z[k][p]=B,++B);K[k]=0;1===q[k]&&b(k)}m=E;j=0;for(s=g.length;j<s;++j)d[g[j].index]=m[j];return d}function ua(a){var c=new (H?Uint16Array:Array)(a.length),b=[],e=[],f=0,d,g,h,m;d=0;for(g=a.length;d<g;d++)b[a[d]]=(b[a[d]]|0)+1;d=1;for(g=16;d<=g;d++)e[d]=f,f+=b[d]|0,f>1<<d&&i("overcommitted"),f<<=1;65536>f&&i("undercommitted");d=0;for(g=a.length;d<g;d++){f=e[a[d]];e[a[d]]+=1;h=c[d]=0;for(m=a[d];h<m;h++)c[d]=c[d]<<1|f&1,f>>>=1}return c};function Da(a,c){this.input=a;this.a=new (H?Uint8Array:Array)(32768);this.h=U.j;var b={},e;if((c||!(c={}))&&"number"===typeof c.compressionType)this.h=c.compressionType;for(e in c)b[e]=c[e];b.outputBuffer=this.a;this.z=new ma(this.input,b)}var U=qa;
Da.prototype.n=function(){var a,c,b,e,f,d,g,h=0;g=this.a;a=Ea;switch(a){case Ea:c=Math.LOG2E*Math.log(32768)-8;break;default:i(Error("invalid compression method"))}b=c<<4|a;g[h++]=b;switch(a){case Ea:switch(this.h){case U.NONE:f=0;break;case U.r:f=1;break;case U.j:f=2;break;default:i(Error("unsupported compression type"))}break;default:i(Error("invalid compression method"))}e=f<<6|0;g[h++]=e|31-(256*b+e)%31;d=ba(this.input);this.z.b=h;g=this.z.n();h=g.length;H&&(g=new Uint8Array(g.buffer),g.length<=
h+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,h+4));g[h++]=d>>24&255;g[h++]=d>>16&255;g[h++]=d>>8&255;g[h++]=d&255;return g};y("Zlib.Deflate",Da);y("Zlib.Deflate.compress",function(a,c){return(new Da(a,c)).n()});y("Zlib.Deflate.CompressionType",U);y("Zlib.Deflate.CompressionType.NONE",U.NONE);y("Zlib.Deflate.CompressionType.FIXED",U.r);y("Zlib.Deflate.CompressionType.DYNAMIC",U.j);function V(a,c){this.k=[];this.l=32768;this.e=this.g=this.c=this.q=0;this.input=H?new Uint8Array(a):a;this.s=!1;this.m=Fa;this.B=!1;if(c||!(c={}))c.index&&(this.c=c.index),c.bufferSize&&(this.l=c.bufferSize),c.bufferType&&(this.m=c.bufferType),c.resize&&(this.B=c.resize);switch(this.m){case Ga:this.b=32768;this.a=new (H?Uint8Array:Array)(32768+this.l+258);break;case Fa:this.b=0;this.a=new (H?Uint8Array:Array)(this.l);this.f=this.J;this.t=this.H;this.o=this.I;break;default:i(Error("invalid inflate mode"))}}
var Ga=0,Fa=1,Ha={D:Ga,C:Fa};
V.prototype.p=function(){for(;!this.s;){var a=X(this,3);a&1&&(this.s=v);a>>>=1;switch(a){case 0:var c=this.input,b=this.c,e=this.a,f=this.b,d=r,g=r,h=r,m=e.length,j=r;this.e=this.g=0;d=c[b++];d===r&&i(Error("invalid uncompressed block header: LEN (first byte)"));g=d;d=c[b++];d===r&&i(Error("invalid uncompressed block header: LEN (second byte)"));g|=d<<8;d=c[b++];d===r&&i(Error("invalid uncompressed block header: NLEN (first byte)"));h=d;d=c[b++];d===r&&i(Error("invalid uncompressed block header: NLEN (second byte)"));h|=
d<<8;g===~h&&i(Error("invalid uncompressed block header: length verify"));b+g>c.length&&i(Error("input buffer is broken"));switch(this.m){case Ga:for(;f+g>e.length;){j=m-f;g-=j;if(H)e.set(c.subarray(b,b+j),f),f+=j,b+=j;else for(;j--;)e[f++]=c[b++];this.b=f;e=this.f();f=this.b}break;case Fa:for(;f+g>e.length;)e=this.f({v:2});break;default:i(Error("invalid inflate mode"))}if(H)e.set(c.subarray(b,b+g),f),f+=g,b+=g;else for(;g--;)e[f++]=c[b++];this.c=b;this.b=f;this.a=e;break;case 1:this.o(Ia,Ja);break;
case 2:Ka(this);break;default:i(Error("unknown BTYPE: "+a))}}return this.t()};
var La=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],Za=H?new Uint16Array(La):La,$a=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],ab=H?new Uint16Array($a):$a,bb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],cb=H?new Uint8Array(bb):bb,db=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],eb=H?new Uint16Array(db):db,fb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,
10,11,11,12,12,13,13],gb=H?new Uint8Array(fb):fb,hb=new (H?Uint8Array:Array)(288),Y,ib;Y=0;for(ib=hb.length;Y<ib;++Y)hb[Y]=143>=Y?8:255>=Y?9:279>=Y?7:8;var Ia=S(hb),jb=new (H?Uint8Array:Array)(30),kb,lb;kb=0;for(lb=jb.length;kb<lb;++kb)jb[kb]=5;var Ja=S(jb);function X(a,c){for(var b=a.g,e=a.e,f=a.input,d=a.c,g;e<c;)g=f[d++],g===r&&i(Error("input buffer is broken")),b|=g<<e,e+=8;g=b&(1<<c)-1;a.g=b>>>c;a.e=e-c;a.c=d;return g}
function mb(a,c){for(var b=a.g,e=a.e,f=a.input,d=a.c,g=c[0],h=c[1],m,j,s;e<h;)m=f[d++],m===r&&i(Error("input buffer is broken")),b|=m<<e,e+=8;j=g[b&(1<<h)-1];s=j>>>16;a.g=b>>s;a.e=e-s;a.c=d;return j&65535}
function Ka(a){function c(a,b,c){var d,e,f,g;for(g=0;g<a;)switch(d=mb(this,b),d){case 16:for(f=3+X(this,2);f--;)c[g++]=e;break;case 17:for(f=3+X(this,3);f--;)c[g++]=0;e=0;break;case 18:for(f=11+X(this,7);f--;)c[g++]=0;e=0;break;default:e=c[g++]=d}return c}var b=X(a,5)+257,e=X(a,5)+1,f=X(a,4)+4,d=new (H?Uint8Array:Array)(Za.length),g,h,m,j;for(j=0;j<f;++j)d[Za[j]]=X(a,3);g=S(d);h=new (H?Uint8Array:Array)(b);m=new (H?Uint8Array:Array)(e);a.o(S(c.call(a,b,g,h)),S(c.call(a,e,g,m)))}
V.prototype.o=function(a,c){var b=this.a,e=this.b;this.u=a;for(var f=b.length-258,d,g,h,m;256!==(d=mb(this,a));)if(256>d)e>=f&&(this.b=e,b=this.f(),e=this.b),b[e++]=d;else{g=d-257;m=ab[g];0<cb[g]&&(m+=X(this,cb[g]));d=mb(this,c);h=eb[d];0<gb[d]&&(h+=X(this,gb[d]));e>=f&&(this.b=e,b=this.f(),e=this.b);for(;m--;)b[e]=b[e++-h]}for(;8<=this.e;)this.e-=8,this.c--;this.b=e};
V.prototype.I=function(a,c){var b=this.a,e=this.b;this.u=a;for(var f=b.length,d,g,h,m;256!==(d=mb(this,a));)if(256>d)e>=f&&(b=this.f(),f=b.length),b[e++]=d;else{g=d-257;m=ab[g];0<cb[g]&&(m+=X(this,cb[g]));d=mb(this,c);h=eb[d];0<gb[d]&&(h+=X(this,gb[d]));e+m>f&&(b=this.f(),f=b.length);for(;m--;)b[e]=b[e++-h]}for(;8<=this.e;)this.e-=8,this.c--;this.b=e};
V.prototype.f=function(){var a=new (H?Uint8Array:Array)(this.b-32768),c=this.b-32768,b,e,f=this.a;if(H)a.set(f.subarray(32768,a.length));else{b=0;for(e=a.length;b<e;++b)a[b]=f[b+32768]}this.k.push(a);this.q+=a.length;if(H)f.set(f.subarray(c,c+32768));else for(b=0;32768>b;++b)f[b]=f[c+b];this.b=32768;return f};
V.prototype.J=function(a){var c,b=this.input.length/this.c+1|0,e,f,d,g=this.input,h=this.a;a&&("number"===typeof a.v&&(b=a.v),"number"===typeof a.F&&(b+=a.F));2>b?(e=(g.length-this.c)/this.u[2],d=258*(e/2)|0,f=d<h.length?h.length+d:h.length<<1):f=h.length*b;H?(c=new Uint8Array(f),c.set(h)):c=h;return this.a=c};
V.prototype.t=function(){var a=0,c=this.a,b=this.k,e,f=new (H?Uint8Array:Array)(this.q+(this.b-32768)),d,g,h,m;if(0===b.length)return H?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);d=0;for(g=b.length;d<g;++d){e=b[d];h=0;for(m=e.length;h<m;++h)f[a++]=e[h]}d=32768;for(g=this.b;d<g;++d)f[a++]=c[d];this.k=[];return this.buffer=f};
V.prototype.H=function(){var a,c=this.b;H?this.B?(a=new Uint8Array(c),a.set(this.a.subarray(0,c))):a=this.a.subarray(0,c):(this.a.length>c&&(this.a.length=c),a=this.a);return this.buffer=a};function nb(a,c){var b,e;this.input=a;this.c=0;if(c||!(c={}))c.index&&(this.c=c.index),c.verify&&(this.M=c.verify);b=a[this.c++];e=a[this.c++];switch(b&15){case Ea:this.method=Ea;break;default:i(Error("unsupported compression method"))}0!==((b<<8)+e)%31&&i(Error("invalid fcheck flag:"+((b<<8)+e)%31));e&32&&i(Error("fdict flag is not supported"));this.A=new V(a,{index:this.c,bufferSize:c.bufferSize,bufferType:c.bufferType,resize:c.resize})}
nb.prototype.p=function(){var a=this.input,c,b;c=this.A.p();this.c=this.A.c;this.M&&(b=(a[this.c++]<<24|a[this.c++]<<16|a[this.c++]<<8|a[this.c++])>>>0,b!==ba(c)&&i(Error("invalid adler-32 checksum")));return c};y("Zlib.Inflate",nb);y("Zlib.Inflate.BufferType",Ha);Ha.ADAPTIVE=Ha.C;Ha.BLOCK=Ha.D;y("Zlib.Inflate.prototype.decompress",nb.prototype.p);var ob=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];H&&new Uint16Array(ob);var pb=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258];H&&new Uint16Array(pb);var qb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0];H&&new Uint8Array(qb);var rb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];H&&new Uint16Array(rb);
var sb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];H&&new Uint8Array(sb);var tb=new (H?Uint8Array:Array)(288),Z,ub;Z=0;for(ub=tb.length;Z<ub;++Z)tb[Z]=143>=Z?8:255>=Z?9:279>=Z?7:8;S(tb);var vb=new (H?Uint8Array:Array)(30),wb,xb;wb=0;for(xb=vb.length;wb<xb;++wb)vb[wb]=5;S(vb);var Ea=8;}).call(this);

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.XML
    * @classdesc
    * XML文件解析工具，它将XML文件解析为标准的JSON对象返回。
    * 用法类似JSON.parse(),传入一个XML字符串给XML.parse()，将能得到一个标准JSON对象。
    * 示例：<root value="abc">
    *          <item value="item0"/>
    *          <item value="item1"/>
    *       </root>
    * 将解析为:
    * {"name":"root","$value":"abc","children":[{"name":"item","$value":"item0"},{"name":"item","$value":"item0"}]};
    *
    * 其中XML上的属性节点都使用$+"属性名"的方式表示,子节点都存放在children属性的列表里，name表示节点名称。
    */
    var XML = (function () {
        function XML() {
        }
        /**
        * 解析一个XML字符串为JSON对象。
        * @method egret.XML.parse
        * @param value {string} 要解析的XML字符串。
        * @returns {any} XML对应的JSON对象。
        */
        XML.parse = function (value) {
            var xmlDoc = egret.SAXParser.getInstance().parserXML(value);
            if (!xmlDoc || !xmlDoc.childNodes) {
                return null;
            }
            var length = xmlDoc.childNodes.length;
            var found = false;
            for (var i = 0; i < length; i++) {
                var node = xmlDoc.childNodes[i];
                if (node.nodeType == 1) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return null;
            }
            var xml = XML.parseNode(node);
            return xml;
        };

        XML.parseNode = function (node) {
            if (!node || node.nodeType != 1) {
                return null;
            }
            var xml = {};
            xml.localName = node.localName;
            xml.name = node.nodeName;
            if (node.namespaceURI)
                xml.namespace = node.namespaceURI;
            if (node.prefix)
                xml.prefix = node.prefix;
            var attributes = node.attributes;
            var length = attributes.length;
            for (var i = 0; i < length; i++) {
                var attrib = attributes[i];
                var key = attrib.name;
                if (key.indexOf("xmlns:") == 0) {
                    continue;
                }
                xml["$" + key] = attrib.value;
            }
            var children = node.childNodes;
            length = children.length;
            for (i = 0; i < length; i++) {
                var childNode = children[i];
                var childXML = XML.parseNode(childNode);
                if (childXML) {
                    if (!xml.children) {
                        xml.children = [];
                    }
                    childXML.parent = xml;
                    xml.children.push(childXML);
                }
            }
            if (!xml.children) {
                var text = node.textContent.trim();
                if (text) {
                    xml.text = text;
                }
            }
            return xml;
        };

        /**
        * 查找xml上符合节点路径的所有子节点。
        * @method egret.XML.findChildren
        * @param xml {any} 要查找的XML节点。
        * @param path {string} 子节点路径，例如"item.node"
        * @param result {Array<any>} 可选参数，传入一个数组用于存储查找的结果。这样做能避免重复创建对象。
        * @returns {any} 返回所有符合path路径的xml上的子孙节点列表
        */
        XML.findChildren = function (xml, path, result) {
            if (!result) {
                result = [];
            } else {
                result.length = 0;
            }
            XML.findByPath(xml, path, result);
            return result;
        };

        XML.findByPath = function (xml, path, result) {
            var index = path.indexOf(".");
            var key;
            var end;
            if (index == -1) {
                key = path;
                end = true;
            } else {
                key = path.substring(0, index);
                path = path.substring(index + 1);
                end = false;
            }
            var children = xml.children;
            if (!children) {
                return;
            }
            var length = children.length;
            for (var i = 0; i < length; i++) {
                var child = children[i];
                if (child.localName == key) {
                    if (end) {
                        result.push(child);
                    } else {
                        XML.findByPath(child, path, result);
                    }
                }
            }
        };

        /**
        * 获取一个XML节点上的所有属性名列表
        * @method egret.XML.getAttributes
        * @param xml {any} 要查找的XML节点。
        * @param result {Array<any>} 可选参数，传入一个数组用于存储查找的结果。这样做能避免重复创建对象。
        * @returns {any} 返回xml上的属性名列表,不包含"$"前缀。
        */
        XML.getAttributes = function (xml, result) {
            if (!result) {
                result = [];
            } else {
                result.length = 0;
            }
            for (var key in xml) {
                if (key.charAt(0) == "$") {
                    result.push(key.substring(1));
                }
            }
            return result;
        };
        return XML;
    })();
    egret.XML = XML;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var Tween = (function (_super) {
        __extends(Tween, _super);
        function Tween(target, props, pluginData) {
            _super.call(this);
            this._target = null;
            this._useTicks = false;
            this.ignoreGlobalPause = false;
            this.loop = false;
            this.pluginData = null;
            this._steps = null;
            this._actions = null;
            this.paused = false;
            this.duration = 0;
            this._prevPos = -1;
            this.position = null;
            this._prevPosition = 0;
            this._stepPosition = 0;
            this.passive = false;
            this.initialize(target, props, pluginData);
        }
        Tween.get = function (target, props, pluginData, override) {
            if (typeof props === "undefined") { props = null; }
            if (typeof pluginData === "undefined") { pluginData = null; }
            if (typeof override === "undefined") { override = false; }
            if (override) {
                Tween.removeTweens(target);
            }
            return new Tween(target, props, pluginData);
        };

        Tween.removeTweens = function (target) {
            if (!target.tween_count) {
                return;
            }
            var tweens = Tween._tweens;
            for (var i = tweens.length - 1; i >= 0; i--) {
                if (tweens[i]._target == target) {
                    tweens[i].paused = true;
                    tweens.splice(i, 1);
                }
            }
            target.tween_count = 0;
        };

        Tween.tick = function (delta, paused) {
            if (typeof paused === "undefined") { paused = false; }
            var tweens = Tween._tweens.concat();
            for (var i = tweens.length - 1; i >= 0; i--) {
                var tween = tweens[i];
                if ((paused && !tween.ignoreGlobalPause) || tween.paused) {
                    continue;
                }
                tween.tick(tween._useTicks ? 1 : delta);
            }
        };

        Tween._register = function (tween, value) {
            var target = tween._target;
            var tweens = Tween._tweens;
            if (value) {
                if (target) {
                    target.tween_count = target.tween_count ? target.tween_count + 1 : 1;
                }
                tweens.push(tween);
                if (!Tween._inited) {
                    egret.Ticker.getInstance().register(Tween.tick, null);
                    Tween._inited = true;
                }
            } else {
                if (target) {
                    target.tween_count--;
                }
                var i = tweens.length;
                while (i--) {
                    if (tweens[i] == tween) {
                        tweens.splice(i, 1);
                        return;
                    }
                }
            }
        };

        Tween.removeAllTweens = function () {
            var tweens = Tween._tweens;
            for (var i = 0, l = tweens.length; i < l; i++) {
                var tween = tweens[i];
                tween.paused = true;
                tween._target.tweenjs_count = 0;
            }
            tweens.length = 0;
        };

        Tween.prototype.initialize = function (target, props, pluginData) {
            this._target = target;
            if (props) {
                this._useTicks = props.useTicks;
                this.ignoreGlobalPause = props.ignoreGlobalPause;
                this.loop = props.loop;
                props.onChange && this.addEventListener("change", props.onChange, props.onChangeObj);
                if (props.override) {
                    Tween.removeTweens(target);
                }
            }

            this.pluginData = pluginData || {};
            this._curQueueProps = {};
            this._initQueueProps = {};
            this._steps = [];
            this._actions = [];
            if (props && props.paused) {
                this.paused = true;
            } else {
                Tween._register(this, true);
            }
            if (props && props.position != null) {
                this.setPosition(props.position, Tween.NONE);
            }
        };

        Tween.prototype.setPosition = function (value, actionsMode) {
            if (typeof actionsMode === "undefined") { actionsMode = 1; }
            if (value < 0) {
                value = 0;
            }

            //正常化位置
            var t = value;
            var end = false;
            if (t >= this.duration) {
                if (this.loop) {
                    t = t % this.duration;
                } else {
                    t = this.duration;
                    end = true;
                }
            }
            if (t == this._prevPos) {
                return end;
            }

            var prevPos = this._prevPos;
            this.position = this._prevPos = t;
            this._prevPosition = value;

            if (this._target) {
                if (end) {
                    //结束
                    this._updateTargetProps(null, 1);
                } else if (this._steps.length > 0) {
                    for (var i = 0, l = this._steps.length; i < l; i++) {
                        if (this._steps[i].t > t) {
                            break;
                        }
                    }
                    var step = this._steps[i - 1];
                    this._updateTargetProps(step, (this._stepPosition = t - step.t) / step.d);
                }
            }

            //执行actions
            if (actionsMode != 0 && this._actions.length > 0) {
                if (this._useTicks) {
                    this._runActions(t, t);
                } else if (actionsMode == 1 && t < prevPos) {
                    if (prevPos != this.duration) {
                        this._runActions(prevPos, this.duration);
                    }
                    this._runActions(0, t, true);
                } else {
                    this._runActions(prevPos, t);
                }
            }

            if (end) {
                this.setPaused(true);
            }

            this.dispatchEventWith("change");
            return end;
        };

        Tween.prototype._runActions = function (startPos, endPos, includeStart) {
            if (typeof includeStart === "undefined") { includeStart = false; }
            var sPos = startPos;
            var ePos = endPos;
            var i = -1;
            var j = this._actions.length;
            var k = 1;
            if (startPos > endPos) {
                //把所有的倒置
                sPos = endPos;
                ePos = startPos;
                i = j;
                j = k = -1;
            }
            while ((i += k) != j) {
                var action = this._actions[i];
                var pos = action.t;
                if (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos)) {
                    action.f.apply(action.o, action.p);
                }
            }
        };

        Tween.prototype._updateTargetProps = function (step, ratio) {
            var p0, p1, v, v0, v1, arr;
            if (!step && ratio == 1) {
                this.passive = false;
                p0 = p1 = this._curQueueProps;
            } else {
                this.passive = !!step.v;

                //不更新props.
                if (this.passive) {
                    return;
                }

                //使用ease
                if (step.e) {
                    ratio = step.e(ratio, 0, 1, 1);
                }
                p0 = step.p0;
                p1 = step.p1;
            }

            for (var n in this._initQueueProps) {
                if ((v0 = p0[n]) == null) {
                    p0[n] = v0 = this._initQueueProps[n];
                }
                if ((v1 = p1[n]) == null) {
                    p1[n] = v1 = v0;
                }
                if (v0 == v1 || ratio == 0 || ratio == 1 || (typeof (v0) != "number")) {
                    v = ratio == 1 ? v1 : v0;
                } else {
                    v = v0 + (v1 - v0) * ratio;
                }

                var ignore = false;
                if (arr = Tween._plugins[n]) {
                    for (var i = 0, l = arr.length; i < l; i++) {
                        var v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step && p0 == p1, !step);
                        if (v2 == Tween.IGNORE) {
                            ignore = true;
                        } else {
                            v = v2;
                        }
                    }
                }
                if (!ignore) {
                    this._target[n] = v;
                }
            }
        };

        Tween.prototype.setPaused = function (value) {
            this.paused = value;
            Tween._register(this, !value);
            return this;
        };

        Tween.prototype._cloneProps = function (props) {
            var o = {};
            for (var n in props) {
                o[n] = props[n];
            }
            return o;
        };

        Tween.prototype._addStep = function (o) {
            if (o.d > 0) {
                this._steps.push(o);
                o.t = this.duration;
                this.duration += o.d;
            }
            return this;
        };

        Tween.prototype._appendQueueProps = function (o) {
            var arr, oldValue, i, l, injectProps;
            for (var n in o) {
                if (this._initQueueProps[n] === undefined) {
                    oldValue = this._target[n];

                    //设置plugins
                    if (arr = Tween._plugins[n]) {
                        for (i = 0, l = arr.length; i < l; i++) {
                            oldValue = arr[i].init(this, n, oldValue);
                        }
                    }
                    this._initQueueProps[n] = this._curQueueProps[n] = (oldValue === undefined) ? null : oldValue;
                } else {
                    oldValue = this._curQueueProps[n];
                }
            }

            for (var n in o) {
                oldValue = this._curQueueProps[n];
                if (arr = Tween._plugins[n]) {
                    injectProps = injectProps || {};
                    for (i = 0, l = arr.length; i < l; i++) {
                        if (arr[i].step) {
                            arr[i].step(this, n, oldValue, o[n], injectProps);
                        }
                    }
                }
                this._curQueueProps[n] = o[n];
            }
            if (injectProps) {
                this._appendQueueProps(injectProps);
            }
            return this._curQueueProps;
        };

        Tween.prototype._addAction = function (o) {
            o.t = this.duration;
            this._actions.push(o);
            return this;
        };

        Tween.prototype._set = function (props, o) {
            for (var n in props) {
                o[n] = props[n];
            }
        };

        Tween.prototype.wait = function (duration, passive) {
            if (typeof passive === "undefined") { passive = false; }
            if (duration == null || duration <= 0) {
                return this;
            }
            var o = this._cloneProps(this._curQueueProps);
            return this._addStep({ d: duration, p0: o, p1: o, v: passive });
        };

        Tween.prototype.to = function (props, duration, ease) {
            if (typeof ease === "undefined") { ease = undefined; }
            if (isNaN(duration) || duration < 0) {
                duration = 0;
            }
            return this._addStep({ d: duration || 0, p0: this._cloneProps(this._curQueueProps), e: ease, p1: this._cloneProps(this._appendQueueProps(props)) });
        };

        Tween.prototype.call = function (callback, thisObj, params) {
            if (typeof thisObj === "undefined") { thisObj = undefined; }
            if (typeof params === "undefined") { params = undefined; }
            return this._addAction({ f: callback, p: params ? params : [this], o: thisObj ? thisObj : this._target });
        };

        Tween.prototype.set = function (props, target) {
            if (typeof target === "undefined") { target = null; }
            return this._addAction({ f: this._set, o: this, p: [props, target ? target : this._target] });
        };

        Tween.prototype.play = function (tween) {
            if (!tween) {
                tween = this;
            }
            return this.call(tween.setPaused, [false], tween);
        };

        Tween.prototype.pause = function (tween) {
            if (!tween) {
                tween = this;
            }
            return this.call(tween.setPaused, [true], tween);
        };

        Tween.prototype.tick = function (delta) {
            if (this.paused) {
                return;
            }
            this.setPosition(this._prevPosition + delta);
        };
        Tween.NONE = 0;
        Tween.LOOP = 1;
        Tween.REVERSE = 2;

        Tween._tweens = [];
        Tween.IGNORE = {};
        Tween._plugins = {};
        Tween._inited = false;
        return Tween;
    })(egret.EventDispatcher);
    egret.Tween = Tween;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var Ease = (function () {
        function Ease() {
            egret.Logger.fatal("Ease不能被实例化");
        }
        Ease.get = function (amount) {
            if (amount < -1) {
                amount = -1;
            }
            if (amount > 1) {
                amount = 1;
            }
            return function (t) {
                if (amount == 0) {
                    return t;
                }
                if (amount < 0) {
                    return t * (t * -amount + 1 + amount);
                }
                return t * ((2 - t) * amount + (1 - amount));
            };
        };

        Ease.getPowIn = function (pow) {
            return function (t) {
                return Math.pow(t, pow);
            };
        };

        Ease.getPowOut = function (pow) {
            return function (t) {
                return 1 - Math.pow(1 - t, pow);
            };
        };

        Ease.getPowInOut = function (pow) {
            return function (t) {
                if ((t *= 2) < 1)
                    return 0.5 * Math.pow(t, pow);
                return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
            };
        };

        Ease.sineIn = function (t) {
            return 1 - Math.cos(t * Math.PI / 2);
        };

        Ease.sineOut = function (t) {
            return Math.sin(t * Math.PI / 2);
        };

        Ease.sineInOut = function (t) {
            return -0.5 * (Math.cos(Math.PI * t) - 1);
        };

        Ease.getBackIn = function (amount) {
            return function (t) {
                return t * t * ((amount + 1) * t - amount);
            };
        };

        Ease.getBackOut = function (amount) {
            return function (t) {
                t = t - 1;
                return (t * t * ((amount + 1) * t + amount) + 1);
            };
        };

        Ease.getBackInOut = function (amount) {
            amount *= 1.525;
            return function (t) {
                if ((t *= 2) < 1)
                    return 0.5 * (t * t * ((amount + 1) * t - amount));
                return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
            };
        };

        Ease.circIn = function (t) {
            return -(Math.sqrt(1 - t * t) - 1);
        };

        Ease.circOut = function (t) {
            return Math.sqrt(1 - (t) * t);
        };

        Ease.circInOut = function (t) {
            if ((t *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - t * t) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        };

        Ease.bounceIn = function (t) {
            return 1 - Ease.bounceOut(1 - t);
        };

        Ease.bounceOut = function (t) {
            if (t < 1 / 2.75) {
                return (7.5625 * t * t);
            } else if (t < 2 / 2.75) {
                return (7.5625 * (t -= 1.5 / 2.75) * t + 0.75);
            } else if (t < 2.5 / 2.75) {
                return (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375);
            } else {
                return (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375);
            }
        };

        Ease.bounceInOut = function (t) {
            if (t < 0.5)
                return Ease.bounceIn(t * 2) * .5;
            return Ease.bounceOut(t * 2 - 1) * 0.5 + 0.5;
        };

        Ease.getElasticIn = function (amplitude, period) {
            var pi2 = Math.PI * 2;
            return function (t) {
                if (t == 0 || t == 1)
                    return t;
                var s = period / pi2 * Math.asin(1 / amplitude);
                return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
            };
        };

        Ease.getElasticOut = function (amplitude, period) {
            var pi2 = Math.PI * 2;
            return function (t) {
                if (t == 0 || t == 1)
                    return t;
                var s = period / pi2 * Math.asin(1 / amplitude);
                return (amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1);
            };
        };

        Ease.getElasticInOut = function (amplitude, period) {
            var pi2 = Math.PI * 2;
            return function (t) {
                var s = period / pi2 * Math.asin(1 / amplitude);
                if ((t *= 2) < 1)
                    return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
                return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * 0.5 + 1;
            };
        };
        Ease.quadIn = Ease.getPowIn(2);
        Ease.quadOut = Ease.getPowOut(2);
        Ease.quadInOut = Ease.getPowInOut(2);
        Ease.cubicIn = Ease.getPowIn(3);
        Ease.cubicOut = Ease.getPowOut(3);
        Ease.cubicInOut = Ease.getPowInOut(3);
        Ease.quartIn = Ease.getPowIn(4);
        Ease.quartOut = Ease.getPowOut(4);
        Ease.quartInOut = Ease.getPowInOut(4);
        Ease.quintIn = Ease.getPowIn(5);
        Ease.quintOut = Ease.getPowOut(5);
        Ease.quintInOut = Ease.getPowInOut(5);

        Ease.backIn = Ease.getBackIn(1.7);

        Ease.backOut = Ease.getBackOut(1.7);

        Ease.backInOut = Ease.getBackInOut(1.7);

        Ease.elasticIn = Ease.getElasticIn(1, 0.3);

        Ease.elasticOut = Ease.getElasticOut(1, 0.3);

        Ease.elasticInOut = Ease.getElasticInOut(1, 0.3 * 1.5);
        return Ease;
    })();
    egret.Ease = Ease;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.Sound
    * @classdesc Sound 类允许您在应用程序中使用声音。
    */
    var Sound = (function () {
        function Sound() {
        }
        /**
        * 播放声音
        * @method egret.Sound#play
        * @param loop {boolean} 是否循环播放，默认为false
        */
        Sound.prototype.play = function (loop) {
            if (typeof loop === "undefined") { loop = false; }
            var sound = this.audio;
            if (!sound) {
                return;
            }
            if (!isNaN(sound.duration)) {
                sound.currentTime = 0;
            }
            sound.loop = loop;
            sound.play();
        };

        /**
        * 暂停声音
        * @method egret.Sound#pause
        */
        Sound.prototype.pause = function () {
            var sound = this.audio;
            if (!sound) {
                return;
            }
            sound.pause();
        };

        /**
        * 重新加载声音
        * @method egret.Sound#load
        */
        Sound.prototype.load = function () {
            var sound = this.audio;
            if (!sound) {
                return;
            }
            sound.load();
        };

        /**
        * 添加事件监听
        * @param type 事件类型
        * @param listener 监听函数
        */
        Sound.prototype.addEventListener = function (type, listener) {
            var sound = this.audio;
            if (!sound) {
                return;
            }
            this.audio.addEventListener(type, listener, false);
        };

        /**
        * 移除事件监听
        * @param type 事件类型
        * @param listener 监听函数
        */
        Sound.prototype.removeEventListener = function (type, listener) {
            var sound = this.audio;
            if (!sound) {
                return;
            }
            this.audio.removeEventListener(type, listener, false);
        };

        /**
        * 设置音量
        * @param value 值需大于0 小于等于 1
        */
        Sound.prototype.setVolume = function (value) {
            var sound = this.audio;
            if (!sound) {
                return;
            }
            sound.volume = value;
        };

        /**
        * 获取当前音量值
        * @returns number
        */
        Sound.prototype.getVolume = function () {
            return this.audio ? this.audio.volume : 0;
        };
        return Sound;
    })();
    egret.Sound = Sound;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ArrayCollection
    * @classdesc
    * 数组的集合类数据结构包装器
    * 通常作为列表组件的数据源，使用这种数据结构包装普通数组，
    * 能在数据源发生改变的时候主动通知视图刷新变更的数据项
    * @extends egret.EventDispatcher
    * @implements egret.ICollection
    */
    var ArrayCollection = (function (_super) {
        __extends(ArrayCollection, _super);
        /**
        * 构造函数
        * @method egret.ArrayCollection#constructor
        * @param source {Array<any>} 数据源
        */
        function ArrayCollection(source) {
            if (typeof source === "undefined") { source = null; }
            _super.call(this);
            if (source) {
                this._source = source;
            } else {
                this._source = [];
            }
        }
        Object.defineProperty(ArrayCollection.prototype, "source", {
            /**
            * 数据源
            * 通常情况下请不要直接调用Array的方法操作数据源，否则对应的视图无法收到数据改变的通知。
            * 若对数据源进行了排序或过滤等操作，请手动调用refresh()方法刷新数据。<br/>
            * @member egret.ArrayCollection#source
            */
            get: function () {
                return this._source;
            },
            set: function (value) {
                if (!value)
                    value = [];
                this._source = value;
                this.dispatchCoEvent(egret.CollectionEventKind.RESET);
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 在对数据源进行排序或过滤操作后可以手动调用此方法刷新所有数据,以更新视图。
        * @method egret.ArrayCollection#refresh
        */
        ArrayCollection.prototype.refresh = function () {
            this.dispatchCoEvent(egret.CollectionEventKind.REFRESH);
        };

        /**
        * 是否包含某项数据
        * @method egret.ArrayCollection#contains
        * @param item {any}
        * @returns {boolean}
        */
        ArrayCollection.prototype.contains = function (item) {
            return this.getItemIndex(item) != -1;
        };

        /**
        * 检测索引是否超出范围
        */
        ArrayCollection.prototype.checkIndex = function (index) {
            if (index < 0 || index >= this._source.length) {
                throw new RangeError("索引:\"" + index + "\"超出集合元素索引范围");
            }
        };

        Object.defineProperty(ArrayCollection.prototype, "length", {
            //--------------------------------------------------------------------------
            //
            // ICollection接口实现方法
            //
            //--------------------------------------------------------------------------
            /**
            * @member egret.ArrayCollection#length
            */
            get: function () {
                return this._source.length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 向列表末尾添加指定项目。等效于 addItemAt(item, length)。
        * @method egret.ArrayCollection#addItem
        * @param item {any}
        */
        ArrayCollection.prototype.addItem = function (item) {
            this._source.push(item);
            this.dispatchCoEvent(egret.CollectionEventKind.ADD, this._source.length - 1, -1, [item]);
        };

        /**
        * 在指定的索引处添加项目。
        * 任何大于已添加项目的索引的项目索引都会增加 1。
        * @method egret.ArrayCollection#addItemAt
        * @throws RangeError 如果索引小于 0 或大于长度。
        * @param item {any}
        * @param index {number}
        */
        ArrayCollection.prototype.addItemAt = function (item, index) {
            if (index < 0 || index > this._source.length) {
                throw new RangeError("索引:\"" + index + "\"超出集合元素索引范围");
            }
            this._source.splice(index, 0, item);
            this.dispatchCoEvent(egret.CollectionEventKind.ADD, index, -1, [item]);
        };

        /**
        * @method egret.ArrayCollection#getItemAt
        * @param index {number}
        * @returns {any}
        */
        ArrayCollection.prototype.getItemAt = function (index) {
            return this._source[index];
        };

        /**
        * @method egret.ArrayCollection#getItemIndex
        * @param item {any}
        * @returns {number}
        */
        ArrayCollection.prototype.getItemIndex = function (item) {
            var length = this._source.length;
            for (var i = 0; i < length; i++) {
                if (this._source[i] === item) {
                    return i;
                }
            }
            return -1;
        };

        /**
        * 通知视图，某个项目的属性已更新。
        * @method egret.ArrayCollection#itemUpdated
        * @param item {any}
        */
        ArrayCollection.prototype.itemUpdated = function (item) {
            var index = this.getItemIndex(item);
            if (index != -1) {
                this.dispatchCoEvent(egret.CollectionEventKind.UPDATE, index, -1, [item]);
            }
        };

        /**
        * 删除列表中的所有项目。
        * @method egret.ArrayCollection#removeAll
        */
        ArrayCollection.prototype.removeAll = function () {
            var items = this._source.concat();
            this._source.length = 0;
            this.dispatchCoEvent(egret.CollectionEventKind.REMOVE, 0, -1, items);
        };

        /**
        * 删除指定索引处的项目并返回该项目。原先位于此索引之后的所有项目的索引现在都向前移动一个位置。
        * @method egret.ArrayCollection#removeItemAt
        * @throws RangeError 如果索引小于 0 或大于长度。
        * @param index {number}
        * @returns {any}
        */
        ArrayCollection.prototype.removeItemAt = function (index) {
            this.checkIndex(index);
            var item = this._source.splice(index, 1)[0];
            this.dispatchCoEvent(egret.CollectionEventKind.REMOVE, index, -1, [item]);
            return item;
        };

        /**
        * 替换在指定索引处的项目，并返回该项目。
        * @method egret.ArrayCollection#replaceItemAt
        * @throws RangeError 如果索引小于 0 或大于长度。
        * @param item {any}
        * @param index {number}
        * @returns {any}
        */
        ArrayCollection.prototype.replaceItemAt = function (item, index) {
            this.checkIndex(index);
            var oldItem = this._source.splice(index, 1, item)[0];
            this.dispatchCoEvent(egret.CollectionEventKind.REPLACE, index, -1, [item], [oldItem]);
            return oldItem;
        };

        /**
        * 用新数据源替换原始数据源，此方法与直接设置source不同，它不会导致目标视图重置滚动位置。
        * @method egret.ArrayCollection#replaceAll
        * @param newSource {Array<any>} 新的数据源
        */
        ArrayCollection.prototype.replaceAll = function (newSource) {
            if (!newSource)
                newSource = [];
            var newLength = newSource.length;
            var oldLenght = this._source.length;
            for (var i = newLength; i < oldLenght; i++) {
                this.removeItemAt(newLength);
            }
            for (i = 0; i < newLength; i++) {
                if (i >= oldLenght)
                    this.addItemAt(newSource[i], i);
                else
                    this.replaceItemAt(newSource[i], i);
            }
            this._source = newSource;
        };

        /**
        * 移动一个项目
        * 在oldIndex和newIndex之间的项目，
        * 若oldIndex小于newIndex,索引会减1
        * 若oldIndex大于newIndex,索引会加1
        * @method egret.ArrayCollection#moveItemAt
        * @param oldIndex {number}
        * @param newIndex {number}
        * @returns {any}
        * @throws RangeError 如果索引小于 0 或大于长度。
        */
        ArrayCollection.prototype.moveItemAt = function (oldIndex, newIndex) {
            this.checkIndex(oldIndex);
            this.checkIndex(newIndex);
            var item = this._source.splice(oldIndex, 1)[0];
            this._source.splice(newIndex, 0, item);
            this.dispatchCoEvent(egret.CollectionEventKind.MOVE, newIndex, oldIndex, [item]);
            return item;
        };

        /**
        * 抛出事件
        */
        ArrayCollection.prototype.dispatchCoEvent = function (kind, location, oldLocation, items, oldItems) {
            if (typeof kind === "undefined") { kind = null; }
            if (typeof location === "undefined") { location = -1; }
            if (typeof oldLocation === "undefined") { oldLocation = -1; }
            if (typeof items === "undefined") { items = null; }
            if (typeof oldItems === "undefined") { oldItems = null; }
            egret.CollectionEvent.dispatchCollectionEvent(this, egret.CollectionEvent.COLLECTION_CHANGE, kind, location, oldLocation, items, oldItems);
        };
        return ArrayCollection;
    })(egret.EventDispatcher);
    egret.ArrayCollection = ArrayCollection;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ObjectCollection
    * @classdesc
    * Object的集合类数据结构包装器,通常作为Tree组件的数据源。
    * @extends egret.EventDispatcher
    * @implements egret.ICollection
    * @implements egret.ITreeCollection
    */
    var ObjectCollection = (function (_super) {
        __extends(ObjectCollection, _super);
        /**
        * 构造函数
        * @method egret.ObjectCollection#constructor
        * @param childrenKey {string} 要从item中获取子项列表的属性名,属性值为一个数组或Vector。
        * @param parentKey {string} 要从item中获取父级项的属性名
        */
        function ObjectCollection(childrenKey, parentKey) {
            if (typeof childrenKey === "undefined") { childrenKey = "children"; }
            if (typeof parentKey === "undefined") { parentKey = "parent"; }
            _super.call(this);
            /**
            * 要显示的节点列表
            */
            this.nodeList = [];
            this._openNodes = [];
            this._showRoot = false;
            this.childrenKey = childrenKey;
            this.parentKey = parentKey;
        }
        Object.defineProperty(ObjectCollection.prototype, "source", {
            /**
            * 数据源。注意：设置source会同时清空openNodes。
            * @member egret.ObjectCollection#source
            */
            get: function () {
                return this._source;
            },
            set: function (value) {
                this._source = value;
                this._openNodes = [];
                this.nodeList = [];
                if (this._source) {
                    if (this._showRoot) {
                        this.nodeList.push(this._source);
                    } else {
                        this._openNodes = [this._source];
                        this.addChildren(this._source, this.nodeList);
                    }
                }
                this.dispatchCoEvent(egret.CollectionEventKind.RESET);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ObjectCollection.prototype, "openNodes", {
            /**
            * 处于展开状态的节点列表
            * @member egret.ObjectCollection#openNodes
            */
            get: function () {
                return this._openNodes.concat();
            },
            set: function (value) {
                this._openNodes = value ? value.concat() : [];
                this.refresh();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(ObjectCollection.prototype, "length", {
            /**
            * @member egret.ObjectCollection#length
            */
            get: function () {
                return this.nodeList.length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.ObjectCollection#getItemAt
        * @param index {number}
        * @returns {any}
        */
        ObjectCollection.prototype.getItemAt = function (index) {
            return this.nodeList[index];
        };

        /**
        * @method egret.ObjectCollection#getItemIndex
        * @param item {any}
        * @returns {number}
        */
        ObjectCollection.prototype.getItemIndex = function (item) {
            var length = this.nodeList.length;
            for (var i = 0; i < length; i++) {
                if (this.nodeList[i] === item) {
                    return i;
                }
            }
            return -1;
        };

        /**
        * 通知视图，某个项目的属性已更新。
        * @method egret.ObjectCollection#itemUpdated
        * @param item {any}
        */
        ObjectCollection.prototype.itemUpdated = function (item) {
            var index = this.getItemIndex(item);
            if (index != -1) {
                this.dispatchCoEvent(egret.CollectionEventKind.UPDATE, index, -1, [item]);
            }
        };

        /**
        * 删除指定节点
        * @method egret.ObjectCollection#removeItem
        * @param item {any}
        */
        ObjectCollection.prototype.removeItem = function (item) {
            if (this.isItemOpen(item))
                this.closeNode(item);
            if (!item)
                return;
            var parent = item[this.parentKey];
            if (!parent)
                return;
            var list = parent[this.childrenKey];
            if (!list)
                return;
            var index = list.indexOf(item);
            if (index != -1)
                list.splice(index, 1);
            item[this.parentKey] = null;
            index = this.nodeList.indexOf(item);
            if (index != -1) {
                this.nodeList.splice(index, 1);
                this.dispatchCoEvent(egret.CollectionEventKind.REMOVE, index, -1, [item]);
            }
        };

        Object.defineProperty(ObjectCollection.prototype, "showRoot", {
            /**
            * 是否显示根节点,默认false。
            * @member egret.ObjectCollection#showRoot
            */
            get: function () {
                return this._showRoot;
            },
            set: function (value) {
                if (this._showRoot == value)
                    return;
                this._showRoot = value;
                if (this._source) {
                    if (this._showRoot) {
                        this.nodeList.splice(0, 0, this._source);
                    } else {
                        this.nodeList.shift();
                        if (this.openNodes.indexOf(this._source) == -1)
                            this.openNodes.push(this._source);
                    }
                    this.refresh();
                }
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 添加打开的节点到列表
        */
        ObjectCollection.prototype.addChildren = function (parent, list) {
            if (!parent.hasOwnProperty(this.childrenKey) || this._openNodes.indexOf(parent) == -1)
                return;
            var children = parent[this.childrenKey];
            var length = children.length;
            for (var i = 0; i < length; i++) {
                var child = children[i];
                list.push(child);
                this.addChildren(child, list);
            }
        };

        /**
        * @method egret.ObjectCollection#hasChildren
        * @param item {any}
        * @returns {boolean}
        */
        ObjectCollection.prototype.hasChildren = function (item) {
            if (item.hasOwnProperty(this.childrenKey))
                return item[this.childrenKey].length > 0;
            return false;
        };

        /**
        * @method egret.ObjectCollection#isItemOpen
        * @param item {any}
        * @returns {boolean}
        */
        ObjectCollection.prototype.isItemOpen = function (item) {
            return this._openNodes.indexOf(item) != -1;
        };

        /**
        * @method egret.ObjectCollection#expandItem
        * @param item {any}
        * @param open {boolean}
        */
        ObjectCollection.prototype.expandItem = function (item, open) {
            if (typeof open === "undefined") { open = true; }
            if (open)
                this.openNode(item);
            else
                this.closeNode(item);
        };

        /**
        * 打开一个节点
        */
        ObjectCollection.prototype.openNode = function (item) {
            if (this._openNodes.indexOf(item) == -1) {
                this._openNodes.push(item);
                var index = this.nodeList.indexOf(item);
                if (index != -1) {
                    var list = [];
                    this.addChildren(item, list);
                    var i = index;
                    while (list.length) {
                        i++;
                        var node = list.shift();
                        this.nodeList.splice(i, 0, node);
                        this.dispatchCoEvent(egret.CollectionEventKind.ADD, i, -1, [node]);
                    }
                    this.dispatchCoEvent("open", index, index, [item]);
                }
            }
        };

        /**
        * 关闭一个节点
        */
        ObjectCollection.prototype.closeNode = function (item) {
            var index = this._openNodes.indexOf(item);
            if (index == -1)
                return;
            var list = [];
            this.addChildren(item, list);
            this._openNodes.splice(index, 1);
            index = this.nodeList.indexOf(item);
            if (index != -1) {
                index++;
                while (list.length) {
                    var node = this.nodeList.splice(index, 1)[0];
                    this.dispatchCoEvent(egret.CollectionEventKind.REMOVE, index, -1, [node]);
                    list.shift();
                }
                index--;
                this.dispatchCoEvent(egret.CollectionEventKind.CLOSE, index, index, [item]);
            }
        };

        /**
        * @method egret.ObjectCollection#getDepth
        * @param item {any}
        * @returns {number}
        */
        ObjectCollection.prototype.getDepth = function (item) {
            var depth = 0;
            var parent = item[this.parentKey];
            while (parent) {
                depth++;
                parent = parent[this.parentKey];
            }
            if (depth > 0 && !this._showRoot)
                depth--;
            return depth;
        };

        /**
        * 刷新数据源。
        * @method egret.ObjectCollection#refresh
        */
        ObjectCollection.prototype.refresh = function () {
            this.nodeList = [];
            if (this._source) {
                if (this._showRoot) {
                    this.nodeList.push(this._source);
                }
                this.addChildren(this._source, this.nodeList);
            }
            this.dispatchCoEvent(egret.CollectionEventKind.REFRESH);
        };

        /**
        * 抛出事件
        */
        ObjectCollection.prototype.dispatchCoEvent = function (kind, location, oldLocation, items, oldItems) {
            if (typeof kind === "undefined") { kind = null; }
            if (typeof location === "undefined") { location = -1; }
            if (typeof oldLocation === "undefined") { oldLocation = -1; }
            if (typeof items === "undefined") { items = null; }
            if (typeof oldItems === "undefined") { oldItems = null; }
            egret.CollectionEvent.dispatchCollectionEvent(this, egret.CollectionEvent.COLLECTION_CHANGE, kind, location, oldLocation, items, oldItems);
        };

        /**
        * 一个工具方法，给parent的子项以及子孙项赋值父级引用。
        * @method egret.ObjectCollection.assignParent
        * @param parent {any} 要遍历子项的parent对象。
        * @param childrenKey {string} 要从parent中获取子项列表的属性名,属性值为一个数组或Vector。
        * @param parentKey {string} 要给子项赋值父级引用的属性名。
        */
        ObjectCollection.assignParent = function (parent, childrenKey, parentKey) {
            if (typeof childrenKey === "undefined") { childrenKey = "children"; }
            if (typeof parentKey === "undefined") { parentKey = "parent"; }
            if (!parent.hasOwnProperty(childrenKey))
                return;
            var children = parent[childrenKey];
            var length = children.length;
            for (var i = 0; i < length; i++) {
                var child = children[i];
                try  {
                    child[parentKey] = parent;
                } catch (e) {
                }
                ObjectCollection.assignParent(child, childrenKey, parentKey);
            }
        };
        return ObjectCollection;
    })(egret.EventDispatcher);
    egret.ObjectCollection = ObjectCollection;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.LayoutManager
    * @classdesc
    * 布局管理器
    * @extends egret.EventDispatcher
    */
    var LayoutManager = (function (_super) {
        __extends(LayoutManager, _super);
        /**
        * @method egret.LayoutManager#constructor
        */
        function LayoutManager() {
            _super.call(this);
            this.targetLevel = Number.MAX_VALUE;
            /**
            * 需要抛出组件初始化完成事件的对象
            */
            this.updateCompleteQueue = new egret.DepthQueue();
            this.invalidatePropertiesFlag = false;
            this.invalidateClientPropertiesFlag = false;
            this.invalidatePropertiesQueue = new egret.DepthQueue();
            this.invalidateSizeFlag = false;
            this.invalidateClientSizeFlag = false;
            this.invalidateSizeQueue = new egret.DepthQueue();
            this.invalidateDisplayListFlag = false;
            this.invalidateDisplayListQueue = new egret.DepthQueue();
            /**
            * 是否已经添加了事件监听
            */
            this.listenersAttached = false;
        }
        /**
        * 标记组件提交过属性
        * @method egret.LayoutManager#invalidateProperties
        * @param client {ILayoutManagerClient}
        */
        LayoutManager.prototype.invalidateProperties = function (client) {
            if (!this.invalidatePropertiesFlag) {
                this.invalidatePropertiesFlag = true;
                if (!this.listenersAttached)
                    this.attachListeners();
            }
            if (this.targetLevel <= client.nestLevel)
                this.invalidateClientPropertiesFlag = true;
            this.invalidatePropertiesQueue.insert(client);
        };

        /**
        * 使提交的属性生效
        */
        LayoutManager.prototype.validateProperties = function () {
            var client = this.invalidatePropertiesQueue.shift();
            while (client) {
                if (client.parent) {
                    client.validateProperties();
                    if (!client.updateCompletePendingFlag) {
                        this.updateCompleteQueue.insert(client);
                        client.updateCompletePendingFlag = true;
                    }
                }
                client = this.invalidatePropertiesQueue.shift();
            }
            if (this.invalidatePropertiesQueue.isEmpty())
                this.invalidatePropertiesFlag = false;
        };

        /**
        * 标记需要重新测量尺寸
        * @method egret.LayoutManager#invalidateSize
        * @param client {ILayoutManagerClient}
        */
        LayoutManager.prototype.invalidateSize = function (client) {
            if (!this.invalidateSizeFlag) {
                this.invalidateSizeFlag = true;
                if (!this.listenersAttached)
                    this.attachListeners();
            }
            if (this.targetLevel <= client.nestLevel)
                this.invalidateClientSizeFlag = true;
            this.invalidateSizeQueue.insert(client);
        };

        /**
        * 测量属性
        */
        LayoutManager.prototype.validateSize = function () {
            var client = this.invalidateSizeQueue.pop();
            while (client) {
                if (client.parent) {
                    client.validateSize();
                    if (!client.updateCompletePendingFlag) {
                        this.updateCompleteQueue.insert(client);
                        client.updateCompletePendingFlag = true;
                    }
                }
                client = this.invalidateSizeQueue.pop();
            }
            if (this.invalidateSizeQueue.isEmpty())
                this.invalidateSizeFlag = false;
        };

        /**
        * 标记需要重新测量尺寸
        * @method egret.LayoutManager#invalidateDisplayList
        * @param client {ILayoutManagerClient}
        */
        LayoutManager.prototype.invalidateDisplayList = function (client) {
            if (!this.invalidateDisplayListFlag) {
                this.invalidateDisplayListFlag = true;
                if (!this.listenersAttached)
                    this.attachListeners();
            }
            this.invalidateDisplayListQueue.insert(client);
        };

        /**
        * 测量属性
        */
        LayoutManager.prototype.validateDisplayList = function () {
            var client = this.invalidateDisplayListQueue.shift();
            while (client) {
                if (client.parent) {
                    client.validateDisplayList();
                    if (!client.updateCompletePendingFlag) {
                        this.updateCompleteQueue.insert(client);
                        client.updateCompletePendingFlag = true;
                    }
                }
                client = this.invalidateDisplayListQueue.shift();
            }
            if (this.invalidateDisplayListQueue.isEmpty())
                this.invalidateDisplayListFlag = false;
        };

        /**
        * 添加事件监听
        */
        LayoutManager.prototype.attachListeners = function () {
            egret.UIGlobals.stage.addEventListener(egret.Event.ENTER_FRAME, this.doPhasedInstantiationCallBack, this);
            egret.UIGlobals.stage.addEventListener(egret.Event.RENDER, this.doPhasedInstantiationCallBack, this);
            egret.UIGlobals.stage.invalidate();
            this.listenersAttached = true;
        };

        /**
        * 执行属性应用
        */
        LayoutManager.prototype.doPhasedInstantiationCallBack = function (event) {
            if (typeof event === "undefined") { event = null; }
            egret.UIGlobals.stage.removeEventListener(egret.Event.ENTER_FRAME, this.doPhasedInstantiationCallBack, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.RENDER, this.doPhasedInstantiationCallBack, this);
            this.doPhasedInstantiation();
        };

        LayoutManager.prototype.doPhasedInstantiation = function () {
            if (this.invalidatePropertiesFlag) {
                this.validateProperties();
            }
            if (this.invalidateSizeFlag) {
                this.validateSize();
            }

            if (this.invalidateDisplayListFlag) {
                this.validateDisplayList();
            }

            if (this.invalidatePropertiesFlag || this.invalidateSizeFlag || this.invalidateDisplayListFlag) {
                this.attachListeners();
            } else {
                this.listenersAttached = false;
                var client = this.updateCompleteQueue.pop();
                while (client) {
                    if (!client.initialized)
                        client.initialized = true;
                    if (client.hasEventListener(egret.UIEvent.UPDATE_COMPLETE))
                        egret.UIEvent.dispatchUIEvent(client, egret.UIEvent.UPDATE_COMPLETE);
                    client.updateCompletePendingFlag = false;
                    client = this.updateCompleteQueue.pop();
                }
                egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.UPDATE_COMPLETE);
            }
        };

        /**
        * 立即应用所有延迟的属性
        * @method egret.LayoutManager#validateNow
        */
        LayoutManager.prototype.validateNow = function () {
            var infiniteLoopGuard = 0;
            while (this.listenersAttached && infiniteLoopGuard++ < 100)
                this.doPhasedInstantiationCallBack();
        };

        /**
        * 使大于等于指定组件层级的元素立即应用属性
        * @method egret.LayoutManager#validateClient
        * @param target {ILayoutManagerClient} 要立即应用属性的组件
        * @param skipDisplayList {boolean} 是否跳过更新显示列表阶段
        */
        LayoutManager.prototype.validateClient = function (target, skipDisplayList) {
            if (typeof skipDisplayList === "undefined") { skipDisplayList = false; }
            var obj;
            var i = 0;
            var done = false;
            var oldTargetLevel = this.targetLevel;

            if (this.targetLevel == Number.MAX_VALUE)
                this.targetLevel = target.nestLevel;

            while (!done) {
                done = true;

                obj = (this.invalidatePropertiesQueue.removeSmallestChild(target));
                while (obj) {
                    if (obj.parent) {
                        obj.validateProperties();
                        if (!obj.updateCompletePendingFlag) {
                            this.updateCompleteQueue.insert(obj);
                            obj.updateCompletePendingFlag = true;
                        }
                    }
                    obj = (this.invalidatePropertiesQueue.removeSmallestChild(target));
                }

                if (this.invalidatePropertiesQueue.isEmpty()) {
                    this.invalidatePropertiesFlag = false;
                }
                this.invalidateClientPropertiesFlag = false;

                obj = (this.invalidateSizeQueue.removeLargestChild(target));
                while (obj) {
                    if (obj.parent) {
                        obj.validateSize();
                        if (!obj.updateCompletePendingFlag) {
                            this.updateCompleteQueue.insert(obj);
                            obj.updateCompletePendingFlag = true;
                        }
                    }
                    if (this.invalidateClientPropertiesFlag) {
                        obj = (this.invalidatePropertiesQueue.removeSmallestChild(target));
                        if (obj) {
                            this.invalidatePropertiesQueue.insert(obj);
                            done = false;
                            break;
                        }
                    }

                    obj = (this.invalidateSizeQueue.removeLargestChild(target));
                }

                if (this.invalidateSizeQueue.isEmpty()) {
                    this.invalidateSizeFlag = false;
                }
                this.invalidateClientPropertiesFlag = false;
                this.invalidateClientSizeFlag = false;

                if (!skipDisplayList) {
                    obj = (this.invalidateDisplayListQueue.removeSmallestChild(target));
                    while (obj) {
                        if (obj.parent) {
                            obj.validateDisplayList();
                            if (!obj.updateCompletePendingFlag) {
                                this.updateCompleteQueue.insert(obj);
                                obj.updateCompletePendingFlag = true;
                            }
                        }
                        if (this.invalidateClientPropertiesFlag) {
                            obj = (this.invalidatePropertiesQueue.removeSmallestChild(target));
                            if (obj) {
                                this.invalidatePropertiesQueue.insert(obj);
                                done = false;
                                break;
                            }
                        }

                        if (this.invalidateClientSizeFlag) {
                            obj = (this.invalidateSizeQueue.removeLargestChild(target));
                            if (obj) {
                                this.invalidateSizeQueue.insert(obj);
                                done = false;
                                break;
                            }
                        }

                        obj = (this.invalidateDisplayListQueue.removeSmallestChild(target));
                    }

                    if (this.invalidateDisplayListQueue.isEmpty()) {
                        this.invalidateDisplayListFlag = false;
                    }
                }
            }

            if (oldTargetLevel == Number.MAX_VALUE) {
                this.targetLevel = Number.MAX_VALUE;
                if (!skipDisplayList) {
                    obj = (this.updateCompleteQueue.removeLargestChild(target));
                    while (obj) {
                        if (!obj.initialized)
                            obj.initialized = true;

                        if (obj.hasEventListener(egret.UIEvent.UPDATE_COMPLETE))
                            egret.UIEvent.dispatchUIEvent(obj, egret.UIEvent.UPDATE_COMPLETE);
                        obj.updateCompletePendingFlag = false;
                        obj = (this.updateCompleteQueue.removeLargestChild(target));
                    }
                }
            }
        };
        return LayoutManager;
    })(egret.EventDispatcher);
    egret.LayoutManager = LayoutManager;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.DepthQueue
    * @classdesc
    * 显示列表嵌套深度排序队列
    */
    var DepthQueue = (function () {
        /**
        * @method egret.DepthQueue#constructor
        */
        function DepthQueue() {
            /**
            * 深度队列
            */
            this.depthBins = [];
            /**
            * 最小深度
            */
            this.minDepth = 0;
            /**
            * 最大深度
            */
            this.maxDepth = -1;
        }
        /**
        * 插入一个元素
        * @method egret.DepthQueue#insert
        * @param client {ILayoutManagerClient}
        */
        DepthQueue.prototype.insert = function (client) {
            var depth = client.nestLevel;
            var hashCode = client.hashCode;
            if (this.maxDepth < this.minDepth) {
                this.minDepth = this.maxDepth = depth;
            } else {
                if (depth < this.minDepth)
                    this.minDepth = depth;
                if (depth > this.maxDepth)
                    this.maxDepth = depth;
            }

            var bin = this.depthBins[depth];

            if (!bin) {
                bin = new DepthBin();
                this.depthBins[depth] = bin;
                bin.items[hashCode] = client;
                bin.length++;
            } else {
                if (bin.items[hashCode] == null) {
                    bin.items[hashCode] = client;
                    bin.length++;
                }
            }
        };

        /**
        * 从队列尾弹出深度最大的一个对象
        * @method egret.DepthQueue#pop
        * @returns {ILayoutManagerClient}
        */
        DepthQueue.prototype.pop = function () {
            var client = null;

            if (this.minDepth <= this.maxDepth) {
                var bin = this.depthBins[this.maxDepth];
                while (!bin || bin.length == 0) {
                    this.maxDepth--;
                    if (this.maxDepth < this.minDepth)
                        return null;
                    bin = this.depthBins[this.maxDepth];
                }
                var items = bin.items;
                for (var key in items) {
                    client = items[key];
                    this.remove(client, this.maxDepth);
                    break;
                }

                while (!bin || bin.length == 0) {
                    this.maxDepth--;
                    if (this.maxDepth < this.minDepth)
                        break;
                    bin = this.depthBins[this.maxDepth];
                }
            }

            return client;
        };

        /**
        * 从队列首弹出深度最小的一个对象
        * @method egret.DepthQueue#shift
        * @returns {ILayoutManagerClient}
        */
        DepthQueue.prototype.shift = function () {
            var client = null;

            if (this.minDepth <= this.maxDepth) {
                var bin = this.depthBins[this.minDepth];
                while (!bin || bin.length == 0) {
                    this.minDepth++;
                    if (this.minDepth > this.maxDepth)
                        return null;
                    bin = this.depthBins[this.minDepth];
                }

                var items = bin.items;
                for (var key in items) {
                    client = items[key];
                    this.remove(client, this.minDepth);
                    break;
                }

                while (!bin || bin.length == 0) {
                    this.minDepth++;
                    if (this.minDepth > this.maxDepth)
                        break;
                    bin = this.depthBins[this.minDepth];
                }
            }

            return client;
        };

        /**
        * 移除大于等于指定组件层级的元素中最大的元素
        * @method egret.DepthQueue#removeLargestChild
        * @param client {ILayoutManagerClient}
        * @returns {any}
        */
        DepthQueue.prototype.removeLargestChild = function (client) {
            var max = this.maxDepth;
            var min = client.nestLevel;
            var hashCode = client.hashCode;
            while (min <= max) {
                var bin = this.depthBins[max];
                if (bin && bin.length > 0) {
                    if (max == client.nestLevel) {
                        if (bin.items[hashCode]) {
                            this.remove(client, max);
                            return client;
                        }
                    } else {
                        var items = bin.items;
                        for (var key in items) {
                            var value = items[key];
                            if ((value instanceof egret.DisplayObject) && (client instanceof egret.DisplayObjectContainer) && client.contains(value)) {
                                this.remove(value, max);
                                return value;
                            }
                        }
                    }

                    max--;
                } else {
                    if (max == this.maxDepth)
                        this.maxDepth--;
                    max--;
                    if (max < min)
                        break;
                }
            }

            return null;
        };

        /**
        * 移除大于等于指定组件层级的元素中最小的元素
        * @method egret.DepthQueue#removeSmallestChild
        * @param client {ILayoutManagerClient}
        * @returns {any}
        */
        DepthQueue.prototype.removeSmallestChild = function (client) {
            var min = client.nestLevel;
            var hashCode = client.hashCode;
            while (min <= this.maxDepth) {
                var bin = this.depthBins[min];
                if (bin && bin.length > 0) {
                    if (min == client.nestLevel) {
                        if (bin.items[hashCode]) {
                            this.remove(client, min);
                            return client;
                        }
                    } else {
                        var items = bin.items;
                        for (var key in items) {
                            var value = items[key];
                            if ((value instanceof egret.DisplayObject) && (client instanceof egret.DisplayObjectContainer) && client.contains(value)) {
                                this.remove(value, min);
                                return value;
                            }
                        }
                    }

                    min++;
                } else {
                    if (min == this.minDepth)
                        this.minDepth++;
                    min++;
                    if (min > this.maxDepth)
                        break;
                }
            }

            return null;
        };

        /**
        * 移除一个元素
        * @method egret.DepthQueue#remove
        * @param client {ILayoutManagerClient}
        * @param level {number}
        * @returns {ILayoutManagerClient}
        */
        DepthQueue.prototype.remove = function (client, level) {
            if (typeof level === "undefined") { level = -1; }
            var depth = (level >= 0) ? level : client.nestLevel;
            var hashCode = client.hashCode;
            var bin = this.depthBins[depth];
            if (bin && bin.items[hashCode] != null) {
                delete bin.items[hashCode];
                bin.length--;
                return client;
            }
            return null;
        };

        /**
        * 清空队列
        * @method egret.DepthQueue#removeAll
        */
        DepthQueue.prototype.removeAll = function () {
            this.depthBins.length = 0;
            this.minDepth = 0;
            this.maxDepth = -1;
        };

        /**
        * 队列是否为空
        * @method egret.DepthQueue#isEmpty
        * @returns {boolean}
        */
        DepthQueue.prototype.isEmpty = function () {
            return this.minDepth > this.maxDepth;
        };
        return DepthQueue;
    })();
    egret.DepthQueue = DepthQueue;

    /**
    * @class egret.DepthBin
    * @classdesc
    * 列表项
    */
    var DepthBin = (function () {
        function DepthBin() {
            /**
            * @member egret.DepthBin#length
            */
            this.length = 0;
            /**
            * @member egret.DepthBin#items
            */
            this.items = [];
        }
        return DepthBin;
    })();
    egret.DepthBin = DepthBin;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.UIGlobals
    * @classdesc
    */
    var UIGlobals = (function () {
        function UIGlobals() {
        }
        Object.defineProperty(UIGlobals, "stage", {
            /**
            * 舞台引用，当第一个UIComponent添加到舞台时此属性被自动赋值
            * @member egret.UIGlobals.stage
            */
            get: function () {
                return UIGlobals._stage;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 初始化管理器
        * @method egret.UIGlobals._initlize
        * @param stage {Stage}
        */
        UIGlobals._initlize = function (stage) {
            if (UIGlobals.initlized)
                return;
            UIGlobals._stage = stage;
            UIGlobals._layoutManager = new egret.LayoutManager();
            UIGlobals.initlized = true;
        };

        Object.defineProperty(UIGlobals, "uiStage", {
            /**
            * 顶级应用容器
            * @member egret.UIGlobals.uiStage
            */
            get: function () {
                return UIGlobals._uiStage;
            },
            enumerable: true,
            configurable: true
        });
        UIGlobals.initlized = false;
        return UIGlobals;
    })();
    egret.UIGlobals = UIGlobals;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.UIComponent
    * @classdesc
    * 显示对象基类
    * @extends egret.DisplayObjectContainer
    * @implements egret.IUIComponent
    * @implements egret.ILayoutManagerClient
    * @implements egret.ILayoutElement
    * @implements egret.IInvalidating
    * @implements egret.IVisualElement
    */
    var UIComponent = (function (_super) {
        __extends(UIComponent, _super);
        /**
        * 构造函数
        * @method egret.UIComponent#constructor
        */
        function UIComponent() {
            _super.call(this);
            this._updateCompletePendingFlag = false;
            this._initialized = false;
            /**
            * _initialize()方法被调用过的标志。
            */
            this.initializeCalled = false;
            this._nestLevel = 0;
            this._enabled = true;
            this._width = 0;
            this._height = 0;
            this._minWidth = 0;
            this._maxWidth = 10000;
            this._minHeight = 0;
            this._maxHeight = 10000;
            this._measuredWidth = 0;
            this._measuredHeight = 0;
            /**
            * @member egret.UIComponent#_invalidatePropertiesFlag
            */
            this._invalidatePropertiesFlag = false;
            /**
            * @member egret.UIComponent#_invalidateSizeFlag
            */
            this._invalidateSizeFlag = false;
            /**
            * @member egret.UIComponent#_invalidateDisplayListFlag
            */
            this._invalidateDisplayListFlag = false;
            /**
            * @member egret.UIComponent#_validateNowFlag
            */
            this._validateNowFlag = false;
            this._includeInLayout = true;
            /**
            * 父级布局管理器设置了组件的宽度标志，尺寸设置优先级：自动布局>显式设置>自动测量
            * @member egret.UIComponent#_layoutWidthExplicitlySet
            */
            this._layoutWidthExplicitlySet = false;
            /**
            * 父级布局管理器设置了组件的高度标志，尺寸设置优先级：自动布局>显式设置>自动测量
            * @member egret.UIComponent#_layoutHeightExplicitlySet
            */
            this._layoutHeightExplicitlySet = false;
            this.touchEnabled = true;
            this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddedToStage, this);
            this.addEventListener(egret.Event.ADDED_TO_STAGE, this.checkInvalidateFlag, this);
        }
        /**
        * 添加到舞台
        */
        UIComponent.prototype.onAddedToStage = function (e) {
            this.removeEventListener(egret.Event.ADDED_TO_STAGE, this.onAddedToStage, this);
            this._initialize();
            egret.UIGlobals._initlize(this.stage);
            if (this._nestLevel > 0)
                this.checkInvalidateFlag();
        };

        Object.defineProperty(UIComponent.prototype, "id", {
            /**
            * 组件 ID。此值将作为对象的实例名称，因此不应包含任何空格或特殊字符。应用程序中的每个组件都应具有唯一的 ID。
            * @constant egret.UIComponent#id
            */
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIComponent.prototype, "isPopUp", {
            /**
            * @member egret.UIComponent#isPopUp
            */
            get: function () {
                return this._isPopUp;
            },
            set: function (value) {
                this._isPopUp = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "owner", {
            /**
            * @member egret.UIComponent#owner
            */
            get: function () {
                return this._owner ? this._owner : this.parent;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.UIComponent#ownerChanged
        * @param value {any}
        */
        UIComponent.prototype.ownerChanged = function (value) {
            this._owner = value;
        };

        Object.defineProperty(UIComponent.prototype, "updateCompletePendingFlag", {
            /**
            * @member egret.UIComponent#updateCompletePendingFlag
            */
            get: function () {
                return this._updateCompletePendingFlag;
            },
            set: function (value) {
                this._updateCompletePendingFlag = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "initialized", {
            /**
            * @member egret.UIComponent#initialized
            */
            get: function () {
                return this._initialized;
            },
            set: function (value) {
                if (this._initialized == value)
                    return;
                this._initialized = value;
                if (value) {
                    egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CREATION_COMPLETE);
                }
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 初始化组件
        * @method egret.UIComponent#_initialize
        */
        UIComponent.prototype._initialize = function () {
            if (this.initializeCalled)
                return;
            if (egret.UIGlobals.stage) {
                this.removeEventListener(egret.Event.ADDED_TO_STAGE, this.onAddedToStage, this);
            }
            this.initializeCalled = true;
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.INITIALIZE);
            this.createChildren();
            this.childrenCreated();
        };

        /**
        * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
        * 请务必调用super.createChildren()以完成父类组件的初始化
        * @method egret.UIComponent#createChildren
        */
        UIComponent.prototype.createChildren = function () {
        };

        /**
        * 子项创建完成
        * @method egret.UIComponent#childrenCreated
        */
        UIComponent.prototype.childrenCreated = function () {
            this.invalidateProperties();
            this.invalidateSize();
            this.invalidateDisplayList();
        };

        Object.defineProperty(UIComponent.prototype, "nestLevel", {
            /**
            * @member egret.UIComponent#nestLevel
            */
            get: function () {
                return this._nestLevel;
            },
            set: function (value) {
                if (this._nestLevel == value)
                    return;
                this._nestLevel = value;

                if (this._nestLevel == 0)
                    this.addEventListener(egret.Event.ADDED_TO_STAGE, this.checkInvalidateFlag, this);
                else
                    this.removeEventListener(egret.Event.ADDED_TO_STAGE, this.checkInvalidateFlag, this);

                for (var i = this.numChildren - 1; i >= 0; i--) {
                    var child = (this.getChildAt(i));
                    if (child != null) {
                        child.nestLevel = this._nestLevel + 1;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 添加对象到显示列表,此接口仅预留给框架内部使用
        * 如果需要管理子项，若有，请使用容器的addElement()方法，非法使用有可能造成无法自动布局。
        */
        UIComponent.prototype._addToDisplayList = function (child, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            var index = this.numChildren;

            if (child.parent == this)
                index--;
            this._addingChild(child);
            this._doAddChild(child, index, notifyListeners);
            this._childAdded(child);
            return child;
        };

        /**
        * 添加对象到显示列表,此接口仅预留给框架内部使用
        * 如果需要管理子项，若有，请使用容器的addElementAt()方法，非法使用有可能造成无法自动布局。
        */
        UIComponent.prototype._addToDisplayListAt = function (child, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            this._addingChild(child);
            this._doAddChild(child, index, notifyListeners);
            this._childAdded(child);
            return child;
        };

        /**
        * 添加对象到显示列表,此接口仅预留给框架内部使用
        * 如果需要管理子项，若有，请使用容器的removeElement()方法,非法使用有可能造成无法自动布局。
        */
        UIComponent.prototype._removeFromDisplayList = function (child, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            var index = this._children.indexOf(child);
            if (index >= 0) {
                this._doRemoveChild(index, notifyListeners);
                this._childRemoved(child);
                return child;
            } else {
                egret.Logger.fatal("child未被addChild到该parent");
                return null;
            }
        };

        /**
        * 从显示列表移除指定索引的子项,此接口仅预留给框架内部使用
        * 如果需要管理子项，若有，请使用容器的removeElementAt()方法,非法使用有可能造成无法自动布局。
        */
        UIComponent.prototype._removeFromDisplayListAt = function (index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (index >= 0 && index < this._children.length) {
                var child = this._doRemoveChild(index, notifyListeners);
                this._childRemoved(child);
                return child;
            } else {
                egret.Logger.fatal("提供的索引超出范围");
                return null;
            }
        };

        /**
        * GUI范围内，请不要调用任何addChild方法，若是容器，请用addElement,若需要包装普通显示对象，请把显示对象赋值给UIAsset.source。
        * @deprecated
        * @method egret.UIComponent#addChild
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        UIComponent.prototype.addChild = function (child) {
            this._addingChild(child);
            _super.prototype.addChild.call(this, child);
            this._childAdded(child);
            return child;
        };

        /**
        * GUI范围内，请不要调用任何addChildAt方法，若是容器，请用addElementAt,若需要包装普通显示对象，请把显示对象赋值给UIAsset.source。
        * @deprecated
        * @method egret.UIComponent#addChildAt
        * @param child {DisplayObject}
        * @param index {number}
        * @returns {DisplayObject}
        */
        UIComponent.prototype.addChildAt = function (child, index) {
            this._addingChild(child);
            _super.prototype.addChildAt.call(this, child, index);
            this._childAdded(child);
            return child;
        };

        /**
        * 即将添加一个子项
        * @method egret.UIComponent#_addingChild
        * @param child {DisplayObject}
        */
        UIComponent.prototype._addingChild = function (child) {
            if (child && "nestLevel" in child) {
                child.nestLevel = this._nestLevel + 1;
            }
        };

        /**
        * 已经添加一个子项
        */
        UIComponent.prototype._childAdded = function (child) {
            if (child instanceof UIComponent) {
                child._initialize();
                child.checkInvalidateFlag();
            }
        };

        /**
        * GUI范围内，请不要调用任何removeChild方法，若是容器，请用removeElement
        * @deprecated
        * @method egret.UIComponent#removeChild
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        UIComponent.prototype.removeChild = function (child) {
            _super.prototype.removeChild.call(this, child);
            this._childRemoved(child);
            return child;
        };

        /**
        * GUI范围内，请不要调用任何removeChildAt方法，若是容器，请用removeElementAt
        * @deprecated
        * @method egret.UIComponent#removeChildAt
        * @param index {number}
        * @returns {DisplayObject}
        */
        UIComponent.prototype.removeChildAt = function (index) {
            var child = _super.prototype.removeChildAt.call(this, index);
            this._childRemoved(child);
            return child;
        };

        /**
        * 已经移除一个子项
        */
        UIComponent.prototype._childRemoved = function (child) {
            if (child && "nestLevel" in child) {
                child.nestLevel = 0;
            }
        };

        /**
        * 检查属性失效标记并应用
        */
        UIComponent.prototype.checkInvalidateFlag = function (event) {
            if (typeof event === "undefined") { event = null; }
            if (!egret.UIGlobals._layoutManager)
                return;
            if (this._invalidatePropertiesFlag) {
                egret.UIGlobals._layoutManager.invalidateProperties(this);
            }
            if (this._invalidateSizeFlag) {
                egret.UIGlobals._layoutManager.invalidateSize(this);
            }
            if (this._invalidateDisplayListFlag) {
                egret.UIGlobals._layoutManager.invalidateDisplayList(this);
            }
            if (this._validateNowFlag) {
                egret.UIGlobals._layoutManager.validateClient(this);
                this._validateNowFlag = false;
            }
        };

        Object.defineProperty(UIComponent.prototype, "enabled", {
            /**
            * @member egret.UIComponent#enabled
            */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                this._enabled = value;
            },
            enumerable: true,
            configurable: true
        });



        UIComponent.prototype._setWidth = function (value) {
            if (this._width == value && this._explicitWidth == value)
                return;
            _super.prototype._setWidth.call(this, value);
            if (isNaN(value))
                this.invalidateSize();
            else
                this._width = value;
            this.invalidateProperties();
            this.invalidateDisplayList();
            this.invalidateParentSizeAndDisplayList();
        };

        Object.defineProperty(UIComponent.prototype, "width", {
            /**
            * @member egret.UIComponent#width
            */
            get: function () {
                return this._width;
            },
            /**
            * 组件宽度,默认值为NaN,设置为NaN将使用组件的measure()方法自动计算尺寸
            */
            set: function (value) {
                this._setWidth(value);
            },
            enumerable: true,
            configurable: true
        });


        UIComponent.prototype._setHeight = function (value) {
            if (this._height == value && this._explicitHeight == value)
                return;
            _super.prototype._setHeight.call(this, value);
            if (isNaN(value))
                this.invalidateSize();
            else
                this._height = value;
            this.invalidateProperties();
            this.invalidateDisplayList();
            this.invalidateParentSizeAndDisplayList();
        };

        Object.defineProperty(UIComponent.prototype, "height", {
            /**
            * @member egret.UIComponent#height
            */
            get: function () {
                return this._height;
            },
            /**
            * 组件高度,默认值为NaN,设置为NaN将使用组件的measure()方法自动计算尺寸
            */
            set: function (value) {
                this._setHeight(value);
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "scaleX", {
            /**
            * @member egret.UIComponent#scaleX
            */
            get: function () {
                return this._scaleX;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                this._setScaleX(value);
            },
            enumerable: true,
            configurable: true
        });


        UIComponent.prototype._setScaleX = function (value) {
            if (this._scaleX == value)
                return;
            this._scaleX = value;
            this.invalidateParentSizeAndDisplayList();
        };

        Object.defineProperty(UIComponent.prototype, "scaleY", {
            /**
            * @member egret.UIComponent#scaleY
            */
            get: function () {
                return this._scaleY;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                this._setScaleY(value);
            },
            enumerable: true,
            configurable: true
        });


        UIComponent.prototype._setScaleY = function (value) {
            if (this._scaleY == value)
                return;
            this._scaleY = value;
            this.invalidateParentSizeAndDisplayList();
        };

        Object.defineProperty(UIComponent.prototype, "minWidth", {
            /**
            * @member egret.UIComponent#minWidth
            */
            get: function () {
                return this._minWidth;
            },
            set: function (value) {
                if (this._minWidth == value)
                    return;
                this._minWidth = value;
                this.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "maxWidth", {
            /**
            * @member egret.UIComponent#maxWidth
            */
            get: function () {
                return this._maxWidth;
            },
            set: function (value) {
                if (this._maxWidth == value)
                    return;
                this._maxWidth = value;
                this.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "minHeight", {
            /**
            * @member egret.UIComponent#minHeight
            */
            get: function () {
                return this._minHeight;
            },
            set: function (value) {
                if (this._minHeight == value)
                    return;
                this._minHeight = value;
                this.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "maxHeight", {
            /**
            * @member egret.UIComponent#maxHeight
            */
            get: function () {
                return this._maxHeight;
            },
            set: function (value) {
                if (this._maxHeight == value)
                    return;
                this._maxHeight = value;
                this.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "measuredWidth", {
            /**
            * 组件的默认宽度（以像素为单位）。此值由 measure() 方法设置。
            * @member egret.UIComponent#measuredWidth
            */
            get: function () {
                return this._measuredWidth;
            },
            set: function (value) {
                this._measuredWidth = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "measuredHeight", {
            /**
            * 组件的默认高度（以像素为单位）。此值由 measure() 方法设置。
            * @member egret.UIComponent#measuredHeight
            */
            get: function () {
                return this._measuredHeight;
            },
            set: function (value) {
                this._measuredHeight = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.UIComponent#setActualSize
        * @param w {number}
        * @param h {number}
        */
        UIComponent.prototype.setActualSize = function (w, h) {
            var change = false;
            if (this._width != w) {
                this._width = w;
                change = true;
            }
            if (this._height != h) {
                this._height = h;
                change = true;
            }
            if (change) {
                this.invalidateDisplayList();
                this.dispatchResizeEvent();
            }
        };

        Object.defineProperty(UIComponent.prototype, "x", {
            /**
            * @constant egret.UIComponent#x
            */
            get: function () {
                return this._x;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._x == value)
                    return;
                this._x = value;
                this.invalidateProperties();
                if (this._includeInLayout && this.parent && this.parent instanceof UIComponent)
                    (this.parent)._childXYChanged();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIComponent.prototype, "y", {
            /**
            * @constant egret.UIComponent#y
            */
            get: function () {
                return this._y;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._y == value)
                    return;
                this._y = value;
                this.invalidateProperties();
                if (this._includeInLayout && this.parent && this.parent instanceof UIComponent)
                    (this.parent)._childXYChanged();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.UIComponent#invalidateProperties
        */
        UIComponent.prototype.invalidateProperties = function () {
            if (!this._invalidatePropertiesFlag) {
                this._invalidatePropertiesFlag = true;

                if (this.parent && egret.UIGlobals._layoutManager)
                    egret.UIGlobals._layoutManager.invalidateProperties(this);
            }
        };

        /**
        * @method egret.UIComponent#validateProperties
        */
        UIComponent.prototype.validateProperties = function () {
            if (this._invalidatePropertiesFlag) {
                this.commitProperties();

                this._invalidatePropertiesFlag = false;
            }
        };

        /**
        * @method egret.UIComponent#invalidateSize
        */
        UIComponent.prototype.invalidateSize = function () {
            if (!this._invalidateSizeFlag) {
                this._invalidateSizeFlag = true;

                if (this.parent && egret.UIGlobals._layoutManager)
                    egret.UIGlobals._layoutManager.invalidateSize(this);
            }
        };

        /**
        * @method egret.UIComponent#validateSize
        * @param recursive {boolean}
        */
        UIComponent.prototype.validateSize = function (recursive) {
            if (typeof recursive === "undefined") { recursive = false; }
            if (recursive) {
                for (var i = 0; i < this.numChildren; i++) {
                    var child = this.getChildAt(i);
                    if ("validateSize" in child)
                        child.validateSize(true);
                }
            }
            if (this._invalidateSizeFlag) {
                var changed = this.measureSizes();
                if (changed) {
                    this.invalidateDisplayList();
                    this.invalidateParentSizeAndDisplayList();
                }
                this._invalidateSizeFlag = false;
            }
        };

        /**
        * 测量组件尺寸，返回尺寸是否发生变化
        */
        UIComponent.prototype.measureSizes = function () {
            var changed = false;

            if (!this._invalidateSizeFlag)
                return changed;

            if (!this.canSkipMeasurement()) {
                this.measure();
                if (this.measuredWidth < this.minWidth) {
                    this.measuredWidth = this.minWidth;
                }
                if (this.measuredWidth > this.maxWidth) {
                    this.measuredWidth = this.maxWidth;
                }
                if (this.measuredHeight < this.minHeight) {
                    this.measuredHeight = this.minHeight;
                }
                if (this.measuredHeight > this.maxHeight) {
                    this.measuredHeight = this.maxHeight;
                }
            }
            if (isNaN(this._oldPreferWidth)) {
                this._oldPreferWidth = this.preferredWidth;
                this._oldPreferHeight = this.preferredHeight;
                changed = true;
            } else {
                if (this.preferredWidth != this._oldPreferWidth || this.preferredHeight != this._oldPreferHeight)
                    changed = true;
                this._oldPreferWidth = this.preferredWidth;
                this._oldPreferHeight = this.preferredHeight;
            }
            return changed;
        };

        /**
        * @method egret.UIComponent#invalidateDisplayList
        */
        UIComponent.prototype.invalidateDisplayList = function () {
            if (!this._invalidateDisplayListFlag) {
                this._invalidateDisplayListFlag = true;

                if (this.parent && egret.UIGlobals._layoutManager)
                    egret.UIGlobals._layoutManager.invalidateDisplayList(this);
            }
        };

        /**
        * @method egret.UIComponent#validateDisplayList
        */
        UIComponent.prototype.validateDisplayList = function () {
            if (this._invalidateDisplayListFlag) {
                var unscaledWidth = 0;
                var unscaledHeight = 0;
                if (this._layoutWidthExplicitlySet) {
                    unscaledWidth = this._width;
                } else if (!isNaN(this.explicitWidth)) {
                    unscaledWidth = this._explicitWidth;
                } else {
                    unscaledWidth = this.measuredWidth;
                }
                if (this._layoutHeightExplicitlySet) {
                    unscaledHeight = this._height;
                } else if (!isNaN(this.explicitHeight)) {
                    unscaledHeight = this._explicitHeight;
                } else {
                    unscaledHeight = this.measuredHeight;
                }
                if (isNaN(unscaledWidth))
                    unscaledWidth = 0;
                if (isNaN(unscaledHeight))
                    unscaledHeight = 0;
                this.setActualSize(unscaledWidth, unscaledHeight);
                this.updateDisplayList(unscaledWidth, unscaledHeight);
                this._invalidateDisplayListFlag = false;
            }
        };

        /**
        * @method egret.UIComponent#validateNow
        * @param skipDisplayList {boolean}
        */
        UIComponent.prototype.validateNow = function (skipDisplayList) {
            if (typeof skipDisplayList === "undefined") { skipDisplayList = false; }
            if (!this._validateNowFlag && egret.UIGlobals._layoutManager != null)
                egret.UIGlobals._layoutManager.validateClient(this, skipDisplayList);
            else
                this._validateNowFlag = true;
        };

        /**
        * 标记父级容器的尺寸和显示列表为失效
        * @method egret.UIComponent#invalidateParentSizeAndDisplayList
        */
        UIComponent.prototype.invalidateParentSizeAndDisplayList = function () {
            if (!this.parent || !this._includeInLayout || !("invalidateSize" in this.parent))
                return;
            var p = (this.parent);
            p.invalidateSize();
            p.invalidateDisplayList();
        };

        /**
        * 更新显示列表
        * @method egret.UIComponent#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        UIComponent.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        };

        /**
        * 是否可以跳过测量尺寸阶段,返回true则不执行measure()方法
        * @method egret.UIComponent#canSkipMeasurement
        * @returns {boolean}
        */
        UIComponent.prototype.canSkipMeasurement = function () {
            return !isNaN(this._explicitWidth) && !isNaN(this._explicitHeight);
        };

        /**
        * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
        * @method egret.UIComponent#commitProperties
        */
        UIComponent.prototype.commitProperties = function () {
            if (this.oldWidth != this._width || this.oldHeight != this._height) {
                this.dispatchResizeEvent();
            }
            if (this.oldX != this.x || this.oldY != this.y) {
                this.dispatchMoveEvent();
            }
        };

        /**
        * 测量组件尺寸
        * @method egret.UIComponent#measure
        */
        UIComponent.prototype.measure = function () {
            this._measuredHeight = 0;
            this._measuredWidth = 0;
        };

        /**
        *  抛出移动事件
        */
        UIComponent.prototype.dispatchMoveEvent = function () {
            if (this.hasEventListener(egret.MoveEvent.MOVE)) {
                egret.MoveEvent.dispatchMoveEvent(this, this.oldX, this.oldY);
            }
            this.oldX = this.x;
            this.oldY = this.y;
        };

        /**
        * 子项的xy位置发生改变
        */
        UIComponent.prototype._childXYChanged = function () {
        };

        /**
        *  抛出尺寸改变事件
        */
        UIComponent.prototype.dispatchResizeEvent = function () {
            if (this.hasEventListener(egret.ResizeEvent.RESIZE)) {
                egret.ResizeEvent.dispatchResizeEvent(this, this.oldWidth, this.oldHeight);
            }
            this.oldWidth = this._width;
            this.oldHeight = this._height;
        };

        Object.defineProperty(UIComponent.prototype, "includeInLayout", {
            /**
            * @member egret.UIComponent#includeInLayout
            */
            get: function () {
                return this._includeInLayout;
            },
            set: function (value) {
                if (this._includeInLayout == value)
                    return;
                this._includeInLayout = true;
                this.invalidateParentSizeAndDisplayList();
                this._includeInLayout = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "left", {
            /**
            * @member egret.UIComponent#left
            */
            get: function () {
                return this._left;
            },
            set: function (value) {
                if (this._left == value)
                    return;
                this._left = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "right", {
            /**
            * @member egret.UIComponent#right
            */
            get: function () {
                return this._right;
            },
            set: function (value) {
                if (this._right == value)
                    return;
                this._right = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "top", {
            /**
            * @member egret.UIComponent#top
            */
            get: function () {
                return this._top;
            },
            set: function (value) {
                if (this._top == value)
                    return;
                this._top = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "bottom", {
            /**
            * @member egret.UIComponent#bottom
            */
            get: function () {
                return this._bottom;
            },
            set: function (value) {
                if (this._bottom == value)
                    return;
                this._bottom = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "horizontalCenter", {
            /**
            * @member egret.UIComponent#horizontalCenter
            */
            get: function () {
                return this._horizontalCenter;
            },
            set: function (value) {
                if (this._horizontalCenter == value)
                    return;
                this._horizontalCenter = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "verticalCenter", {
            /**
            * @member egret.UIComponent#verticalCenter
            */
            get: function () {
                return this._verticalCenter;
            },
            set: function (value) {
                if (this._verticalCenter == value)
                    return;
                this._verticalCenter = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "percentWidth", {
            /**
            * @member egret.UIComponent#percentWidth
            */
            get: function () {
                return this._percentWidth;
            },
            set: function (value) {
                if (this._percentWidth == value)
                    return;
                this._percentWidth = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "percentHeight", {
            /**
            * @member egret.UIComponent#percentHeight
            */
            get: function () {
                return this._percentHeight;
            },
            set: function (value) {
                if (this._percentHeight == value)
                    return;
                this._percentHeight = value;
                this.invalidateParentSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.UIComponent#setLayoutBoundsSize
        * @param layoutWidth {number}
        * @param layoutHeight {number}
        */
        UIComponent.prototype.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
            if (isNaN(layoutWidth)) {
                this._layoutWidthExplicitlySet = false;
                layoutWidth = this.preferredWidth;
            } else {
                this._layoutWidthExplicitlySet = true;
            }
            if (isNaN(layoutHeight)) {
                this._layoutHeightExplicitlySet = false;
                layoutHeight = this.preferredHeight;
            } else {
                this._layoutHeightExplicitlySet = true;
            }

            this.setActualSize(layoutWidth / this._scaleX, layoutHeight / this._scaleY);
        };

        /**
        * @method egret.UIComponent#setLayoutBoundsPosition
        * @param x {number}
        * @param y {number}
        */
        UIComponent.prototype.setLayoutBoundsPosition = function (x, y) {
            if (this._scaleX < 0) {
                x += this.layoutBoundsWidth;
            }
            if (this._scaleY < 0) {
                y += this.layoutBoundsHeight;
            }
            var changed = false;
            if (this._x != x) {
                this._x = x;
                changed = true;
            }
            if (this._y != y) {
                this._y = y;
                changed = true;
            }
            if (changed) {
                this.dispatchMoveEvent();
            }
        };

        Object.defineProperty(UIComponent.prototype, "preferredWidth", {
            /**
            * @member egret.UIComponent#preferredWidth
            */
            get: function () {
                var w = this._hasWidthSet ? this._explicitWidth : this._measuredWidth;
                var scaleX = this._scaleX;
                if (scaleX < 0) {
                    scaleX = -scaleX;
                }
                return w * scaleX;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "preferredHeight", {
            /**
            * @member egret.UIComponent#preferredHeight
            */
            get: function () {
                var h = this._hasHeightSet ? this._explicitHeight : this._measuredHeight;
                var scaleY = this._scaleY;
                if (scaleY < 0) {
                    scaleY = -scaleY;
                }
                return h * scaleY;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "preferredX", {
            /**
            * @member egret.UIComponent#preferredX
            */
            get: function () {
                if (this._scaleX >= 0) {
                    return this._x;
                }
                var w = this.preferredWidth;
                return this._x - w;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "preferredY", {
            /**
            * @member egret.UIComponent#preferredY
            */
            get: function () {
                if (this._scaleY >= 0) {
                    return this._y;
                }
                var h = this.preferredHeight;
                return this._y - h;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "layoutBoundsX", {
            /**
            * @member egret.UIComponent#layoutBoundsX
            */
            get: function () {
                if (this._scaleX >= 0) {
                    return this._x;
                }
                var w = this.layoutBoundsWidth;
                return this._x - w;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "layoutBoundsY", {
            /**
            * @member egret.UIComponent#layoutBoundsY
            */
            get: function () {
                if (this._scaleY >= 0) {
                    return this._y;
                }
                var h = this.layoutBoundsHeight;
                return this._y - h;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "layoutBoundsWidth", {
            /**
            * @member egret.UIComponent#layoutBoundsWidth
            */
            get: function () {
                var w = 0;
                if (this._layoutWidthExplicitlySet) {
                    w = this._width;
                } else if (this._hasWidthSet) {
                    w = this._explicitWidth;
                } else {
                    w = this._measuredWidth;
                }
                var scaleX = this._scaleX;
                if (scaleX < 0) {
                    scaleX = -scaleX;
                }
                return w * scaleX;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIComponent.prototype, "layoutBoundsHeight", {
            /**
            * 组件的布局高度,常用于父级的updateDisplayList()方法中
            * 按照：布局高度>外部显式设置高度>测量高度 的优先级顺序返回高度
            * @member egret.UIComponent#layoutBoundsHeight
            */
            get: function () {
                var h = 0;
                if (this._layoutHeightExplicitlySet) {
                    h = this._height;
                } else if (this._hasHeightSet) {
                    h = this._explicitHeight;
                } else {
                    h = this._measuredHeight;
                }
                var scaleY = this.scaleY;
                if (scaleY < 0) {
                    scaleY = -scaleY;
                }
                return h * scaleY;
            },
            enumerable: true,
            configurable: true
        });
        return UIComponent;
    })(egret.DisplayObjectContainer);
    egret.UIComponent = UIComponent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.PopUpPosition
    * @classdesc
    * 定义弹出位置的常量值。
    * 该常量决定目标对象相对于父级组件的弹出位置。
    */
    var PopUpPosition = (function () {
        function PopUpPosition() {
        }
        PopUpPosition.ABOVE = "above";

        PopUpPosition.BELOW = "below";

        PopUpPosition.CENTER = "center";

        PopUpPosition.TOP_LEFT = "topLeft";

        PopUpPosition.LEFT = "left";

        PopUpPosition.RIGHT = "right";
        return PopUpPosition;
    })();
    egret.PopUpPosition = PopUpPosition;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.ScrollPolicy
    * @classdesc
    * 滚动条显示策略常量
    */
    var ScrollPolicy = (function () {
        function ScrollPolicy() {
        }
        ScrollPolicy.AUTO = "auto";

        ScrollPolicy.OFF = "off";

        ScrollPolicy.ON = "on";
        return ScrollPolicy;
    })();
    egret.ScrollPolicy = ScrollPolicy;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ClassFactory
    * @classdesc
    * @extends egret.HashObject
    */
    var ClassFactory = (function (_super) {
        __extends(ClassFactory, _super);
        /**
        * @method egret.ClassFactory#constructor
        * @class egret.ClassFactory
        * @classdesc
        * ClassFactory 实例是一个“工厂对象”，Egret 可用其生成其他类的实例，每个实例拥有相同的属性。
        * @param generator {any} newInstance() 方法根据工厂对象生成对象时使用的 Class。
        */
        function ClassFactory(generator) {
            if (typeof generator === "undefined") { generator = null; }
            _super.call(this);
            this.generator = generator;
        }
        /**
        * 生产一个新的实例
        * @method egret.egret#newInstance
        * @returns {any}
        */
        ClassFactory.prototype.newInstance = function () {
            var instance = new this.generator();
            return instance;
        };
        return ClassFactory;
    })(egret.HashObject);
    egret.ClassFactory = ClassFactory;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.OverrideBase
    * @classdesc
    * OverrideBase 类是视图状态所用的 override 类的基类。
    * @extends egret.HashObject
    * @implements egret.IOverride
    */
    var OverrideBase = (function (_super) {
        __extends(OverrideBase, _super);
        /**
        * @method egret.OverrideBase#constructor
        */
        function OverrideBase() {
            _super.call(this);
        }
        /**
        * @method egret.OverrideBase#initialize
        * @param parent {IStateClient}
        */
        OverrideBase.prototype.initialize = function (parent) {
        };

        /**
        * @method egret.OverrideBase#apply
        * @param parent {IContainer}
        */
        OverrideBase.prototype.apply = function (parent) {
        };

        /**
        * @method egret.OverrideBase#remove
        * @param parent {IContainer}
        */
        OverrideBase.prototype.remove = function (parent) {
            if (parent === null) {
            }
        };

        /**
        * 从对象初始化，这是一个便利方法
        * @method egret.OverrideBase#initializeFromObject
        * @param properties {any}
        * @returns {any}
        */
        OverrideBase.prototype.initializeFromObject = function (properties) {
            for (var p in properties) {
                this[p] = properties[p];
            }
            return this;
        };
        return OverrideBase;
    })(egret.HashObject);
    egret.OverrideBase = OverrideBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.AddItems
    * @classdesc
    * 添加显示元素
    * @extends egret.OverrideBase
    */
    var AddItems = (function (_super) {
        __extends(AddItems, _super);
        /**
        * 构造函数
        * @method egret.AddItems#constructor
        */
        function AddItems(target, propertyName, position, relativeTo) {
            _super.call(this);
            /**
            * 要添加到的属性
            * @member egret.AddItems#propertyName
            */
            this.propertyName = "";
            /**
            * 添加的位置
            * @member egret.AddItems#position
            */
            this.position = AddItems.LAST;
            this.target = target;
            this.propertyName = propertyName;
            this.position = position;
            this.relativeTo = relativeTo;
        }
        /**
        * @method egret.AddItems#initialize
        * @param parent {IStateClient}
        */
        AddItems.prototype.initialize = function (parent) {
            var targetElement = (parent[this.target]);
            if (!targetElement || targetElement instanceof egret.SkinnableComponent)
                return;

            //让UIAsset等素材组件立即开始初始化，防止延迟闪一下或首次点击失效的问题。
            if ("_initialize" in targetElement) {
                try  {
                    targetElement["_initialize"]();
                } catch (e) {
                }
            }
        };

        /**
        * @method egret.AddItems#apply
        * @param parent {IContainer}
        */
        AddItems.prototype.apply = function (parent) {
            var index;
            var relative;
            try  {
                relative = (parent[this.relativeTo]);
            } catch (e) {
            }
            var targetElement = (parent[this.target]);
            var dest = (this.propertyName ? parent[this.propertyName] : parent);
            if (!targetElement || !dest)
                return;
            switch (this.position) {
                case AddItems.FIRST:
                    index = 0;
                    break;
                case AddItems.LAST:
                    index = -1;
                    break;
                case AddItems.BEFORE:
                    index = dest.getElementIndex(relative);
                    break;
                case AddItems.AFTER:
                    index = dest.getElementIndex(relative) + 1;
                    break;
            }
            if (index == -1)
                index = dest.numElements;
            dest.addElementAt(targetElement, index);
        };

        /**
        * @method egret.AddItems#remove
        * @param parent {IContainer}
        */
        AddItems.prototype.remove = function (parent) {
            var dest = this.propertyName == null || this.propertyName == "" ? parent : parent[this.propertyName];
            var targetElement = (parent[this.target]);
            if (!targetElement || !dest)
                return;
            if (dest.getElementIndex(targetElement) != -1) {
                dest.removeElement(targetElement);
            }
        };
        AddItems.FIRST = "first";

        AddItems.LAST = "last";

        AddItems.BEFORE = "before";

        AddItems.AFTER = "after";
        return AddItems;
    })(egret.OverrideBase);
    egret.AddItems = AddItems;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SetProperty
    * @classdesc
    * 设置属性
    * @extends egret.OverrideBase
    */
    var SetProperty = (function (_super) {
        __extends(SetProperty, _super);
        /**
        * 构造函数
        * @method egret.SetProperty#constructor
        */
        function SetProperty(target, name, value) {
            _super.call(this);
            this.target = target;
            this.name = name;
            this.value = value;
        }
        /**
        * @method egret.SetProperty#apply
        * @param parent {IContainer}
        */
        SetProperty.prototype.apply = function (parent) {
            var obj = this.target == null || this.target == "" ? parent : parent[this.target];
            if (obj == null)
                return;
            this.oldValue = obj[this.name];
            this.setPropertyValue(obj, this.name, this.value, this.oldValue);
        };

        /**
        * @method egret.SetProperty#remove
        * @param parent {IContainer}
        */
        SetProperty.prototype.remove = function (parent) {
            var obj = this.target == null || this.target == "" ? parent : parent[this.target];
            if (obj == null)
                return;
            this.setPropertyValue(obj, this.name, this.oldValue, this.oldValue);
            this.oldValue = null;
        };

        /**
        * 设置属性值
        */
        SetProperty.prototype.setPropertyValue = function (obj, name, value, valueForType) {
            if (value === undefined || value === null)
                obj[name] = value;
            else if (typeof (valueForType) == "boolean")
                obj[name] = this.toBoolean(value);
            else
                obj[name] = value;
        };

        /**
        * 转成Boolean值
        */
        SetProperty.prototype.toBoolean = function (value) {
            if (typeof (value) == "string")
                return value.toLowerCase() == "true";

            return value != false;
        };
        return SetProperty;
    })(egret.OverrideBase);
    egret.SetProperty = SetProperty;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.State
    * @classdesc
    * State 类定义视图状态，即组件的特定视图。
    * @extends egret.HashObject
    */
    var State = (function (_super) {
        __extends(State, _super);
        /**
        * @method egret.State#constructor
        * @param properties {any}
        */
        function State(name, overrides) {
            _super.call(this);
            /**
            * 已经初始化标志
            */
            this.initialized = false;
            this.name = name;
            this.overrides = overrides;
        }
        /**
        * 初始化视图
        * @method egret.State#initialize
        * @param parent {IStateClient}
        */
        State.prototype.initialize = function (parent) {
            if (!this.initialized) {
                this.initialized = true;
                for (var i = 0; i < this.overrides.length; i++) {
                    (this.overrides[i]).initialize(parent);
                }
            }
        };
        return State;
    })(egret.HashObject);
    egret.State = State;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.LayoutUtil
    * @classdesc
    * 布局工具类
    */
    var LayoutUtil = (function () {
        function LayoutUtil() {
        }
        /**
        * 根据对象当前的xy坐标调整其相对位置属性，使其在下一次的父级布局中过程中保持当前位置不变。
        * @method egret.LayoutUtil.adjustRelativeByXY
        * @param element {IVisualElement} 要调整相对位置属性的对象
        * @param parent {DisplayObjectContainer} element的父级容器。若不设置，则取element.parent的值。若两者的值都为空，则放弃调整。
        */
        LayoutUtil.adjustRelativeByXY = function (element, parent) {
            if (typeof parent === "undefined") { parent = null; }
            if (!element)
                return;
            if (!parent)
                parent = element.parent;
            if (!parent)
                return;
            var x = element.x;
            var y = element.y;
            var h = element.layoutBoundsHeight;
            var w = element.layoutBoundsWidth;
            var parentW = parent.width;
            var parentH = parent.height;
            if (!isNaN(element.left)) {
                element.left = x;
            }
            if (!isNaN(element.right)) {
                element.right = parentW - x - w;
            }
            if (!isNaN(element.horizontalCenter)) {
                element.horizontalCenter = x + w * 0.5 - parentW * 0.5;
            }

            if (!isNaN(element.top)) {
                element.top = y;
            }
            if (!isNaN(element.bottom)) {
                element.bottom = parentH - y - h;
            }
            if (!isNaN(element.verticalCenter)) {
                element.verticalCenter = h * 0.5 - parentH * 0.5 + y;
            }
        };
        return LayoutUtil;
    })();
    egret.LayoutUtil = LayoutUtil;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.UIAsset
    * @classdesc
    * 素材包装器。<p/>
    * 注意：UIAsset仅在添content时测量一次初始尺寸， 请不要在外部直接修改content尺寸，
    * 若做了引起content尺寸发生变化的操作, 需手动调用UIAsset的invalidateSize()进行重新测量。
    * @extends egret.UIComponent
    * @implements egret.ISkinnableClient
    */
    var UIAsset = (function (_super) {
        __extends(UIAsset, _super);
        /**
        * @method egret.UIAsset#constructor
        * @param source {any} 素材标识符
        */
        function UIAsset(source, autoScale) {
            if (typeof autoScale === "undefined") { autoScale = true; }
            _super.call(this);
            /**
            * 确定位图填充尺寸的方式。默认值：BitmapFillMode.SCALE。
            * 设置为 BitmapFillMode.REPEAT时，位图将重复以填充区域。
            * 设置为 BitmapFillMode.SCALE时，位图将拉伸以填充区域。
            * 注意:此属性仅在source的解析结果为Texture时有效
            * @member {egret.Texture} egret.UIAsset#fillMode
            */
            this.fillMode = "scale";
            this.sourceChanged = false;
            this.createChildrenCalled = false;
            this.contentReused = false;
            /**
            * 是自动否缩放content对象，以符合UIAsset的尺寸。默认值true。
            */
            this.autoScale = true;
            this.touchChildren = false;
            if (source) {
                this.source = source;
            }
            this.autoScale = autoScale;
        }
        Object.defineProperty(UIAsset.prototype, "source", {
            /**
            * 素材标识符。可以为Class,String,或DisplayObject实例等任意类型，具体规则由项目注入的素材适配器决定，
            * 适配器根据此属性值解析获取对应的显示对象，并赋值给content属性。
            * @member egret.UIAsset#source
            */
            get: function () {
                return this._source;
            },
            set: function (value) {
                if (this._source == value)
                    return;
                this._source = value;
                if (this.createChildrenCalled) {
                    this.parseSource();
                } else {
                    this.sourceChanged = true;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIAsset.prototype, "content", {
            /**
            * 解析source得到的对象，通常为显示对象或Texture。
            * @member egret.UIAsset#content
            */
            get: function () {
                return this._content;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.UIAsset#createChildren
        */
        UIAsset.prototype.createChildren = function () {
            _super.prototype.createChildren.call(this);
            if (this.sourceChanged) {
                this.parseSource();
            }
            this.createChildrenCalled = true;
        };

        /**
        * 解析source
        */
        UIAsset.prototype.parseSource = function () {
            this.sourceChanged = false;
            var adapter = UIAsset.assetAdapter;
            if (!adapter) {
                adapter = this.getAdapter();
            }
            if (!this._source) {
                this.contentChanged(null, null);
            } else {
                var reuseContent = this.contentReused ? null : this._content;
                this.contentReused = true;
                adapter.getAsset(this._source, this.contentChanged, this, reuseContent);
            }
        };

        /**
        * 获取资源适配器
        */
        UIAsset.prototype.getAdapter = function () {
            var adapter;
            try  {
                adapter = egret.Injector.getInstance("egret.IAssetAdapter");
            } catch (e) {
                adapter = new egret.DefaultAssetAdapter();
            }
            UIAsset.assetAdapter = adapter;
            return adapter;
        };

        /**
        * 皮肤发生改变
        */
        UIAsset.prototype.contentChanged = function (content, source) {
            if (source !== this._source)
                return;
            var oldContent = this._content;
            this._content = content;
            if (oldContent !== content) {
                if (oldContent instanceof egret.DisplayObject) {
                    this._removeFromDisplayList(oldContent);
                }
                if (content instanceof egret.DisplayObject) {
                    this._addToDisplayListAt(content, 0);
                }
            }
            if (content instanceof egret.Texture && content["scale9Grid"] instanceof egret.Rectangle) {
                this.scale9Grid = content["scale9Grid"];
            }
            this.invalidateSize();
            this.invalidateDisplayList();
            this.contentReused = false;
            if (this.hasEventListener(egret.UIEvent.CONTENT_CHANGED)) {
                egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CONTENT_CHANGED);
            }
        };

        UIAsset.prototype.measure = function () {
            _super.prototype.measure.call(this);
            var content = this._content;
            if (content instanceof egret.DisplayObject) {
                if ("preferredWidth" in content) {
                    this.measuredWidth = (content).preferredWidth;
                    this.measuredHeight = (content).preferredHeight;
                } else {
                    this.measuredWidth = content.width * content.scaleX;
                    this.measuredHeight = content.height * content.scaleY;
                }
            } else if (content instanceof egret.Texture) {
                this.measuredWidth = content._textureWidth;
                this.measuredHeight = content._textureHeight;
            }
        };

        /**
        * @method egret.UIAsset#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        UIAsset.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            var content = this._content;
            if (this.autoScale && content instanceof egret.DisplayObject) {
                if ("setLayoutBoundsSize" in content) {
                    (content).setLayoutBoundsSize(unscaledWidth, unscaledHeight);
                } else {
                    content.width = unscaledWidth / content.scaleX;
                    content.height = unscaledHeight / content.scaleY;
                }
            }
        };

        UIAsset.prototype._render = function (renderContext) {
            if (this._content instanceof egret.Texture) {
                var texture = this._content;
                this._texture_to_render = texture;
                var w;
                var h;
                if (this.autoScale) {
                    w = this._width;
                    h = this._height;
                } else {
                    w = texture.textureWidth;
                    h = texture.textureHeight;
                }
                egret.Bitmap._drawBitmap(renderContext, w, h, this);
            } else {
                this._texture_to_render = null;
            }
            _super.prototype._render.call(this, renderContext);
        };

        /**
        * @see egret.DisplayObject.measureBounds
        * @returns {Rectangle}
        * @private
        */
        UIAsset.prototype._measureBounds = function () {
            var bounds = _super.prototype._measureBounds.call(this);
            if (this._content instanceof egret.Texture) {
                var texture = this._content;
                var textureW = texture._textureWidth;
                var textureH = texture._textureHeight;
                var w = this.width;
                var h = this.height;
                var x = Math.floor(texture._offsetX * w / textureW);
                var y = Math.floor(texture._offsetY * h / textureH);
                if (x < bounds.x) {
                    bounds.x = x;
                }
                if (y < bounds.y) {
                    bounds.y = y;
                }
                if (x + w > bounds.right) {
                    bounds.right = x + w;
                }
                if (y + h > bounds.bottom) {
                    bounds.bottom = y + h;
                }
            }
            return bounds;
        };

        /**
        * @method egret.UIAsset#addChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        UIAsset.prototype.addChild = function (child) {
            throw (new Error("addChild()" + UIAsset.errorStr + "addElement()代替"));
        };

        /**
        * @method egret.UIAsset#addChildAt
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        * @returns {DisplayObject}
        */
        UIAsset.prototype.addChildAt = function (child, index) {
            throw (new Error("addChildAt()" + UIAsset.errorStr + "addElementAt()代替"));
        };

        /**
        * @method egret.UIAsset#removeChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        UIAsset.prototype.removeChild = function (child) {
            throw (new Error("removeChild()" + UIAsset.errorStr + "removeElement()代替"));
        };

        /**
        * @method egret.UIAsset#removeChildAt
        * @deprecated
        * @param index {number}
        * @returns {DisplayObject}
        */
        UIAsset.prototype.removeChildAt = function (index) {
            throw (new Error("removeChildAt()" + UIAsset.errorStr + "removeElementAt()代替"));
        };

        /**
        * @method egret.UIAsset#setChildIndex
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        */
        UIAsset.prototype.setChildIndex = function (child, index) {
            throw (new Error("setChildIndex()" + UIAsset.errorStr + "setElementIndex()代替"));
        };

        /**
        * @method egret.UIAsset#swapChildren
        * @deprecated
        * @param child1 {DisplayObject}
        * @param child2 {DisplayObject}
        */
        UIAsset.prototype.swapChildren = function (child1, child2) {
            throw (new Error("swapChildren()" + UIAsset.errorStr + "swapElements()代替"));
        };

        /**
        * @method egret.UIAsset#swapChildrenAt
        * @deprecated
        * @param index1 {number}
        * @param index2 {number}
        */
        UIAsset.prototype.swapChildrenAt = function (index1, index2) {
            throw (new Error("swapChildrenAt()" + UIAsset.errorStr + "swapElementsAt()代替"));
        };
        UIAsset.errorStr = "在此组件中不可用，若此组件为容器类，请使用";
        return UIAsset;
    })(egret.UIComponent);
    egret.UIAsset = UIAsset;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SkinnableComponent
    * @classdesc
    * 复杂可设置外观组件的基类，接受ISkin类或任何显示对象作为皮肤。
    * 当皮肤为ISkin时，将自动匹配两个实例内同名的公开属性(显示对象)，
    * 并将皮肤的属性引用赋值到此类定义的同名属性(必须没有默认值)上,
    * 如果要对公共属性添加事件监听或其他操作，
    * 请覆盖partAdded()和partRemoved()方法
    * @extends egret.SkinnableComponent
    */
    var SkinnableComponent = (function (_super) {
        __extends(SkinnableComponent, _super);
        /**
        * 构造函数
        * @method egret.SkinnableComponent#constructor
        */
        function SkinnableComponent() {
            _super.call(this);
            /**
            * 主机组件标识符。用于唯一确定一个组件的名称。
            * 在解析skinName时，会把此属性的值传递给ISkinAdapter.getSkin()方法，以参与皮肤解析的规则判断。
            * 用户自定义的组件若不对此属性赋值，将会继承父级的标识符定义。
            * @member {string} egret.SkinnableComponent#hostComponentKey
            */
            this.hostComponentKey = "egret.SkinnableComponent";
            /**
            * 外部显式设置了皮肤名
            */
            this._skinNameExplicitlySet = false;
            this.createChildrenCalled = false;
            //========================皮肤视图状态=====================start=======================
            this.stateIsDirty = false;
            this._autoMouseEnabled = true;
            /**
            * 外部显式设置的mouseChildren属性值
            */
            this.explicitMouseChildren = true;
            /**
            * 外部显式设置的mouseEnabled属性值
            */
            this.explicitMouseEnabled = true;
        }
        Object.defineProperty(SkinnableComponent.prototype, "skinName", {
            /**
            * 皮肤标识符。可以为Class,String,或DisplayObject实例等任意类型，具体规则由项目注入的素材适配器决定，
            * 适配器根据此属性值解析获取对应的显示对象，并赋值给skin属性。
            * @member egret.SkinnableComponent#skinName
            */
            get: function () {
                return this._skinName;
            },
            set: function (value) {
                if (this._skinName == value)
                    return;
                this._skinName = value;
                this._skinNameExplicitlySet = true;
                if (this.createChildrenCalled) {
                    this.parseSkinName();
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableComponent.prototype, "skin", {
            /**
            * 皮肤对象实例。
            * @member egret.SkinnableComponent#skin
            */
            get: function () {
                return this._skin;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.SkinnableComponent#createChildren
        */
        SkinnableComponent.prototype.createChildren = function () {
            _super.prototype.createChildren.call(this);
            this.parseSkinName();
            this.createChildrenCalled = true;
        };

        /**
        * 解析skinName
        */
        SkinnableComponent.prototype.parseSkinName = function () {
            var adapter = SkinnableComponent.skinAdapter;
            if (!adapter) {
                adapter = this.getSkinAdapter();
            }

            var skin = adapter.getSkin(this._skinName, this.hostComponentKey);
            var oldSkin = this._skin;
            this.detachSkin(oldSkin);
            if (oldSkin instanceof egret.DisplayObject) {
                this._removeFromDisplayList(oldSkin);
            }

            this._skin = skin;
            if (skin instanceof egret.DisplayObject) {
                this._addToDisplayListAt(this._skin, 0);
            }
            this.attachSkin(skin);
            this.invalidateSkinState();
            this.invalidateSize();
            this.invalidateDisplayList();

            if (this.hasEventListener(egret.UIEvent.SKIN_CHANGED)) {
                egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.SKIN_CHANGED);
            }
        };

        /**
        * 获取皮肤适配器
        */
        SkinnableComponent.prototype.getSkinAdapter = function () {
            var adapter;
            try  {
                adapter = egret.Injector.getInstance("egret.ISkinAdapter");
            } catch (e) {
                adapter = new egret.DefaultSkinAdapter();
            }
            SkinnableComponent.skinAdapter = adapter;
            return adapter;
        };

        /**
        * 附加皮肤
        * @method egret.SkinnableComponent#attachSkin
        * @param skin {any}
        */
        SkinnableComponent.prototype.attachSkin = function (skin) {
            if (skin && "hostComponent" in skin) {
                var newSkin = skin;
                newSkin.hostComponent = this;
                this.findSkinParts();
            }
            if (skin && "hostComponent" in skin && skin instanceof egret.DisplayObject)
                this._setSkinLayoutEnabled(false);
            else
                this._setSkinLayoutEnabled(true);
        };

        /**
        * 匹配皮肤和主机组件的公共变量，并完成实例的注入。此方法在附加皮肤时会自动执行一次。
        * 若皮肤中含有延迟实例化的子部件，在子部件实例化完成时需要从外部再次调用此方法,完成注入。
        * @method egret.SkinnableComponent#findSkinParts
        */
        SkinnableComponent.prototype.findSkinParts = function () {
            var skin = this._skin;
            if (skin && "skinParts" in skin) {
                var skinParts = skin.skinParts;
                var length = skinParts.length;
                for (var i = 0; i < length; i++) {
                    var partName = skinParts[i];
                    if ((partName in skin)) {
                        try  {
                            this[partName] = skin[partName];
                            this.partAdded(partName, skin[partName]);
                        } catch (e) {
                        }
                    }
                }
            }
        };

        /**
        * 卸载皮肤
        * @method egret.SkinnableComponent#detachSkin
        * @param skin {any}
        */
        SkinnableComponent.prototype.detachSkin = function (skin) {
            if (skin && "skinParts" in skin) {
                var skinParts = skin.skinParts;
                var length = skinParts.length;
                for (var i = 0; i < length; i++) {
                    var partName = skinParts[i];
                    if (!(partName in this))
                        continue;
                    if (this[partName] != null) {
                        this.partRemoved(partName, this[partName]);
                    }
                    this[partName] = null;
                }
                skin.hostComponent = null;
            }
        };

        /**
        * 若皮肤是ISkin,则调用此方法附加皮肤中的公共部件
        * @method egret.SkinnableComponent#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        SkinnableComponent.prototype.partAdded = function (partName, instance) {
            egret.SkinPartEvent.dispatchSkinPartEvent(this, egret.SkinPartEvent.PART_ADDED, partName, instance);
        };

        /**
        * 若皮肤是ISkin，则调用此方法卸载皮肤之前注入的公共部件
        * @method egret.SkinnableComponent#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        SkinnableComponent.prototype.partRemoved = function (partName, instance) {
            egret.SkinPartEvent.dispatchSkinPartEvent(this, egret.SkinPartEvent.PART_REMOVED, partName, instance);
        };

        /**
        * 标记当前需要重新验证皮肤状态
        * @method egret.SkinnableComponent#invalidateSkinState
        */
        SkinnableComponent.prototype.invalidateSkinState = function () {
            if (this.stateIsDirty)
                return;

            this.stateIsDirty = true;
            this.invalidateProperties();
        };

        /**
        * 子类覆盖此方法,应用当前的皮肤状态
        * @method egret.SkinnableComponent#validateSkinState
        */
        SkinnableComponent.prototype.validateSkinState = function () {
            var curState = this.getCurrentSkinState();
            var skin = this._skin;
            if (skin && "currentState" in skin) {
                skin.currentState = curState;
            }
            if (this.hasEventListener("stateChanged"))
                this.dispatchEventWith("stateChanged");
        };

        Object.defineProperty(SkinnableComponent.prototype, "autoTouchEnabled", {
            /**
            * 在enabled属性发生改变时是否自动开启或禁用鼠标事件的响应。默认值为true。
            * @member egret.SkinnableComponent#autoTouchEnabled
            */
            get: function () {
                return this._autoMouseEnabled;
            },
            set: function (value) {
                if (this._autoMouseEnabled == value)
                    return;
                this._autoMouseEnabled = value;
                if (this._autoMouseEnabled) {
                    this._touchChildren = this.enabled ? this.explicitMouseChildren : false;
                    this._touchEnabled = this.enabled ? this.explicitMouseEnabled : false;
                } else {
                    this._touchChildren = this.explicitMouseChildren;
                    this._touchEnabled = this.explicitMouseEnabled;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableComponent.prototype, "touchChildren", {
            /**
            * @member egret.SkinnableComponent#touchChildren
            */
            get: function () {
                return this._touchChildren;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this.enabled)
                    this._touchChildren = value;
                this.explicitMouseChildren = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableComponent.prototype, "touchEnabled", {
            /**
            * @member egret.SkinnableComponent#touchEnabled
            */
            get: function () {
                return this._touchEnabled;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this.enabled)
                    this._touchEnabled = value;
                this.explicitMouseEnabled = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableComponent.prototype, "enabled", {
            /**
            * @member egret.SkinnableComponent#enabled
            */
            get: function () {
                return this._enabled;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });


        SkinnableComponent.prototype._setEnabled = function (value) {
            if (this._enabled == value)
                return;
            this._enabled = value;
            if (this._autoMouseEnabled) {
                this._touchChildren = value ? this.explicitMouseChildren : false;
                this._touchEnabled = value ? this.explicitMouseEnabled : false;
            }
            this.invalidateSkinState();
        };

        /**
        * 返回组件当前的皮肤状态名称,子类覆盖此方法定义各种状态名
        * @method egret.SkinnableComponent#getCurrentSkinState
        * @returns {string}
        */
        SkinnableComponent.prototype.getCurrentSkinState = function () {
            return this.enabled ? "normal" : "disabled";
        };

        //========================皮肤视图状态===================end========================
        /**
        * @method egret.SkinnableComponent#commitProperties
        */
        SkinnableComponent.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);
            if (this.stateIsDirty) {
                this.stateIsDirty = false;
                this.validateSkinState();
            }
        };

        /**
        * 启用或禁用组件自身的布局。通常用在当组件的皮肤不是ISkinPartHost，又需要自己创建子项并布局时。
        */
        SkinnableComponent.prototype._setSkinLayoutEnabled = function (value) {
            var hasLayout = (this.skinLayout != null);
            if (hasLayout == value)
                return;
            if (value) {
                this.skinLayout = new egret.SkinBasicLayout();
                this.skinLayout.target = this;
            } else {
                this.skinLayout.target = null;
                this.skinLayout = null;
            }
            this.invalidateSize();
            this.invalidateDisplayList();
        };

        SkinnableComponent.prototype._childXYChanged = function () {
            if (this.skinLayout) {
                this.invalidateSize();
                this.invalidateDisplayList();
            }
        };

        SkinnableComponent.prototype.measure = function () {
            _super.prototype.measure.call(this);
            var skin = this._skin;
            if (!skin)
                return;
            var isDisplayObject = (skin instanceof egret.DisplayObject);
            if (isDisplayObject) {
                if (skin && "preferredWidth" in skin) {
                    this.measuredWidth = (skin).preferredWidth;
                    this.measuredHeight = (skin).preferredHeight;
                } else {
                    this.measuredWidth = skin.width;
                    this.measuredHeight = skin.height;
                }
            }
            if (this.skinLayout) {
                this.skinLayout.measure();
            }
            if (!isDisplayObject) {
                var measuredW = this.measuredWidth;
                var measuredH = this.measuredHeight;
                try  {
                    if (!isNaN(skin.width))
                        measuredW = Math.ceil(skin.width);
                    if (!isNaN(skin.height))
                        measuredH = Math.ceil(skin.height);
                    if (skin.hasOwnProperty("minWidth") && measuredW < skin.minWidth) {
                        measuredW = skin.minWidth;
                    }
                    if (skin.hasOwnProperty("maxWidth") && measuredW > skin.maxWidth) {
                        measuredW = skin.maxWidth;
                    }
                    if (skin.hasOwnProperty("minHeight") && measuredH < skin.minHeight) {
                        measuredH = skin.minHeight;
                    }
                    if (skin.hasOwnProperty("maxHeight") && measuredH > skin.maxHeight) {
                        measuredH = skin.maxHeight;
                    }
                    this.measuredWidth = measuredW;
                    this.measuredHeight = measuredH;
                } catch (e) {
                }
            }
        };

        /**
        * @method egret.SkinnableComponent#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        SkinnableComponent.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            var skin = this._skin;
            if (skin) {
                if ("setLayoutBoundsSize" in skin) {
                    (skin).setLayoutBoundsSize(unscaledWidth, unscaledHeight);
                } else if (skin instanceof egret.DisplayObject) {
                    skin.scaleX = skin.width == 0 ? 1 : unscaledWidth / skin.width;
                    skin.scaleY = skin.height == 0 ? 1 : unscaledHeight / skin.height;
                }
            }
            if (this.skinLayout) {
                this.skinLayout.updateDisplayList(unscaledWidth, unscaledHeight);
            }
        };

        /**
        * @method egret.SkinnableComponent#addChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        SkinnableComponent.prototype.addChild = function (child) {
            throw (new Error("addChild()" + SkinnableComponent.errorStr + "addElement()代替"));
        };

        /**
        * @method egret.SkinnableComponent#addChildAt
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        * @returns {DisplayObject}
        */
        SkinnableComponent.prototype.addChildAt = function (child, index) {
            throw (new Error("addChildAt()" + SkinnableComponent.errorStr + "addElementAt()代替"));
        };

        /**
        * @method egret.SkinnableComponent#removeChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        SkinnableComponent.prototype.removeChild = function (child) {
            throw (new Error("removeChild()" + SkinnableComponent.errorStr + "removeElement()代替"));
        };

        /**
        * @method egret.SkinnableComponent#removeChildAt
        * @deprecated
        * @param index {number}
        * @returns {DisplayObject}
        */
        SkinnableComponent.prototype.removeChildAt = function (index) {
            throw (new Error("removeChildAt()" + SkinnableComponent.errorStr + "removeElementAt()代替"));
        };

        /**
        * @method egret.SkinnableComponent#setChildIndex
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        */
        SkinnableComponent.prototype.setChildIndex = function (child, index) {
            throw (new Error("setChildIndex()" + SkinnableComponent.errorStr + "setElementIndex()代替"));
        };

        /**
        * @method egret.SkinnableComponent#swapChildren
        * @deprecated
        * @param child1 {DisplayObject}
        * @param child2 {DisplayObject}
        */
        SkinnableComponent.prototype.swapChildren = function (child1, child2) {
            throw (new Error("swapChildren()" + SkinnableComponent.errorStr + "swapElements()代替"));
        };

        /**
        * @method egret.SkinnableComponent#swapChildrenAt
        * @deprecated
        * @param index1 {number}
        * @param index2 {number}
        */
        SkinnableComponent.prototype.swapChildrenAt = function (index1, index2) {
            throw (new Error("swapChildrenAt()" + SkinnableComponent.errorStr + "swapElementsAt()代替"));
        };
        SkinnableComponent.errorStr = "在此组件中不可用，若此组件为容器类，请使用";
        return SkinnableComponent;
    })(egret.UIComponent);
    egret.SkinnableComponent = SkinnableComponent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.DefaultSkinAdapter
    * @classdesc
    * 默认的ISkinAdapter接口实现
    * @implements egret.ISkinAdapter
    */
    var DefaultSkinAdapter = (function () {
        /**
        * 构造函数
        * @method egret.DefaultSkinAdapter#constructor
        */
        function DefaultSkinAdapter() {
        }
        /**
        * 获取皮肤显示对象
        * @method egret.ISkinAdapter#getSkin
        * @param skinName {any} 待解析的皮肤标识符
        * @param hostComponentKey {string} 主机组件标识符
        * @returns {any} 皮肤对象实例
        */
        DefaultSkinAdapter.prototype.getSkin = function (skinName, hostComponentKey) {
            if (!skinName)
                return null;
            if (skinName.prototype) {
                return new skinName();
            } else if (typeof (skinName) == "string") {
                var clazz = egret.getDefinitionByName(skinName);
                if (clazz) {
                    return new clazz();
                } else {
                    return null;
                }
            } else {
                return skinName;
            }
        };
        return DefaultSkinAdapter;
    })();
    egret.DefaultSkinAdapter = DefaultSkinAdapter;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.DefaultAssetAdapter
    * @classdesc
    * 默认的IAssetAdapter接口实现
    * @implements egret.IAssetAdapter
    */
    var DefaultAssetAdapter = (function () {
        /**
        * 构造函数
        * @method egret.DefaultSkinAdapter#constructor
        */
        function DefaultAssetAdapter() {
        }
        /**
        * 解析素材
        * @method egret.DefaultAssetAdapter#getAsset
        * @param source {any} 待解析的新素材标识符
        * @param compFunc {Function} 解析完成回调函数，示例：compFunc(content:any,source:any):void;
        * 回调参数content接受两种类型：DisplayObject或Texture。
        * @param thisObject {any} compFunc的this引用
        * @param oldContent any 旧的内容对象,传入值有可能为null。
        * 对于某些类型素材，例如MovieClip，可以重用传入的显示对象,只修改其数据再返回。
        */
        DefaultAssetAdapter.prototype.getAsset = function (source, compFunc, thisObject, oldContent) {
            var content = source;
            if (source.prototype) {
                content = new source();
            }
            if (content instanceof egret.DisplayObject || content instanceof egret.Texture) {
                compFunc.call(thisObject, content, source);
            } else if (typeof (source) == "string") {
                var url = source;
                var loader = new egret.URLLoader();
                loader.dataFormat = egret.URLLoaderDataFormat.TEXTURE;
                loader.addEventListener(egret.Event.COMPLETE, function (event) {
                    content = loader.data;
                    compFunc.call(thisObject, content, source);
                }, this);
                loader.load(new egret.URLRequest(url));
            } else {
                compFunc.call(thisObject, content, source);
            }
        };
        return DefaultAssetAdapter;
    })();
    egret.DefaultAssetAdapter = DefaultAssetAdapter;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SkinBasicLayout
    * @classdesc
    * 皮肤简单布局类。
    * @extends egret.HashObject
    */
    var SkinBasicLayout = (function (_super) {
        __extends(SkinBasicLayout, _super);
        /**
        * @method egret.SkinBasicLayout#constructor
        */
        function SkinBasicLayout() {
            _super.call(this);
        }
        Object.defineProperty(SkinBasicLayout.prototype, "target", {
            /**
            * 目标布局对象
            * @member egret.SkinBasicLayout#target
            */
            get: function () {
                return this._target;
            },
            set: function (value) {
                this._target = value;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 测量组件尺寸大小
        * @method egret.SkinBasicLayout#measure
        */
        SkinBasicLayout.prototype.measure = function () {
            if (this.target == null)
                return;

            var measureW = 0;
            var measureH = 0;

            var skin = this._target.skin;
            var count = this.target.numChildren;
            for (var i = 0; i < count; i++) {
                var layoutElement = this.target.getChildAt(i);
                if (!layoutElement || layoutElement == skin || !layoutElement.includeInLayout)
                    continue;

                var hCenter = layoutElement.horizontalCenter;
                var vCenter = layoutElement.verticalCenter;
                var left = layoutElement.left;
                var right = layoutElement.right;
                var top = layoutElement.top;
                var bottom = layoutElement.bottom;

                var extX;
                var extY;

                if (!isNaN(left) && !isNaN(right)) {
                    extX = left + right;
                } else if (!isNaN(hCenter)) {
                    extX = Math.abs(hCenter) * 2;
                } else if (!isNaN(left) || !isNaN(right)) {
                    extX = isNaN(left) ? 0 : left;
                    extX += isNaN(right) ? 0 : right;
                } else {
                    extX = layoutElement.preferredX;
                }

                if (!isNaN(top) && !isNaN(bottom)) {
                    extY = top + bottom;
                } else if (!isNaN(vCenter)) {
                    extY = Math.abs(vCenter) * 2;
                } else if (!isNaN(top) || !isNaN(bottom)) {
                    extY = isNaN(top) ? 0 : top;
                    extY += isNaN(bottom) ? 0 : bottom;
                } else {
                    extY = layoutElement.preferredY;
                }

                var preferredWidth = layoutElement.preferredWidth;
                var preferredHeight = layoutElement.preferredHeight;

                measureW = Math.ceil(Math.max(measureW, extX + preferredWidth));
                measureH = Math.ceil(Math.max(measureH, extY + preferredHeight));
            }

            this.target.measuredWidth = Math.max(measureW, this.target.measuredWidth);
            this.target.measuredHeight = Math.max(measureH, this.target.measuredHeight);
        };

        /**
        * 更新显示列表
        * @method egret.SkinBasicLayout#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        SkinBasicLayout.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            if (this.target == null)
                return;

            var count = this.target.numChildren;
            var skin = this._target.skin;
            for (var i = 0; i < count; i++) {
                var layoutElement = this.target.getChildAt(i);
                if (layoutElement == null || layoutElement == skin || !layoutElement.includeInLayout)
                    continue;

                var hCenter = layoutElement.horizontalCenter;
                var vCenter = layoutElement.verticalCenter;
                var left = layoutElement.left;
                var right = layoutElement.right;
                var top = layoutElement.top;
                var bottom = layoutElement.bottom;
                var percentWidth = layoutElement.percentWidth;
                var percentHeight = layoutElement.percentHeight;

                var childWidth = NaN;
                var childHeight = NaN;

                if (!isNaN(left) && !isNaN(right)) {
                    childWidth = unscaledWidth - right - left;
                } else if (!isNaN(percentWidth)) {
                    childWidth = Math.round(unscaledWidth * Math.min(percentWidth * 0.01, 1));
                }

                if (!isNaN(top) && !isNaN(bottom)) {
                    childHeight = unscaledHeight - bottom - top;
                } else if (!isNaN(percentHeight)) {
                    childHeight = Math.round(unscaledHeight * Math.min(percentHeight * 0.01, 1));
                }

                layoutElement.setLayoutBoundsSize(childWidth, childHeight);

                var elementWidth = layoutElement.layoutBoundsWidth;
                var elementHeight = layoutElement.layoutBoundsHeight;

                var childX = NaN;
                var childY = NaN;

                if (!isNaN(hCenter))
                    childX = Math.round((unscaledWidth - elementWidth) / 2 + hCenter);
                else if (!isNaN(left))
                    childX = left;
                else if (!isNaN(right))
                    childX = unscaledWidth - elementWidth - right;
                else
                    childX = layoutElement.layoutBoundsX;

                if (!isNaN(vCenter))
                    childY = Math.round((unscaledHeight - elementHeight) / 2 + vCenter);
                else if (!isNaN(top))
                    childY = top;
                else if (!isNaN(bottom))
                    childY = unscaledHeight - elementHeight - bottom;
                else
                    childY = layoutElement.layoutBoundsY;

                layoutElement.setLayoutBoundsPosition(childX, childY);
            }
        };
        return SkinBasicLayout;
    })(egret.HashObject);
    egret.SkinBasicLayout = SkinBasicLayout;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ButtonBase
    * @classdesc
    * 按钮组件基类
    * @extends egret.SkinnableComponent
    */
    var ButtonBase = (function (_super) {
        __extends(ButtonBase, _super);
        /**
        * 构造函数
        * @method egret.ButtonBase#constructor
        */
        function ButtonBase() {
            _super.call(this);
            /**
            * 已经开始过不断抛出buttonDown事件的标志
            */
            this._downEventFired = false;
            this._autoRepeat = false;
            this._repeatDelay = 35;
            this._repeatInterval = 35;
            this._hovered = false;
            this._keepDown = false;
            this._label = "";
            this._mouseCaptured = false;
            this._stickyHighlighting = false;
            this.touchChildren = false;
            this.addHandlers();
        }
        Object.defineProperty(ButtonBase.prototype, "autoRepeat", {
            /**
            * 指定在用户按住鼠标按键时是否重复分派 buttonDown 事件。
            * @member egret.ButtonBase#autoRepeat
            */
            get: function () {
                return this._autoRepeat;
            },
            set: function (value) {
                if (value == this._autoRepeat)
                    return;

                this._autoRepeat = value;
                this.checkAutoRepeatTimerConditions(this.isDown());
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ButtonBase.prototype, "repeatDelay", {
            /**
            * 在第一个 buttonDown 事件之后，以及相隔每个 repeatInterval 重复一次 buttonDown 事件之前，需要等待的毫秒数。
            * @member egret.ButtonBase#repeatDelay
            */
            get: function () {
                return this._repeatDelay;
            },
            set: function (value) {
                this._repeatDelay = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ButtonBase.prototype, "repeatInterval", {
            /**
            * 用户在按钮上按住鼠标时，buttonDown 事件之间相隔的毫秒数。
            * @member egret.ButtonBase#repeatInterval
            */
            get: function () {
                return this._repeatInterval;
            },
            set: function (value) {
                this._repeatInterval = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ButtonBase.prototype, "hovered", {
            /**
            * 指示鼠标指针是否位于按钮上。
            * @member egret.ButtonBase#hovered
            */
            get: function () {
                return this._hovered;
            },
            set: function (value) {
                if (value == this._hovered)
                    return;
                this._hovered = value;
                this.invalidateSkinState();
                this.checkButtonDownConditions();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 强制让按钮停在鼠标按下状态,此方法不会导致重复抛出buttonDown事件,仅影响皮肤State。
        * @method egret.ButtonBase#_keepDown
        * @param down {boolean} 是否按下
        */
        ButtonBase.prototype._setKeepDown = function (down) {
            if (this._keepDown == down)
                return;
            this._keepDown = down;
            this.invalidateSkinState();
        };

        Object.defineProperty(ButtonBase.prototype, "label", {
            /**
            * 要在按钮上显示的文本
            * @member egret.ButtonBase#label
            */
            get: function () {
                return this._getLabel();
            },
            set: function (value) {
                this._setLabel(value);
            },
            enumerable: true,
            configurable: true
        });

        ButtonBase.prototype._getLabel = function () {
            if (this.labelDisplay) {
                return this.labelDisplay.text;
            } else {
                return this._label;
            }
        };


        ButtonBase.prototype._setLabel = function (value) {
            this._label = value;
            if (this.labelDisplay) {
                this.labelDisplay.text = value;
            }
        };

        Object.defineProperty(ButtonBase.prototype, "mouseCaptured", {
            /**
            * 指示第一次分派 MouseEvent.MOUSE_DOWN 时，是否按下鼠标以及鼠标指针是否在按钮上。
            * @member egret.ButtonBase#mouseCaptured
            */
            get: function () {
                return this._mouseCaptured;
            },
            set: function (value) {
                if (value == this._mouseCaptured)
                    return;

                this._mouseCaptured = value;
                this.invalidateSkinState();
                if (!value)
                    this.removeStageMouseHandlers();
                this.checkButtonDownConditions();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ButtonBase.prototype, "stickyHighlighting", {
            /**
            * 如果为 false，则按钮会在用户按下它时显示其鼠标按下时的外观，但在用户将鼠标拖离它时将改为显示鼠标经过的外观。
            * 如果为 true，则按钮会在用户按下它时显示其鼠标按下时的外观，并在用户将鼠标拖离时继续显示此外观。
            * @member egret.ButtonBase#stickyHighlighting
            */
            get: function () {
                return this._stickyHighlighting;
            },
            set: function (value) {
                if (value == this._stickyHighlighting)
                    return;

                this._stickyHighlighting = value;
                this.invalidateSkinState();
                this.checkButtonDownConditions();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 开始抛出buttonDown事件
        */
        ButtonBase.prototype.checkButtonDownConditions = function () {
            var isCurrentlyDown = this.isDown();
            if (this._downEventFired != isCurrentlyDown) {
                if (isCurrentlyDown) {
                    egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.BUTTON_DOWN);
                }

                this._downEventFired = isCurrentlyDown;
                this.checkAutoRepeatTimerConditions(isCurrentlyDown);
            }
        };

        /**
        * 添加鼠标事件监听
        * @method egret.ButtonBase#addHandlers
        */
        ButtonBase.prototype.addHandlers = function () {
            this.addEventListener(egret.TouchEvent.TOUCH_ROLL_OVER, this.mouseEventHandler, this);
            this.addEventListener(egret.TouchEvent.TOUCH_ROLL_OUT, this.mouseEventHandler, this);
            this.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.mouseEventHandler, this);
            this.addEventListener(egret.TouchEvent.TOUCH_END, this.mouseEventHandler, this);
            this.addEventListener(egret.TouchEvent.TOUCH_TAP, this.mouseEventHandler, this);
        };

        /**
        * 添加舞台鼠标弹起事件监听
        */
        ButtonBase.prototype.addStageMouseHandlers = function () {
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);

            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
        };

        /**
        * 移除舞台鼠标弹起事件监听
        */
        ButtonBase.prototype.removeStageMouseHandlers = function () {
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);

            egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
        };

        /**
        * 按钮是否是按下的状态
        */
        ButtonBase.prototype.isDown = function () {
            if (!this.enabled)
                return false;

            if (this.mouseCaptured && (this.hovered || this.stickyHighlighting))
                return true;
            return false;
        };

        /**
        * 检查需要启用还是关闭重发计时器
        */
        ButtonBase.prototype.checkAutoRepeatTimerConditions = function (buttonDown) {
            var needsTimer = this.autoRepeat && buttonDown;
            var hasTimer = this.autoRepeatTimer != null;

            if (needsTimer == hasTimer)
                return;

            if (needsTimer)
                this.startTimer();
            else
                this.stopTimer();
        };

        /**
        * 启动重发计时器
        */
        ButtonBase.prototype.startTimer = function () {
            this.autoRepeatTimer = new egret.Timer(1);
            this.autoRepeatTimer.delay = this._repeatDelay;
            this.autoRepeatTimer.addEventListener(egret.TimerEvent.TIMER, this.autoRepeat_timerDelayHandler, this);
            this.autoRepeatTimer.start();
        };

        /**
        * 停止重发计时器
        */
        ButtonBase.prototype.stopTimer = function () {
            this.autoRepeatTimer.stop();
            this.autoRepeatTimer = null;
        };

        /**
        * 鼠标事件处理
        * @method egret.ButtonBase#mouseEventHandler
        * @param event {Event}
        */
        ButtonBase.prototype.mouseEventHandler = function (event) {
            var touchEvent = event;
            switch (event.type) {
                case egret.TouchEvent.TOUCH_ROLL_OVER: {
                    if (touchEvent.touchDown && !this.mouseCaptured)
                        return;
                    this.hovered = true;
                    break;
                }

                case egret.TouchEvent.TOUCH_ROLL_OUT: {
                    this.hovered = false;
                    break;
                }

                case egret.TouchEvent.TOUCH_BEGIN: {
                    this.addStageMouseHandlers();
                    if (egret.InteractionMode.mode == egret.InteractionMode.TOUCH)
                        this.hovered = true;
                    this.mouseCaptured = true;
                    break;
                }

                case egret.TouchEvent.TOUCH_END: {
                    if (event.target == this) {
                        this.hovered = true;

                        if (this.mouseCaptured) {
                            this.buttonReleased();
                            this.mouseCaptured = false;
                        }
                    }
                    break;
                }
                case egret.TouchEvent.TOUCH_TAP: {
                    if (!this.enabled)
                        event.stopImmediatePropagation();
                    else
                        this.clickHandler(event);
                    return;
                }
            }
        };

        /**
        * 按钮弹起事件
        * @method egret.ButtonBase#buttonReleased
        */
        ButtonBase.prototype.buttonReleased = function () {
        };

        /**
        * 按钮点击事件
        * @method egret.ButtonBase#clickHandler
        * @param event {TouchEvent}
        */
        ButtonBase.prototype.clickHandler = function (event) {
        };

        /**
        * 舞台上鼠标弹起事件
        */
        ButtonBase.prototype.stage_mouseUpHandler = function (event) {
            if (event.target == this)
                return;

            this.mouseCaptured = false;
        };

        /**
        * 自动重发计时器首次延迟结束事件
        */
        ButtonBase.prototype.autoRepeat_timerDelayHandler = function (event) {
            this.autoRepeatTimer.reset();
            this.autoRepeatTimer.removeEventListener(egret.TimerEvent.TIMER, this.autoRepeat_timerDelayHandler, this);

            this.autoRepeatTimer.delay = this._repeatInterval;
            this.autoRepeatTimer.addEventListener(egret.TimerEvent.TIMER, this.autoRepeat_timerHandler, this);
            this.autoRepeatTimer.start();
        };

        /**
        * 自动重发buttonDown事件
        */
        ButtonBase.prototype.autoRepeat_timerHandler = function (event) {
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.BUTTON_DOWN);
        };

        /**
        * @method egret.ButtonBase#getCurrentSkinState
        * @returns {string}
        */
        ButtonBase.prototype.getCurrentSkinState = function () {
            if (!this.enabled)
                return _super.prototype.getCurrentSkinState.call(this);

            if (this.isDown() || this._keepDown)
                return "down";

            if (egret.InteractionMode.mode == egret.InteractionMode.MOUSE && (this.hovered || this.mouseCaptured))
                return "over";

            return "up";
        };

        /**
        * @method egret.ButtonBase#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        ButtonBase.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.labelDisplay) {
                this.labelDisplay.text = this._label;
            }
        };
        return ButtonBase;
    })(egret.SkinnableComponent);
    egret.ButtonBase = ButtonBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ToggleButtonBase
    * @classdesc
    * 切换按钮组件基类
    * @extends egret.ButtonBase
    */
    var ToggleButtonBase = (function (_super) {
        __extends(ToggleButtonBase, _super);
        /**
        * @method egret.ToggleButtonBase#constructor
        */
        function ToggleButtonBase() {
            _super.call(this);
            /**
            * 是否根据鼠标事件自动变换选中状态,默认true。仅框架内使用。
            */
            this._autoSelected = true;
        }
        Object.defineProperty(ToggleButtonBase.prototype, "selected", {
            /**
            * 按钮处于按下状态时为 true，而按钮处于弹起状态时为 false。
            * @member egret.ToggleButtonBase#selected
            */
            get: function () {
                return this._selected;
            },
            set: function (value) {
                this._setSelected(value);
            },
            enumerable: true,
            configurable: true
        });


        ToggleButtonBase.prototype._setSelected = function (value) {
            if (value == this._selected)
                return;

            this._selected = value;
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);
            ;
            this.invalidateSkinState();
        };

        /**
        * @method egret.ToggleButtonBase#getCurrentSkinState
        * @returns {string}
        */
        ToggleButtonBase.prototype.getCurrentSkinState = function () {
            if (!this.selected)
                return _super.prototype.getCurrentSkinState.call(this);
            else
                return _super.prototype.getCurrentSkinState.call(this) + "AndSelected";
        };

        /**
        * @method egret.ToggleButtonBase#buttonReleased
        */
        ToggleButtonBase.prototype.buttonReleased = function () {
            _super.prototype.buttonReleased.call(this);
            if (!this._autoSelected || !this.enabled)
                return;
            this.selected = !this.selected;
            this.dispatchEventWith(egret.Event.CHANGE);
        };
        return ToggleButtonBase;
    })(egret.ButtonBase);
    egret.ToggleButtonBase = ToggleButtonBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TextBase
    * @classdesc
    * 文本基类,实现对文本的自动布局，样式属性设置。
    * @extends egret.UIComponent
    * @implements egret.IDisplayText
    */
    var TextBase = (function (_super) {
        __extends(TextBase, _super);
        /**
        * @method egret.TextBase#constructor
        */
        function TextBase() {
            _super.call(this);
            this._fontFamily = "SimSun";
            this._size = 30;
            this._textAlign = egret.HorizontalAlign.LEFT;
            this._verticalAlign = egret.VerticalAlign.TOP;
            this._lineSpacing = 0;
            this._textColor = 0xFFFFFF;
            this._text = "";
        }
        Object.defineProperty(TextBase.prototype, "fontFamily", {
            /**
            * 字体名称 。默认值：SimSun
            * @member egret.TextBase#fontFamily
            */
            get: function () {
                return this._fontFamily;
            },
            set: function (value) {
                if (this._fontFamily == value)
                    return;
                this._fontFamily = value;
                this.fontFamilyChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "size", {
            /**
            * 字号大小,默认值30 。
            * @member egret.TextBase#size
            */
            get: function () {
                return this._size;
            },
            set: function (value) {
                if (this._size == value)
                    return;
                this._size = value;
                this.sizeChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "bold", {
            /**
            * 是否显示为粗体，默认false。
            * @member egret.TextBase#bold
            */
            get: function () {
                return this._bold;
            },
            set: function (value) {
                if (this._bold == value)
                    return;
                this._bold = value;
                this.boldChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "italic", {
            /**
            * 是否显示为粗体，默认false。
            * @member egret.TextBase#italic
            */
            get: function () {
                return this._italic;
            },
            set: function (value) {
                if (this._italic == value)
                    return;
                this._italic = value;
                this.italicChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "textAlign", {
            /**
            * 文字的水平对齐方式 ,请使用TextAlign中定义的常量。
            * 默认值：TextFormatAlign.LEFT。
            * @member egret.TextBase#textAlign
            */
            get: function () {
                return this._textAlign;
            },
            set: function (value) {
                if (this._textAlign == value)
                    return;
                this._textAlign = value;
                this.textAlignChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "verticalAlign", {
            /**
            * 文字的垂直对齐方式 ,请使用VerticalAlign中定义的常量。
            * 默认值：VerticalAlign.TOP。
            * @member egret.TextBase#verticalAlign
            */
            get: function () {
                return this._verticalAlign;
            },
            set: function (value) {
                if (this._verticalAlign == value)
                    return;
                this._verticalAlign = value;
                this.verticalAlignChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "lineSpacing", {
            /**
            * 行间距
            * @member egret.TextBase#lineSpacing
            */
            get: function () {
                return this._lineSpacing;
            },
            set: function (value) {
                if (this._lineSpacing == value)
                    return;
                this._lineSpacing = value;
                this.lineSpacingChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "textColor", {
            /**
            * @member egret.TextBase#textColor
            */
            get: function () {
                return this._textColor;
            },
            set: function (value) {
                if (this._textColor == value)
                    return;
                this._textColor = value;
                this.textColorChanged = true;
                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TextBase.prototype, "text", {
            /**
            * @member egret.TextBase#text
            */
            get: function () {
                return this._text;
            },
            set: function (value) {
                if (value == this._text)
                    return;
                this._text = value;
                this._textChanged = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.TextBase#createChildren
        */
        TextBase.prototype.createChildren = function () {
            _super.prototype.createChildren.call(this);

            if (!this._textField) {
                this.checkTextField();
            }
        };

        /**
        * @method egret.TextBase#commitProperties
        */
        TextBase.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);

            if (!this._textField) {
                this.checkTextField();
            }

            if (this.fontFamilyChanged) {
                this._textField.fontFamily = this._fontFamily;
                this.fontFamilyChanged = false;
            }
            if (this.sizeChanged) {
                this._textField.size = this._size;
                this.sizeChanged = false;
            }
            if (this.boldChanged) {
                this._textField.bold = this._bold;
                this.boldChanged = false;
            }
            if (this.italic) {
                this._textField.italic = this._italic;
                this.italicChanged = false;
            }
            if (this.textAlignChanged) {
                this._textField.textAlign = this._textAlign;
                this.textAlignChanged = false;
            }
            if (this.verticalAlignChanged) {
                this._textField.verticalAlign = this._verticalAlign;
                this.verticalAlignChanged = false;
            }
            if (this.lineSpacingChanged) {
                this._textField.lineSpacing = this._lineSpacing;
                this.lineSpacingChanged = false;
            }
            if (this.textColorChanged) {
                this._textField.textColor = this._textColor;
                this.textColorChanged = false;
            }
            if (this._textChanged) {
                this._textField.text = this._text;
                this._textChanged = false;
            }
        };

        /**
        * 检查是否创建了textField对象，没有就创建一个。
        */
        TextBase.prototype.checkTextField = function () {
            if (!this._textField) {
                this.createTextField();
                this._textField.text = this._text;
                this._textChanged = true;
                this.invalidateProperties();
            }
        };

        TextBase.prototype.createTextField = function () {
            this._textField = new egret.TextField;
            this._textField.fontFamily = this._fontFamily;
            this._textField.size = this._size;
            this._textField.textAlign = this._textAlign;
            this._textField.verticalAlign = this._verticalAlign;
            this._textField.lineSpacing = this._lineSpacing;
            this._textField.textColor = this._textColor;
            this._addToDisplayList(this._textField);
        };

        /**
        * @method egret.TextBase#measure
        */
        TextBase.prototype.measure = function () {
            _super.prototype.measure.call(this);

            this.measuredWidth = TextBase.DEFAULT_MEASURED_WIDTH;
            this.measuredHeight = TextBase.DEFAULT_MEASURED_HEIGHT;
        };

        /**
        * 更新显示列表
        * @method egret.TextBase#$updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        TextBase.prototype.$updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        };

        /**
        * @method egret.TextBase#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        TextBase.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            this._textField.width = unscaledWidth;
            this._textField.height = unscaledHeight;
        };
        TextBase.DEFAULT_MEASURED_WIDTH = 160;

        TextBase.DEFAULT_MEASURED_HEIGHT = 22;
        return TextBase;
    })(egret.UIComponent);
    egret.TextBase = TextBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.GroupBase
    * @classdesc
    * 自动布局容器基类
    * @extends egret.UIComponent
    * @implements egret.IViewport
    */
    var GroupBase = (function (_super) {
        __extends(GroupBase, _super);
        /**
        * @method egret.GroupBase#constructor
        */
        function GroupBase() {
            _super.call(this);
            this._contentWidth = 0;
            this._contentHeight = 0;
            this._clipAndEnableScrolling = false;
            this._horizontalScrollPosition = 0;
            this._verticalScrollPosition = 0;
            /**
            * 在更新显示列表时是否需要更新布局标志
            * @member egret.GroupBase#_layoutInvalidateDisplayListFlag
            */
            this._layoutInvalidateDisplayListFlag = false;
            /**
            * 在测量尺寸时是否需要测量布局的标志
            * @member egret.GroupBase#_layoutInvalidateSizeFlag
            */
            this._layoutInvalidateSizeFlag = false;
            this.touchEnabled = false;
        }
        /**
        * @method egret.GroupBase#createChildren
        */
        GroupBase.prototype.createChildren = function () {
            _super.prototype.createChildren.call(this);
            if (!this._layout) {
                this.layout = new egret.BasicLayout;
            }
        };

        Object.defineProperty(GroupBase.prototype, "contentWidth", {
            /**
            * @member egret.GroupBase#contentWidth
            */
            get: function () {
                return this._contentWidth;
            },
            enumerable: true,
            configurable: true
        });

        GroupBase.prototype.setContentWidth = function (value) {
            if (value == this._contentWidth)
                return;
            var oldValue = this._contentWidth;
            this._contentWidth = value;
            if (this.hasEventListener("propertyChange"))
                egret.PropertyChangeEvent.dispatchPropertyChangeEvent(this, egret.PropertyChangeEventKind.UPDATE, "contentWidth", oldValue, value, this);
        };

        Object.defineProperty(GroupBase.prototype, "contentHeight", {
            /**
            * @member egret.GroupBase#contentHeight
            */
            get: function () {
                return this._contentHeight;
            },
            enumerable: true,
            configurable: true
        });

        GroupBase.prototype.setContentHeight = function (value) {
            if (value == this._contentHeight)
                return;
            var oldValue = this._contentHeight;
            this._contentHeight = value;
            if (this.hasEventListener("propertyChange"))
                egret.PropertyChangeEvent.dispatchPropertyChangeEvent(this, egret.PropertyChangeEventKind.UPDATE, "contentHeight", oldValue, value, this);
        };

        /**
        * 设置 contentWidth 和 contentHeight 属性，此方法由Layout类调用
        * @method egret.GroupBase#setContentSize
        * @private
        *
        * @param width {number}
        * @param height {number}
        */
        GroupBase.prototype.setContentSize = function (width, height) {
            if ((width == this._contentWidth) && (height == this._contentHeight))
                return;
            this.setContentWidth(width);
            this.setContentHeight(height);
        };

        Object.defineProperty(GroupBase.prototype, "layout", {
            /**
            * 此容器的布局对象
            * @member egret.GroupBase#layout
            */
            get: function () {
                return this._layout;
            },
            set: function (value) {
                this._setLayout(value);
            },
            enumerable: true,
            configurable: true
        });


        GroupBase.prototype._setLayout = function (value) {
            if (this._layout == value)
                return;
            if (this._layout) {
                this._layout.target = null;
            }

            this._layout = value;

            if (this._layout) {
                this._layout.target = this;
            }
            this.invalidateSize();
            this.invalidateDisplayList();
            this.dispatchEventWith("layoutChanged");
        };

        Object.defineProperty(GroupBase.prototype, "clipAndEnableScrolling", {
            /**
            * 如果为 true，指定将子代剪切到视区的边界。如果为 false，则容器子代会从容器边界扩展过去，而不管组件的大小规范。默认false
            * @member egret.GroupBase#clipAndEnableScrolling
            */
            get: function () {
                return this._clipAndEnableScrolling;
            },
            set: function (value) {
                if (value == this._clipAndEnableScrolling)
                    return;
                this._clipAndEnableScrolling = value;
                if (this._clipAndEnableScrolling) {
                    this.scrollRect = new egret.Rectangle(this._horizontalScrollPosition, this._verticalScrollPosition, this.width, this.height);
                } else {
                    this.scrollRect = null;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(GroupBase.prototype, "horizontalScrollPosition", {
            /**
            * 可视区域水平方向起始点
            * @member egret.GroupBase#horizontalScrollPosition
            */
            get: function () {
                return this._horizontalScrollPosition;
            },
            set: function (value) {
                if (value == this._horizontalScrollPosition)
                    return;
                var oldValue = this._horizontalScrollPosition;
                this._horizontalScrollPosition = value;
                this.scrollPositionChanged();
                egret.PropertyChangeEvent.dispatchPropertyChangeEvent(this, egret.PropertyChangeEventKind.UPDATE, "horizontalScrollPosition", oldValue, value, this);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(GroupBase.prototype, "verticalScrollPosition", {
            /**
            * 可视区域竖直方向起始点
            * @member egret.GroupBase#verticalScrollPosition
            */
            get: function () {
                return this._verticalScrollPosition;
            },
            set: function (value) {
                if (value == this._verticalScrollPosition)
                    return;
                var oldValue = this._verticalScrollPosition;
                this._verticalScrollPosition = value;
                this.scrollPositionChanged();
                egret.PropertyChangeEvent.dispatchPropertyChangeEvent(this, egret.PropertyChangeEventKind.UPDATE, "verticalScrollPosition", oldValue, value, this);
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 滚动条位置改变
        */
        GroupBase.prototype.scrollPositionChanged = function () {
            if (!this._clipAndEnableScrolling) {
                return;
            }
            this.updateScrollRect(this.width, this.height);
            this._invalidateDisplayListExceptLayout();
            if (this._layout) {
                this._layout.scrollPositionChanged();
            }
        };

        /**
        * 更新可视区域
        * @param w {number}
        * @param h {number}
        */
        GroupBase.prototype.updateScrollRect = function (w, h) {
            var rect = this._scrollRect;
            if (this._clipAndEnableScrolling) {
                if (rect) {
                    rect.x = this._horizontalScrollPosition;
                    rect.y = this._verticalScrollPosition;
                    rect.width = w;
                    rect.height = h;
                } else {
                    this._scrollRect = new egret.Rectangle(this._horizontalScrollPosition, this._verticalScrollPosition, w, h);
                }
            } else if (rect) {
                this._scrollRect = null;
            }
        };

        /**
        * @method egret.GroupBase#measure
        */
        GroupBase.prototype.measure = function () {
            if (!this._layout || !this._layoutInvalidateSizeFlag)
                return;
            _super.prototype.measure.call(this);
            this._layout.measure();
        };

        /**
        * 标记需要更新显示列表但不需要更新布局
        * @method egret.GroupBase#_invalidateDisplayListExceptLayout
        */
        GroupBase.prototype._invalidateDisplayListExceptLayout = function () {
            _super.prototype.invalidateDisplayList.call(this);
        };

        /**
        * @method egret.GroupBase#invalidateDisplayList
        */
        GroupBase.prototype.invalidateDisplayList = function () {
            _super.prototype.invalidateDisplayList.call(this);
            this._layoutInvalidateDisplayListFlag = true;
        };

        /**
        * @method egret.GroupBase#_childXYChanged
        */
        GroupBase.prototype._childXYChanged = function () {
            this.invalidateSize();
            this.invalidateDisplayList();
        };

        /**
        * 标记需要更新显示列表但不需要更新布局
        * @method egret.GroupBase#_invalidateSizeExceptLayout
        */
        GroupBase.prototype._invalidateSizeExceptLayout = function () {
            _super.prototype.invalidateSize.call(this);
        };

        /**
        * @method egret.GroupBase#invalidateSize
        */
        GroupBase.prototype.invalidateSize = function () {
            _super.prototype.invalidateSize.call(this);
            this._layoutInvalidateSizeFlag = true;
        };

        /**
        * @method egret.GroupBase#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        GroupBase.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            if (this._layoutInvalidateDisplayListFlag && this._layout) {
                this._layoutInvalidateDisplayListFlag = false;
                this._layout.updateDisplayList(unscaledWidth, unscaledHeight);
                this.updateScrollRect(unscaledWidth, unscaledHeight);
            }
        };

        Object.defineProperty(GroupBase.prototype, "numElements", {
            /**
            * 此容器中的可视元素的数量。
            * @member egret.GroupBase#numElements
            */
            get: function () {
                return -1;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 返回指定索引处的可视元素。
        * @method egret.GroupBase#getElementAt
        * @param index {number} 要检索的元素的索引。
        * @throws RangeError 如果在子列表中不存在该索引位置。
        * @returns {IVisualElement}
        */
        GroupBase.prototype.getElementAt = function (index) {
            return null;
        };

        /**
        * 返回可视元素的索引位置。若不存在，则返回-1。
        * @method egret.GroupBase#getElementIndex
        * @param element {IVisualElement} 可视元素。
        * @returns {number}
        */
        GroupBase.prototype.getElementIndex = function (element) {
            return -1;
        };

        /**
        * 返回在容器可视区域内的布局元素索引列表,此方法忽略不是布局元素的普通的显示对象
        * @method egret.GroupBase#getElementIndicesInView
        * @returns {number}
        */
        GroupBase.prototype.getElementIndicesInView = function () {
            var visibleIndices = [];
            var index;
            if (!this.scrollRect) {
                for (index = 0; index < this.numChildren; index++) {
                    visibleIndices.push(index);
                }
            } else {
                for (index = 0; index < this.numChildren; index++) {
                    var layoutElement = (this.getChildAt(index));
                    if (!layoutElement)
                        continue;
                    var eltR = new egret.Rectangle();
                    eltR.x = layoutElement.layoutBoundsX;
                    eltR.y = layoutElement.layoutBoundsY;
                    eltR.width = layoutElement.layoutBoundsWidth;
                    eltR.height = layoutElement.layoutBoundsHeight;
                    if (this.scrollRect.intersects(eltR))
                        visibleIndices.push(index);
                }
            }
            return visibleIndices;
        };

        /**
        * 在支持虚拟布局的容器中，设置容器内可见的子元素索引范围。此方法在不支持虚拟布局的容器中无效。
        * 通常在即将连续调用getVirtualElementAt()之前需要显式设置一次，以便容器提前释放已经不可见的子元素。
        * @method egret.GroupBase#setVirtualElementIndicesInView
        * @param startIndex {number} 可视元素起始索引
        * @param endIndex {number} 可视元素结束索引
        */
        GroupBase.prototype.setVirtualElementIndicesInView = function (startIndex, endIndex) {
        };

        /**
        * 支持useVirtualLayout属性的布局类在updateDisplayList()中使用此方法来获取“处于视图中”的布局元素
        * @method egret.GroupBase#getVirtualElementAt
        * @param index {number} 要检索的元素的索引。
        * @returns {IVisualElement}
        */
        GroupBase.prototype.getVirtualElementAt = function (index) {
            return this.getElementAt(index);
        };
        return GroupBase;
    })(egret.UIComponent);
    egret.GroupBase = GroupBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ItemRenderer
    * @classdesc
    * 项呈示器基类
    * @extends egret.ButtonBase
    * @implements egret.IItemRenderer
    */
    var ItemRenderer = (function (_super) {
        __extends(ItemRenderer, _super);
        /**
        * @method egret.ItemRenderer#constructor
        */
        function ItemRenderer() {
            _super.call(this);
            this.dataChangedFlag = false;
            this._selected = false;
            this._itemIndex = -1;
            this.touchChildren = true;
        }
        Object.defineProperty(ItemRenderer.prototype, "data", {
            /**
            * @member egret.ItemRenderer#data
            */
            get: function () {
                return this._data;
            },
            set: function (value) {
                //这里不能加if(_data==value)return;的判断，会导致数据源无法刷新的问题
                this._data = value;
                if (this.initialized || this.parent) {
                    this.dataChangedFlag = false;
                    this.dataChanged();
                } else {
                    this.dataChangedFlag = true;
                    this.invalidateProperties();
                }
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 子类复写此方法以在data数据源发生改变时跟新显示列表。
        * 与直接复写_data的setter方法不同，它会确保在皮肤已经附加完成后再被调用。
        * @method egret.ItemRenderer#dataChanged
        */
        ItemRenderer.prototype.dataChanged = function () {
        };

        Object.defineProperty(ItemRenderer.prototype, "selected", {
            /**
            * @member egret.ItemRenderer#selected
            */
            get: function () {
                return this._selected;
            },
            set: function (value) {
                if (this._selected == value)
                    return;
                this._selected = value;
                this.invalidateSkinState();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ItemRenderer.prototype, "itemIndex", {
            /**
            * @member egret.ItemRenderer#itemIndex
            */
            get: function () {
                return this._itemIndex;
            },
            set: function (value) {
                this._itemIndex = value;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.ItemRenderer#commitProperties
        */
        ItemRenderer.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);
            if (this.dataChangedFlag) {
                this.dataChangedFlag = false;
                this.dataChanged();
            }
        };

        /**
        * @method egret.ItemRenderer#getCurrentSkinState
        * @returns {string}
        */
        ItemRenderer.prototype.getCurrentSkinState = function () {
            if (this._selected)
                return "down";
            return _super.prototype.getCurrentSkinState.call(this);
        };
        return ItemRenderer;
    })(egret.ButtonBase);
    egret.ItemRenderer = ItemRenderer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TreeItemRenderer
    * @classdesc
    * Tree组件的项呈示器基类
    * @extends egret.ItemRenderer
    * @implements egret.ITreeItemRenderer
    */
    var TreeItemRenderer = (function (_super) {
        __extends(TreeItemRenderer, _super);
        /**
        * 构造函数
        * @method egret.TreeItemRenderer#constructor
        */
        function TreeItemRenderer() {
            _super.call(this);
            this._indentation = 17;
            this._depth = 0;
            this._hasChildren = false;
            this._isOpen = false;
            this.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onItemMouseDown, this, false, 1000);
        }
        TreeItemRenderer.prototype.onItemMouseDown = function (event) {
            if (event.target == this.disclosureButton) {
                event.stopImmediatePropagation();
            }
        };

        Object.defineProperty(TreeItemRenderer.prototype, "indentation", {
            /**
            * 子节点相对父节点的缩进值，以像素为单位。默认17。
            * @member egret.TreeItemRenderer#indentation
            */
            get: function () {
                return this._indentation;
            },
            set: function (value) {
                this._indentation = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TreeItemRenderer.prototype, "iconSkinName", {
            /**
            * @member egret.TreeItemRenderer#iconSkinName
            */
            get: function () {
                return this._iconSkinName;
            },
            set: function (value) {
                if (this._iconSkinName == value)
                    return;
                this._iconSkinName = value;
                if (this.iconDisplay) {
                    this.iconDisplay.source = this._iconSkinName;
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TreeItemRenderer.prototype, "depth", {
            /**
            * @member egret.TreeItemRenderer#depth
            */
            get: function () {
                return this._depth;
            },
            set: function (value) {
                if (value == this._depth)
                    return;
                this._depth = value;
                if (this.contentGroup) {
                    this.contentGroup.x = this._depth * this._indentation;
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TreeItemRenderer.prototype, "hasChildren", {
            /**
            * @member egret.TreeItemRenderer#hasChildren
            */
            get: function () {
                return this._hasChildren;
            },
            set: function (value) {
                if (this._hasChildren == value)
                    return;
                this._hasChildren = value;
                if (this.disclosureButton) {
                    this.disclosureButton.visible = this._hasChildren;
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TreeItemRenderer.prototype, "opened", {
            /**
            * @member egret.TreeItemRenderer#opened
            */
            get: function () {
                return this._isOpen;
            },
            set: function (value) {
                if (this._isOpen == value)
                    return;
                this._isOpen = value;
                if (this.disclosureButton) {
                    this.disclosureButton.selected = this._isOpen;
                }
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.TreeItemRenderer#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        TreeItemRenderer.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);
            if (instance == this.iconDisplay) {
                this.iconDisplay.source = this._iconSkinName;
            } else if (instance == this.disclosureButton) {
                this.disclosureButton.visible = this._hasChildren;
                this.disclosureButton.selected = this._isOpen;
                this.disclosureButton._autoSelected = false;
                this.disclosureButton.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.disclosureButton_mouseDownHandler, this);
            } else if (instance == this.contentGroup) {
                this.contentGroup.x = this._depth * this._indentation;
            }
        };

        /**
        * @method egret.TreeItemRenderer#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        TreeItemRenderer.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);
            if (instance == this.iconDisplay) {
                this.iconDisplay.source = null;
            } else if (instance == this.disclosureButton) {
                this.disclosureButton.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.disclosureButton_mouseDownHandler, this);
                this.disclosureButton._autoSelected = true;
                this.disclosureButton.visible = true;
            }
        };

        /**
        * 鼠标在disclosureButton上按下
        * @method egret.TreeItemRenderer#disclosureButton_mouseDownHandler
        * @param event {TouchEvent}
        */
        TreeItemRenderer.prototype.disclosureButton_mouseDownHandler = function (event) {
            egret.TreeEvent.dispatchTreeEvent(this, egret.TreeEvent.ITEM_OPENING, this.itemIndex, this.data, this, !this._isOpen);
        };
        return TreeItemRenderer;
    })(egret.ItemRenderer);
    egret.TreeItemRenderer = TreeItemRenderer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.Animation
    * @classdesc
    * 数值缓动工具类
    */
    var Animation = (function () {
        /**
        * 构造函数
        * @method egret.Animation#constructor
        * @param updateFunction {Function} 动画更新时的回调函数,updateFunction(animation:Animation):void
        * @param thisObject {an}
        */
        function Animation(updateFunction, thisObject) {
            /**
            * 此动画的缓动行为。设置为null意味着不使用缓动，默认值为Ease.sineInOut()
            * @member egret.Animation#easerFunction
            */
            this.easerFunction = egret.Ease.sineInOut;
            this._duration = 500;
            this._startDelay = 0;
            this._repeatCount = 1;
            this._repeatDelay = 0;
            /**
            * 随着时间的推移Animation将设置动画的属性和值的列表。对象示例:{p:"x",f:10,t:100}表示，属性名"x"从10改变到100。
            * @member egret.Animation#motionPaths
            */
            this.motionPaths = [];
            this._currentValue = {};
            this.pauseTime = 0;
            this._isPaused = false;
            /**
            * 动画启动时刻
            */
            this.startTime = 0;
            this._started = false;
            /**
            * 已经播放的次数。
            */
            this.playedTimes = 0;
            this.updateFunction = updateFunction;
            this.thisObject = thisObject;
        }
        Object.defineProperty(Animation.prototype, "isPlaying", {
            /**
            * 是否正在播放动画，不包括延迟等待和暂停的阶段
            * @member egret.Animation#isPlaying
            */
            get: function () {
                return this._isPlaying;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Animation.prototype, "duration", {
            /**
            * 动画持续时间,单位毫秒，默认值500
            * @member egret.Animation#duration
            */
            get: function () {
                return this._duration;
            },
            set: function (value) {
                this._duration = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Animation.prototype, "startDelay", {
            /**
            * 动画开始播放前的延时时间,单位毫秒,默认0。
            * @member egret.Animation#startDelay
            */
            get: function () {
                return this._startDelay;
            },
            set: function (value) {
                this._startDelay = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Animation.prototype, "repeatCount", {
            /**
            * 动画重复的次数，0代表无限制重复。默认值为1。
            * @member egret.Animation#repeatCount
            */
            get: function () {
                return this._repeatCount;
            },
            set: function (value) {
                this._repeatCount = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Animation.prototype, "repeatDelay", {
            /**
            * 每次重复播放之间的间隔。第二次及以后的播放开始之前的延迟毫秒数。若要设置第一次之前的延迟时间，请使用startDelay属性。
            * @member egret.Animation#repeatDelay
            */
            get: function () {
                return this._repeatDelay;
            },
            set: function (value) {
                this._repeatDelay = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Animation.prototype, "currentValue", {
            /**
            * 动画到当前时间对应的值。以MotionPath.property为键存储各个MotionPath的当前值。
            * @member egret.Animation#currentValue
            */
            get: function () {
                return this._currentValue;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 开始正向播放动画,无论何时调用都重新从零时刻开始，若设置了延迟会首先进行等待。
        * @method egret.Animation#play
        */
        Animation.prototype.play = function () {
            this.stopAnimation();
            this.start();
        };

        /**
        * 立即跳到指定百分比的动画位置
        */
        Animation.prototype.seek = function (runningTime) {
            runningTime = Math.min(runningTime, this.duration);
            var fraction = runningTime / this.duration;
            this.caculateCurrentValue(fraction);
            this.startTime = egret.getTimer() - runningTime - this._startDelay;
            if (this.updateFunction != null)
                this.updateFunction.call(this.thisObject, this);
        };

        /**
        * 开始播放动画
        */
        Animation.prototype.start = function () {
            this.playedTimes = 0;
            this._started = true;
            this._isPlaying = false;
            this._currentValue = {};
            this.caculateCurrentValue(0);
            this.startTime = egret.getTimer();
            Animation.currentTime = this.startTime;
            this.doInterval();
            Animation.addAnimation(this);
        };

        /**
        * 直接跳到动画结尾
        * @method egret.Animation#end
        */
        Animation.prototype.end = function () {
            if (!this._started) {
                this.caculateCurrentValue(0);
                if (this.startFunction != null) {
                    this.startFunction.call(this.thisObject, this);
                }
                if (this.updateFunction != null) {
                    this.updateFunction.call(this.thisObject, this);
                }
            }
            this.caculateCurrentValue(1);
            if (this.updateFunction != null) {
                this.updateFunction.call(this.thisObject, this);
            }
            this.stopAnimation();
            if (this.endFunction != null) {
                this.endFunction.call(this.thisObject, this);
            }
        };

        /**
        * 停止播放动画
        * @method egret.Animation#stop
        */
        Animation.prototype.stop = function () {
            this.stopAnimation();
            if (this.stopFunction != null)
                this.stopFunction.call(this.thisObject, this);
        };

        /**
        * 仅停止播放动画，而不调用stopFunction。
        */
        Animation.prototype.stopAnimation = function () {
            this.playedTimes = 0;
            this._isPlaying = false;
            this.startTime = 0;
            this._started = false;
            Animation.removeAnimation(this);
        };

        Object.defineProperty(Animation.prototype, "isPaused", {
            /**
            * 正在暂停中
            * @member egret.Animation#isPaused
            */
            get: function () {
                return this._isPaused;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 暂停播放
        * @method egret.Animation#pause
        */
        Animation.prototype.pause = function () {
            if (!this._started)
                return;
            this._isPaused = true;
            this.pauseTime = egret.getTimer();
            this._isPlaying = false;
            Animation.removeAnimation(this);
        };

        /**
        * 继续播放
        * @method egret.Animation#resume
        */
        Animation.prototype.resume = function () {
            if (!this._started || !this._isPaused)
                return;
            this._isPaused = false;
            this.startTime += egret.getTimer() - this.pauseTime;
            this.pauseTime = -1;
            Animation.addAnimation(this);
        };

        Object.defineProperty(Animation.prototype, "started", {
            /**
            * 动画已经开始的标志，包括延迟等待和暂停的阶段。
            * @member egret.Animation#started
            */
            get: function () {
                return this._started;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 计算当前值并返回动画是否结束
        */
        Animation.prototype.doInterval = function () {
            var delay = this.playedTimes > 0 ? this._repeatDelay : this._startDelay;
            var runningTime = Animation.currentTime - this.startTime - delay;
            if (runningTime < 0) {
                return false;
            }
            if (!this._isPlaying) {
                this._isPlaying = true;
                if (this.playedTimes == 0) {
                    if (this.startFunction != null)
                        this.startFunction.call(this.thisObject, this);
                }
            }
            var fraction = this._duration == 0 ? 1 : Math.min(runningTime, this._duration) / this._duration;
            this.caculateCurrentValue(fraction);
            if (this.updateFunction != null)
                this.updateFunction.call(this.thisObject, this);
            var isEnded = runningTime >= this._duration;
            if (isEnded) {
                this.playedTimes++;
                this._isPlaying = false;
                this.startTime = Animation.currentTime;
                if (this._repeatCount == 0 || this.playedTimes < this._repeatCount) {
                    isEnded = false;
                } else {
                    Animation.removeAnimation(this);
                    this._started = false;
                    this.playedTimes = 0;
                }
            }
            if (isEnded && this.endFunction != null) {
                this.endFunction.call(this.thisObject, this);
            }
            return isEnded;
        };

        /**
        * 计算当前值
        */
        Animation.prototype.caculateCurrentValue = function (fraction) {
            if (this.easerFunction)
                fraction = this.easerFunction(fraction);
            var paths = this.motionPaths;
            var length = paths.length;
            for (var i = 0; i < length; i++) {
                var motion = paths[i];
                this.currentValue[motion.prop] = motion.from + (motion.to - motion.from) * fraction;
            }
        };

        /**
        * 添加动画到队列
        */
        Animation.addAnimation = function (animation) {
            if (Animation.activeAnimations.indexOf(animation) == -1) {
                Animation.activeAnimations.push(animation);
                if (!Animation.registered) {
                    Animation.registered = true;
                    egret.Ticker.getInstance().register(Animation.onEnterFrame, null);
                }
            }
        };

        /**
        * 从队列移除动画,返回移除前的索引
        */
        Animation.removeAnimation = function (animation) {
            var index = Animation.activeAnimations.indexOf(animation);
            if (index != -1) {
                Animation.activeAnimations.splice(index, 1);
                if (index <= Animation.currentIntervalIndex)
                    Animation.currentIntervalIndex--;
            }
            if (Animation.activeAnimations.length == 0 && Animation.registered) {
                Animation.registered = false;
                egret.Ticker.getInstance().unregister(Animation.onEnterFrame, null);
            }
        };

        /**
        * 计时器触发函数
        */
        Animation.onEnterFrame = function (frameTime, currentTime) {
            Animation.currentTime = egret.getTimer();
            Animation.currentIntervalIndex = 0;
            while (Animation.currentIntervalIndex < Animation.activeAnimations.length) {
                var animation = Animation.activeAnimations[Animation.currentIntervalIndex];
                var isEnded = animation.doInterval();
                Animation.currentIntervalIndex++;
            }
            Animation.currentIntervalIndex = -1;
            if (Animation.activeAnimations.length == 0 && Animation.registered) {
                Animation.registered = false;
                egret.Ticker.getInstance().unregister(Animation.onEnterFrame, null);
            }
        };
        Animation.currentTime = 0;

        Animation.TIMER_RESOLUTION = 1000 / 60;

        Animation.activeAnimations = [];

        Animation.currentIntervalIndex = -1;
        return Animation;
    })();
    egret.Animation = Animation;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Range
    * @classdesc
    * 范围选取组件,该组件包含一个值和这个值所允许的最大最小约束范围。
    * @extends egret.SkinnableComponent
    */
    var Range = (function (_super) {
        __extends(Range, _super);
        /**
        * 构造函数
        * @method egret.Range#constructor
        */
        function Range() {
            _super.call(this);
            this._maximum = 100;
            /**
            * 最大有效值改变标志
            */
            this.maxChanged = false;
            this._minimum = 0;
            /**
            * 最小有效值改变标志
            */
            this.minChanged = false;
            this._stepSize = 1;
            /**
            * 单步大小改变的标志
            */
            this.stepSizeChanged = false;
            this._value = 0;
            this._changedValue = 0;
            /**
            * 此范围的当前值改变标志
            */
            this.valueChanged = false;
            this._snapInterval = 1;
            this.snapIntervalChanged = false;
            this._explicitSnapInterval = false;
        }
        Object.defineProperty(Range.prototype, "maximum", {
            /**
            * 最大有效值
            * @member egret.Range#maximum
            */
            get: function () {
                return this._maximum;
            },
            set: function (value) {
                this._setMaximun(value);
            },
            enumerable: true,
            configurable: true
        });


        Range.prototype._setMaximun = function (value) {
            if (value == this._maximum)
                return;

            this._maximum = value;
            this.maxChanged = true;

            this.invalidateProperties();
        };

        Object.defineProperty(Range.prototype, "minimum", {
            /**
            * 最小有效值
            * @member egret.Range#minimum
            */
            get: function () {
                return this._minimum;
            },
            set: function (value) {
                this._setMinimun(value);
            },
            enumerable: true,
            configurable: true
        });


        Range.prototype._setMinimun = function (value) {
            if (value == this._minimum)
                return;

            this._minimum = value;
            this.minChanged = true;

            this.invalidateProperties();
        };

        Object.defineProperty(Range.prototype, "stepSize", {
            /**
            * 调用 changeValueByStep() 方法时 value 属性更改的单步大小。默认值为 1。<br/>
            * 除非 snapInterval 为 0，否则它必须是 snapInterval 的倍数。<br/>
            * 如果 stepSize 不是倍数，则会将它近似到大于或等于 snapInterval 的最近的倍数。<br/>
            * @member egret.Range#stepSize
            */
            get: function () {
                return this._stepSize;
            },
            set: function (value) {
                if (value == this._stepSize)
                    return;

                this._stepSize = value;
                this.stepSizeChanged = true;

                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Range.prototype, "value", {
            /**
            * 此范围的当前值。
            * @member egret.Range#value
            */
            get: function () {
                return this._getValue();
            },
            set: function (newValue) {
                this._setValue(newValue);
            },
            enumerable: true,
            configurable: true
        });


        Range.prototype._setValue = function (newValue) {
            if (newValue == this.value)
                return;
            this._changedValue = newValue;
            this.valueChanged = true;
            this.invalidateProperties();
        };

        Range.prototype._getValue = function () {
            return (this.valueChanged) ? this._changedValue : this._value;
        };

        Object.defineProperty(Range.prototype, "snapInterval", {
            /**
            * snapInterval 属性定义 value 属性的有效值。如果为非零，则有效值为 minimum 与此属性的整数倍数之和，且小于或等于 maximum。 <br/>
            * 例如，如果 minimum 为 10，maximum 为 20，而此属性为 3，则可能的有效值为 10、13、16、19 和 20。<br/>
            * 如果此属性的值为零，则仅会将有效值约束到介于 minimum 和 maximum 之间（包括两者）。<br/>
            * 此属性还约束 stepSize 属性（如果设置）的有效值。如果未显式设置此属性，但设置了 stepSize，则 snapInterval 将默认为 stepSize。<br/>
            * @member egret.Range#snapInterval
            */
            get: function () {
                return this._snapInterval;
            },
            set: function (value) {
                this._explicitSnapInterval = true;

                if (value == this._snapInterval)
                    return;
                if (isNaN(value)) {
                    this._snapInterval = 1;
                    this._explicitSnapInterval = false;
                } else {
                    this._snapInterval = value;
                }

                this.snapIntervalChanged = true;
                this.stepSizeChanged = true;

                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.Range#commitProperties
        */
        Range.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);

            if (this.minimum > this.maximum) {
                if (!this.maxChanged)
                    this._minimum = this._maximum;
                else
                    this._maximum = this._minimum;
            }

            if (this.valueChanged || this.maxChanged || this.minChanged || this.snapIntervalChanged) {
                var currentValue = (this.valueChanged) ? this._changedValue : this._value;
                this.valueChanged = false;
                this.maxChanged = false;
                this.minChanged = false;
                this.snapIntervalChanged = false;
                this.setValue(this.nearestValidValue(currentValue, this.snapInterval));
            }

            if (this.stepSizeChanged) {
                if (this._explicitSnapInterval) {
                    this._stepSize = this.nearestValidSize(this._stepSize);
                } else {
                    this._snapInterval = this._stepSize;
                    this.setValue(this.nearestValidValue(this._value, this.snapInterval));
                }

                this.stepSizeChanged = false;
            }
        };

        /**
        * 修正stepSize到最接近snapInterval的整数倍
        */
        Range.prototype.nearestValidSize = function (size) {
            var interval = this.snapInterval;
            if (interval == 0)
                return size;

            var validSize = Math.round(size / interval) * interval;
            return (Math.abs(validSize) < interval) ? interval : validSize;
        };

        /**
        * 修正输入的值为有效值
        * @method egret.Range#nearestValidValue
        * @param value {number} 输入值。
        * @param interval {number} snapInterval 的值，或 snapInterval 的整数倍数。
        * @returns {number}
        */
        Range.prototype.nearestValidValue = function (value, interval) {
            if (interval == 0)
                return Math.max(this.minimum, Math.min(this.maximum, value));

            var maxValue = this.maximum - this.minimum;
            var scale = 1;

            value -= this.minimum;
            if (interval != Math.round(interval)) {
                var parts = ((1 + interval).toString()).split(".");
                scale = Math.pow(10, parts[1].length);
                maxValue *= scale;
                value = Math.round(value * scale);
                interval = Math.round(interval * scale);
            }

            var lower = Math.max(0, Math.floor(value / interval) * interval);
            var upper = Math.min(maxValue, Math.floor((value + interval) / interval) * interval);
            var validValue = ((value - lower) >= ((upper - lower) / 2)) ? upper : lower;

            return (validValue / scale) + this.minimum;
        };

        /**
        * 设置当前值。此方法假定调用者已经使用了 nearestValidValue() 方法来约束 value 参数
        * @method egret.Range#setValue
        * @param value {number} value属性的新值
        */
        Range.prototype.setValue = function (value) {
            if (this._value == value)
                return;
            if (isNaN(value))
                value = 0;
            if (!isNaN(this.maximum) && !isNaN(this.minimum) && (this.maximum > this.minimum))
                this._value = Math.min(this.maximum, Math.max(this.minimum, value));
            else
                this._value = value;
            this.valueChanged = false;
        };

        /**
        * 按 stepSize增大或减小当前值
        * @method egret.Range#changeValueByStep
        * @param increase {boolean} 若为 true，则向value增加stepSize，否则减去它。
        */
        Range.prototype.changeValueByStep = function (increase) {
            if (typeof increase === "undefined") { increase = true; }
            if (this.stepSize == 0)
                return;

            var newValue = (increase) ? this.value + this.stepSize : this.value - this.stepSize;
            this.setValue(this.nearestValidValue(newValue, this.snapInterval));
        };
        return Range;
    })(egret.SkinnableComponent);
    egret.Range = Range;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TrackBase
    * @classdesc
    * TrackBase类是具有一个轨道和一个或多个滑块按钮的组件的一个基类，如 Slider 和 ScrollBar。
    * @extends egret.Range
    */
    var TrackBase = (function (_super) {
        __extends(TrackBase, _super);
        /**
        * @method egret.TrackBase#constructor
        */
        function TrackBase() {
            _super.call(this);
            this._slideDuration = 300;
            /**
            * 当鼠标拖动thumb时，需要更新value的标记。
            */
            this.needUpdateValue = false;
            this.addEventListener(egret.Event.ADDED_TO_STAGE, this.addedToStageHandler, this);
            this.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.mouseDownHandler, this);
        }
        Object.defineProperty(TrackBase.prototype, "slideDuration", {
            /**
            * 在轨道上单击以移动滑块时，滑动动画持续的时间（以毫秒为单位）。<br/>
            * 此属性用于 Slider 和 ScrollBar。对于 Slider，在轨道上的任何单击将导致生成使用此样式的一个动画，同时滑块将移到单击的位置。<br/>
            * 对于 ScrollBar，仅当按住 Shift 键并单击轨道时才使用此样式，这会导致滑块移到单击的位置。<br/>
            * 未按下 Shift 键时单击 ScrollBar 轨道将导致出现分页行为。<br/>
            * 按住 Shift 键并单击时，必须也对 ScrollBar 设置 smoothScrolling 属性才可以实现动画行为。<br/>
            * 此持续时间是整个滑过轨道的总时间，实际滚动会根据距离相应缩短。
            * @member egret.TrackBase#slideDuration
            */
            get: function () {
                return this._slideDuration;
            },
            set: function (value) {
                this._slideDuration = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TrackBase.prototype, "maximum", {
            /**
            * 最大有效值
            * @member egret.TrackBase#maximum
            */
            get: function () {
                return this._maximum;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (value == this._maximum)
                    return;

                this._setMaximun(value);
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TrackBase.prototype, "minimum", {
            /**
            * 最小有效值
            * @member egret.TrackBase#minimum
            */
            get: function () {
                return this._minimum;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (value == this._minimum)
                    return;

                this._setMinimun(value);
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TrackBase.prototype, "value", {
            /**
            * 此范围的当前值。
            * @member egret.TrackBase#value
            */
            get: function () {
                return this._getValue();
            },
            /**
            * @inheritDoc
            */
            set: function (newValue) {
                if (newValue == this._getValue())
                    return;

                this._setValue(newValue);
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.TrackBase#setValue
        * @param value {number}
        */
        TrackBase.prototype.setValue = function (value) {
            _super.prototype.setValue.call(this, value);
            this.invalidateDisplayList();
        };

        /**
        * 将相对于轨道的 x,y 像素位置转换为介于最小值和最大值（包括两者）之间的一个值。
        * @method egret.TrackBase#pointToValue
        * @param x {number} 相对于轨道原点的位置的x坐标。
        * @param y {number} 相对于轨道原点的位置的y坐标。
        * @returns {number}
        */
        TrackBase.prototype.pointToValue = function (x, y) {
            return this.minimum;
        };

        /**
        * @method egret.TrackBase#changeValueByStep
        * @param increase {boolean}
        */
        TrackBase.prototype.changeValueByStep = function (increase) {
            if (typeof increase === "undefined") { increase = true; }
            var prevValue = this.value;

            _super.prototype.changeValueByStep.call(this, increase);

            if (this.value != prevValue)
                this.dispatchEventWith(egret.Event.CHANGE);
        };

        /**
        * @method egret.TrackBase#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        TrackBase.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.thumb) {
                this.thumb.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.thumb_mouseDownHandler, this);
                this.thumb.addEventListener(egret.ResizeEvent.RESIZE, this.thumb_resizeHandler, this);
                this.thumb.addEventListener(egret.UIEvent.UPDATE_COMPLETE, this.thumb_updateCompleteHandler, this);
                this.thumb.stickyHighlighting = true;
            } else if (instance == this.track) {
                this.track.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.track_mouseDownHandler, this);
                this.track.addEventListener(egret.ResizeEvent.RESIZE, this.track_resizeHandler, this);
            }
        };

        /**
        * @method egret.TrackBase#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        TrackBase.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);

            if (instance == this.thumb) {
                this.thumb.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.thumb_mouseDownHandler, this);
                this.thumb.removeEventListener(egret.ResizeEvent.RESIZE, this.thumb_resizeHandler, this);
                this.thumb.removeEventListener(egret.UIEvent.UPDATE_COMPLETE, this.thumb_updateCompleteHandler, this);
            } else if (instance == this.track) {
                this.track.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.track_mouseDownHandler, this);
                this.track.removeEventListener(egret.ResizeEvent.RESIZE, this.track_resizeHandler, this);
            }
        };

        /**
        * @method egret.TrackBase#updateDisplayList
        * @param w {number}
        * @param h {number}
        */
        TrackBase.prototype.updateDisplayList = function (w, h) {
            _super.prototype.updateDisplayList.call(this, w, h);
            this.updateSkinDisplayList();
        };

        /**
        * 更新皮肤部件（通常为滑块）的大小和可见性。<br/>
        * 子类覆盖此方法以基于 minimum、maximum 和 value 属性更新滑块的大小、位置和可见性。
        * @method egret.TrackBase#updateSkinDisplayList
        */
        TrackBase.prototype.updateSkinDisplayList = function () {
        };

        /**
        * 添加到舞台时
        */
        TrackBase.prototype.addedToStageHandler = function (event) {
            this.updateSkinDisplayList();
        };

        /**
        * 轨道尺寸改变事件
        */
        TrackBase.prototype.track_resizeHandler = function (event) {
            this.updateSkinDisplayList();
        };

        /**
        * 滑块尺寸改变事件
        */
        TrackBase.prototype.thumb_resizeHandler = function (event) {
            this.updateSkinDisplayList();
        };

        /**
        * 滑块三个阶段的延迟布局更新完毕事件
        */
        TrackBase.prototype.thumb_updateCompleteHandler = function (event) {
            this.updateSkinDisplayList();
            this.thumb.removeEventListener(egret.UIEvent.UPDATE_COMPLETE, this.thumb_updateCompleteHandler, this);
        };

        /**
        * 滑块按下事件
        * @method egret.TrackBase#thumb_mouseDownHandler
        * @param event {TouchEvent}
        */
        TrackBase.prototype.thumb_mouseDownHandler = function (event) {
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE, this.stage_mouseMoveHandler, this);
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
            this.addEventListener(egret.Event.ENTER_FRAME, this.onEnterFrame, this);

            var clickOffset = this.thumb.globalToLocal(event.stageX, event.stageY, egret.Point.identity);
            this._clickOffsetX = clickOffset.x;
            this._clickOffsetY = clickOffset.y;

            egret.TrackBaseEvent.dispatchTrackBaseEvent(this, egret.TrackBaseEvent.THUMB_PRESS);
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CHANGE_START);
        };

        /**
        * 拖动thumb过程中触发的EnterFrame事件
        */
        TrackBase.prototype.onEnterFrame = function (event) {
            if (!this.needUpdateValue || !this.track)
                return;
            this.updateWhenMouseMove();
            this.needUpdateValue = false;
        };

        /**
        * 当thumb被拖动时更新值，此方法每帧只被调用一次，比直接在鼠标移动事件里更新性能更高。
        * @method egret.TrackBase#updateWhenMouseMove
        */
        TrackBase.prototype.updateWhenMouseMove = function () {
            if (!this.track)
                return;
            var p = this.track.globalToLocal(this._moveStageX, this._moveStageY, egret.Point.identity);
            var newValue = this.pointToValue(p.x - this._clickOffsetX, p.y - this._clickOffsetY);
            newValue = this.nearestValidValue(newValue, this.snapInterval);

            if (newValue != this.value) {
                this.setValue(newValue);
                this.validateDisplayList();
                egret.TrackBaseEvent.dispatchTrackBaseEvent(this, egret.TrackBaseEvent.THUMB_DRAG);
                this.dispatchEventWith(egret.Event.CHANGE);
            }
        };

        /**
        * 鼠标移动事件
        * @method egret.TrackBase#stage_mouseMoveHandler
        * @param event {TouchEvent}
        */
        TrackBase.prototype.stage_mouseMoveHandler = function (event) {
            this._moveStageX = event.stageX;
            this._moveStageY = event.stageY;
            if (this.needUpdateValue)
                return;
            this.needUpdateValue = true;
        };

        /**
        * 鼠标弹起事件
        * @method egret.TrackBase#stage_mouseUpHandler
        * @param event {Event}
        */
        TrackBase.prototype.stage_mouseUpHandler = function (event) {
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE, this.stage_mouseMoveHandler, this);
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
            this.removeEventListener(egret.Event.ENTER_FRAME, this.updateWhenMouseMove, this);
            if (this.needUpdateValue) {
                this.updateWhenMouseMove();
                this.needUpdateValue = false;
            }
            egret.TrackBaseEvent.dispatchTrackBaseEvent(this, egret.TrackBaseEvent.THUMB_RELEASE);
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CHANGE_END);
        };

        /**
        * 轨道被按下事件
        * @method egret.TrackBase#track_mouseDownHandler
        * @param event {TouchEvent}
        */
        TrackBase.prototype.track_mouseDownHandler = function (event) {
        };

        /**
        * 当在组件上按下鼠标时记录被按下的子显示对象
        */
        TrackBase.prototype.mouseDownHandler = function (event) {
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpSomewhereHandler, this);
            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpSomewhereHandler, this);

            this.mouseDownTarget = (event.target);
        };

        /**
        * 当鼠标弹起时，若不是在mouseDownTarget上弹起，而是另外的子显示对象上弹起时，额外抛出一个鼠标单击事件。
        */
        TrackBase.prototype.stage_mouseUpSomewhereHandler = function (event) {
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpSomewhereHandler, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpSomewhereHandler, this);
            if (this.mouseDownTarget != event.target && event instanceof egret.TouchEvent && this.contains((event.target))) {
                var mEvent = event;

                var mousePoint = (event.target).localToGlobal(mEvent.localX, mEvent.localY);

                egret.TouchEvent.dispatchTouchEvent(this, egret.TouchEvent.TOUCH_TAP, mEvent.touchPointID, mousePoint.x, mousePoint.y, mEvent.ctrlKey, mEvent.altKey, mEvent.shiftKey, mEvent.touchDown);
            }

            this.mouseDownTarget = null;
        };
        return TrackBase;
    })(egret.Range);
    egret.TrackBase = TrackBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SliderBase
    * @classdesc
    * 滑块控件基类
    * @extends egret.TrackBase
    */
    var SliderBase = (function (_super) {
        __extends(SliderBase, _super);
        /**
        * 构造函数
        * @method egret.SliderBase#constructor
        */
        function SliderBase() {
            _super.call(this);
            this._showTrackHighlight = true;
            this._pendingValue = 0;
            this._liveDragging = true;
            this.maximum = 10;
        }
        Object.defineProperty(SliderBase.prototype, "showTrackHighlight", {
            /**
            * 是否启用轨道高亮效果。默认值为true。
            * 注意，皮肤里的子部件trackHighlight要同时为非空才能显示高亮效果。
            * @member egret.SliderBase#showTrackHighlight
            */
            get: function () {
                return this._showTrackHighlight;
            },
            set: function (value) {
                if (this._showTrackHighlight == value)
                    return;
                this._showTrackHighlight = value;
                if (this.trackHighlight)
                    this.trackHighlight.visible = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SliderBase.prototype, "pendingValue", {
            /**
            * 释放鼠标按键时滑块将具有的值。无论liveDragging是否为true，在滑块拖动期间始终更新此属性。
            * 而value属性在当liveDragging为false时，只在鼠标释放时更新一次。
            * @member egret.SliderBase#pendingValue
            */
            get: function () {
                return this._pendingValue;
            },
            set: function (value) {
                if (value == this._pendingValue)
                    return;
                this._pendingValue = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.SliderBase#setValue
        * @param value {number}
        */
        SliderBase.prototype.setValue = function (value) {
            this._pendingValue = value;

            _super.prototype.setValue.call(this, value);
        };

        /**
        * 动画播放更新数值
        */
        SliderBase.prototype.animationUpdateHandler = function (animation) {
            this.pendingValue = animation.currentValue["value"];
        };

        /**
        * 动画播放完毕
        */
        SliderBase.prototype.animationEndHandler = function (animation) {
            this.setValue(this.slideToValue);

            this.dispatchEventWith(egret.Event.CHANGE);
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CHANGE_END);
        };

        /**
        * 停止播放动画
        */
        SliderBase.prototype.stopAnimation = function () {
            this.animator.stop();

            this.setValue(this.nearestValidValue(this.pendingValue, this.snapInterval));

            this.dispatchEventWith(egret.Event.CHANGE);
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CHANGE_END);
        };

        /**
        * @method egret.SliderBase#thumb_mouseDownHandler
        * @param event {TouchEvent}
        */
        SliderBase.prototype.thumb_mouseDownHandler = function (event) {
            if (this.animator && this.animator.isPlaying)
                this.stopAnimation();

            _super.prototype.thumb_mouseDownHandler.call(this, event);
        };

        Object.defineProperty(SliderBase.prototype, "liveDragging", {
            /**
            * 如果为 true，则将在沿着轨道拖动滑块时，而不是在释放滑块按钮时，提交此滑块的值。
            * @member egret.SliderBase#liveDragging
            */
            get: function () {
                return this._liveDragging;
            },
            set: function (value) {
                this._liveDragging = value;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.SliderBase#updateWhenMouseMove
        */
        SliderBase.prototype.updateWhenMouseMove = function () {
            if (!this.track)
                return;

            var pos = this.track.globalToLocal(this._moveStageX, this._moveStageY, egret.Point.identity);
            var newValue = this.pointToValue(pos.x - this._clickOffsetX, pos.y - this._clickOffsetY);
            newValue = this.nearestValidValue(newValue, this.snapInterval);

            if (newValue != this.pendingValue) {
                egret.TrackBaseEvent.dispatchTrackBaseEvent(this, egret.TrackBaseEvent.THUMB_DRAG);
                if (this.liveDragging == true) {
                    this.setValue(newValue);
                    this.dispatchEventWith(egret.Event.CHANGE);
                } else {
                    this.pendingValue = newValue;
                }
            }
        };

        /**
        * @method egret.SliderBase#stage_mouseUpHandler
        * @param event {Event}
        */
        SliderBase.prototype.stage_mouseUpHandler = function (event) {
            _super.prototype.stage_mouseUpHandler.call(this, event);
            if ((this.liveDragging == false) && (this.value != this.pendingValue)) {
                this.setValue(this.pendingValue);
                this.dispatchEventWith(egret.Event.CHANGE);
            }
        };

        /**
        * @method egret.SliderBase#track_mouseDownHandler
        * @param event {TouchEvent}
        */
        SliderBase.prototype.track_mouseDownHandler = function (event) {
            if (!this.enabled)
                return;
            var thumbW = (this.thumb) ? this.thumb.width : 0;
            var thumbH = (this.thumb) ? this.thumb.height : 0;
            var offsetX = event.stageX - (thumbW / 2);
            var offsetY = event.stageY - (thumbH / 2);
            var p = this.track.globalToLocal(offsetX, offsetY, egret.Point.identity);

            var newValue = this.pointToValue(p.x, p.y);
            newValue = this.nearestValidValue(newValue, this.snapInterval);

            if (newValue != this.pendingValue) {
                if (this.slideDuration != 0) {
                    if (!this.animator) {
                        this.animator = new egret.Animation(this.animationUpdateHandler, this);
                        this.animator.endFunction = this.animationEndHandler;
                    }
                    if (this.animator.isPlaying)
                        this.stopAnimation();
                    this.slideToValue = newValue;
                    this.animator.duration = this.slideDuration * (Math.abs(this.pendingValue - this.slideToValue) / (this.maximum - this.minimum));
                    this.animator.motionPaths = [{ prop: "value", from: this.pendingValue, to: this.slideToValue }];
                    egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CHANGE_START);
                    this.animator.play();
                } else {
                    this.setValue(newValue);
                    this.dispatchEventWith(egret.Event.CHANGE);
                }
            }
        };

        /**
        * @method egret.SliderBase#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        SliderBase.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);
            if (instance == this.trackHighlight) {
                this.trackHighlight.touchEnabled = false;
                if (this.trackHighlight instanceof egret.DisplayObjectContainer)
                    (this.trackHighlight).touchChildren = false;
                this.trackHighlight.visible = this._showTrackHighlight;
            }
        };
        return SliderBase;
    })(egret.TrackBase);
    egret.SliderBase = SliderBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Label
    * @classdesc
    * 一行或多行不可编辑的文本控件
    * @extends egret.TextBase
    */
    var Label = (function (_super) {
        __extends(Label, _super);
        /**
        * @method egret.Label#constructor
        */
        function Label() {
            _super.call(this);
            this._maxDisplayedLines = 0;
            /**
            * 上一次测量的宽度
            */
            this.lastUnscaledWidth = NaN;
            this._padding = 0;
            this._paddingLeft = NaN;
            this._paddingRight = NaN;
            this._paddingTop = NaN;
            this._paddingBottom = NaN;
            this.addEventListener(egret.UIEvent.UPDATE_COMPLETE, this.updateCompleteHandler, this);
        }
        /**
        * 一个验证阶段完成
        */
        Label.prototype.updateCompleteHandler = function (event) {
            this.lastUnscaledWidth = NaN;
        };

        Object.defineProperty(Label.prototype, "maxDisplayedLines", {
            /**
            * 最大显示行数,0或负值代表不限制。
            * @member egret.Label#maxDisplayedLines
            */
            get: function () {
                return this._maxDisplayedLines;
            },
            set: function (value) {
                if (this._maxDisplayedLines == value)
                    return;
                this._maxDisplayedLines = value;
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Label.prototype, "padding", {
            /**
            * 四个边缘的共同内边距。若单独设置了任一边缘的内边距，则该边缘的内边距以单独设置的值为准。
            * 此属性主要用于快速设置多个边缘的相同内边距。默认值：0。
            * @member egret.Label#padding
            */
            get: function () {
                return this._padding;
            },
            set: function (value) {
                if (this._padding == value)
                    return;
                this._padding = value;
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Label.prototype, "paddingLeft", {
            /**
            * 文字距离左边缘的空白像素,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.Label#paddingLeft
            */
            get: function () {
                return this._paddingLeft;
            },
            set: function (value) {
                if (this._paddingLeft == value)
                    return;

                this._paddingLeft = value;
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Label.prototype, "paddingRight", {
            /**
            * 文字距离右边缘的空白像素,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.Label#paddingRight
            */
            get: function () {
                return this._paddingRight;
            },
            set: function (value) {
                if (this._paddingRight == value)
                    return;

                this._paddingRight = value;
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Label.prototype, "paddingTop", {
            /**
            * 文字距离顶部边缘的空白像素,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.Label#paddingTop
            */
            get: function () {
                return this._paddingTop;
            },
            set: function (value) {
                if (this._paddingTop == value)
                    return;

                this._paddingTop = value;
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Label.prototype, "paddingBottom", {
            /**
            * 文字距离底部边缘的空白像素,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.Label#paddingBottom
            */
            get: function () {
                return this._paddingBottom;
            },
            set: function (value) {
                if (this._paddingBottom == value)
                    return;

                this._paddingBottom = value;
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.Label#measure
        */
        Label.prototype.measure = function () {
            //先提交属性，防止样式发生改变导致的测量不准确问题。
            if (this._invalidatePropertiesFlag)
                this.validateProperties();
            if (this.isSpecialCase()) {
                if (isNaN(this.lastUnscaledWidth)) {
                    this._oldPreferWidth = NaN;
                    this._oldPreferHeight = NaN;
                } else {
                    this.measureUsingWidth(this.lastUnscaledWidth);
                    return;
                }
            }

            var availableWidth;

            if (!isNaN(this.explicitWidth))
                availableWidth = this.explicitWidth;
            else if (this.maxWidth != 10000)
                availableWidth = this.maxWidth;

            this.measureUsingWidth(availableWidth);
        };

        /**
        * 特殊情况，组件尺寸由父级决定，要等到父级UpdateDisplayList的阶段才能测量
        */
        Label.prototype.isSpecialCase = function () {
            return this._maxDisplayedLines != 1 && (!isNaN(this.percentWidth) || (!isNaN(this.left) && !isNaN(this.right))) && isNaN(this.explicitHeight) && isNaN(this.percentHeight);
        };

        /**
        * 使用指定的宽度进行测量
        */
        Label.prototype.measureUsingWidth = function (w) {
            var originalText = this._textField.text;
            if (this._textChanged) {
                this._textField.text = this._text;
            }

            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            this._textField.width = NaN;
            this._textField.height = NaN;
            if (!isNaN(w)) {
                this._textField.width = w - paddingL - paddingR;
                this.measuredWidth = Math.ceil(this._textField.measuredWidth);
                this.measuredHeight = Math.ceil(this._textField.measuredHeight);
            } else {
                this.measuredWidth = Math.ceil(this._textField.measuredWidth);
                this.measuredHeight = Math.ceil(this._textField.measuredHeight);
            }

            if (this._maxDisplayedLines > 0 && this._textField.numLines > this._maxDisplayedLines) {
                var size = this._textField.size;
                var lineSpacing = this._textField.lineSpacing;
                this.measuredHeight = (size + lineSpacing) * this._maxDisplayedLines - lineSpacing;
            }

            this.measuredWidth += paddingL + paddingR;
            this.measuredHeight += paddingT + paddingB;

            this._textField.text = originalText;
        };

        /**
        * @method egret.Label#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        Label.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            this.$updateDisplayList(unscaledWidth, unscaledHeight);

            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            this._textField.x = paddingL;
            this._textField.y = paddingT;
            if (this.isSpecialCase()) {
                var firstTime = isNaN(this.lastUnscaledWidth) || this.lastUnscaledWidth != unscaledWidth;
                this.lastUnscaledWidth = unscaledWidth;
                if (firstTime) {
                    this._oldPreferWidth = NaN;
                    this._oldPreferHeight = NaN;
                    this.invalidateSize();
                    return;
                }
            }

            //防止在父级validateDisplayList()阶段改变的text属性值，
            //接下来直接调用自身的updateDisplayList()而没有经过measure(),使用的测量尺寸是上一次的错误值。
            if (this._invalidateSizeFlag)
                this.validateSize();

            if (!this._textField.visible)
                this._textField.visible = true;

            this._textField.width = unscaledWidth - paddingL - paddingR;
            var unscaledTextHeight = unscaledHeight - paddingT - paddingB;
            this._textField.height = unscaledTextHeight;

            if (this._maxDisplayedLines > 0 && this._textField.numLines > this._maxDisplayedLines) {
                var size = this._textField.size;
                var lineSpacing = this._textField.lineSpacing;
                var h = (size + lineSpacing) * this._maxDisplayedLines - lineSpacing;
                this._textField.height = Math.min(unscaledTextHeight, h);
            }
        };
        return Label;
    })(egret.TextBase);
    egret.Label = Label;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Rect
    * @classdesc
    * 矩形绘图元素。此组件可响应鼠标事件。
    * @extends egret.UIComponent
    */
    var Rect = (function (_super) {
        __extends(Rect, _super);
        /**
        * 构造函数
        * @method egret.Rect#constructor
        */
        function Rect() {
            _super.call(this);
            this._fillColor = 0xFFFFFF;
            this._fillAlpha = 1;
            this._strokeColor = 0x444444;
            this._strokeAlpha = 0;
            this._strokeWeight = 1;
            this.touchChildren = false;
        }
        Object.defineProperty(Rect.prototype, "graphics", {
            get: function () {
                if (!this._graphics) {
                    this._graphics = new egret.Graphics();
                }
                return this._graphics;
            },
            enumerable: true,
            configurable: true
        });

        Rect.prototype._render = function (renderContext) {
            if (this._graphics)
                this._graphics._draw(renderContext);
            _super.prototype._render.call(this, renderContext);
        };

        Object.defineProperty(Rect.prototype, "fillColor", {
            /**
            * 填充颜色
            * @member egret.Rect#fillColor
            */
            get: function () {
                return this._fillColor;
            },
            set: function (value) {
                if (this._fillColor == value)
                    return;
                this._fillColor = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Rect.prototype, "fillAlpha", {
            /**
            * 填充透明度,默认值为0。
            * @member egret.Rect#fillAlpha
            */
            get: function () {
                return this._fillAlpha;
            },
            set: function (value) {
                if (this._fillAlpha == value)
                    return;
                this._fillAlpha = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Rect.prototype, "strokeColor", {
            /**
            * 边框颜色,注意：当strokeAlpha为0时，不显示边框。
            * @member egret.Rect#strokeColor
            */
            get: function () {
                return this._strokeColor;
            },
            set: function (value) {
                if (this._strokeColor == value)
                    return;
                this._strokeColor = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Rect.prototype, "strokeAlpha", {
            /**
            * 边框透明度，默认值为0。
            * @member egret.Rect#strokeAlpha
            */
            get: function () {
                return this._strokeAlpha;
            },
            set: function (value) {
                if (this._strokeAlpha == value)
                    return;
                this._strokeAlpha = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Rect.prototype, "strokeWeight", {
            /**
            * 边框粗细(像素),注意：当strokeAlpha为0时，不显示边框。
            * @member egret.Rect#strokeWeight
            */
            get: function () {
                return this._strokeWeight;
            },
            set: function (value) {
                if (this._strokeWeight == value)
                    return;
                this._strokeWeight = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @see egret.DisplayObject.measureBounds
        * @returns {Rectangle}
        * @private
        */
        Rect.prototype._measureBounds = function () {
            var bounds = _super.prototype._measureBounds.call(this);
            var w = this.width;
            var h = this.height;
            var x = 0;
            var y = 0;
            if (x < bounds.x) {
                bounds.x = x;
            }
            if (y < bounds.y) {
                bounds.y = y;
            }
            if (x + w > bounds.right) {
                bounds.right = x + w;
            }
            if (y + h > bounds.bottom) {
                bounds.bottom = y + h;
            }
            return bounds;
        };

        /**
        * @method egret.Rect#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        Rect.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledWidth);
            var g = this.graphics;
            g.clear();
            g.beginFill(this._fillColor, this._fillAlpha);
            if (this._strokeAlpha > 0) {
                g.lineStyle(this._strokeWeight, this._strokeColor, this._strokeAlpha, true, "normal", "square", "miter");
            }
            g.drawRect(0, 0, unscaledWidth, unscaledHeight);
            g.endFill();
        };
        return Rect;
    })(egret.UIComponent);
    egret.Rect = Rect;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Button
    * @classdesc
    * 按钮控件
    * @extends egret.ButtonBase
    */
    var Button = (function (_super) {
        __extends(Button, _super);
        /**
        * @method egret.Button#constructor
        */
        function Button() {
            _super.call(this);
            this.hostComponentKey = "egret.Button";
        }
        return Button;
    })(egret.ButtonBase);
    egret.Button = Button;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ToggleButton
    * @classdesc
    * 切换按钮
    * @extends egret.ToggleButtonBase
    */
    var ToggleButton = (function (_super) {
        __extends(ToggleButton, _super);
        /**
        * 构造函数
        * @method egret.ToggleButton#constructor
        */
        function ToggleButton() {
            _super.call(this);
            this.hostComponentKey = "egret.ToggleButton";
        }
        return ToggleButton;
    })(egret.ToggleButtonBase);
    egret.ToggleButton = ToggleButton;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.CheckBox
    * @classdesc
    * 复选框
    * @extends egret.ToggleButtonBase
    */
    var CheckBox = (function (_super) {
        __extends(CheckBox, _super);
        /**
        * 构造函数
        * @method egret.CheckBox#constructor
        */
        function CheckBox() {
            _super.call(this);
            this.hostComponentKey = "egret.CheckBox";
        }
        return CheckBox;
    })(egret.ToggleButtonBase);
    egret.CheckBox = CheckBox;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.RadioButtonGroup
    * @classdesc
    * 单选按钮组
    * @extends egret.EventDispatcher
    */
    var RadioButtonGroup = (function (_super) {
        __extends(RadioButtonGroup, _super);
        /**
        * 构造函数
        * @method egret.RadioButtonGroup#constructor
        */
        function RadioButtonGroup() {
            _super.call(this);
            /**
            * 单选按钮列表
            */
            this.radioButtons = [];
            this._enabled = true;
            this._name = "_radioButtonGroup" + RadioButtonGroup.groupCount;
            RadioButtonGroup.groupCount++;
        }
        Object.defineProperty(RadioButtonGroup.prototype, "enabled", {
            /**
            * 组件是否可以接受用户交互。默认值为true。设置此属性将影响组内所有单选按钮。
            * @member egret.RadioButtonGroup#enabled
            */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled == value)
                    return;

                this._enabled = value;
                for (var i = 0; i < this.numRadioButtons; i++)
                    this.getRadioButtonAt(i).invalidateSkinState();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(RadioButtonGroup.prototype, "numRadioButtons", {
            /**
            * 组内单选按钮数量
            * @member egret.RadioButtonGroup#numRadioButtons
            */
            get: function () {
                return this.radioButtons.length;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(RadioButtonGroup.prototype, "selectedValue", {
            /**
            * 当前被选中的单选按钮的value属性值。注意，此属性仅当目标RadioButton在显示列表时有效。
            * @member egret.RadioButtonGroup#selectedValue
            */
            get: function () {
                if (this.selection) {
                    return this.selection.value != null ? this.selection.value : this.selection.label;
                }
                return null;
            },
            set: function (value) {
                this._selectedValue = value;
                if (value == null) {
                    this._setSelection(null, false);
                    return;
                }
                var n = this.numRadioButtons;
                for (var i = 0; i < n; i++) {
                    var radioButton = this.getRadioButtonAt(i);
                    if (radioButton.value == value || radioButton.label == value) {
                        this.changeSelection(i, false);
                        this._selectedValue = null;
                        egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);

                        break;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(RadioButtonGroup.prototype, "selection", {
            /**
            * 当前被选中的单选按钮引用,注意，此属性仅当目标RadioButton在显示列表时有效。
            * @member egret.RadioButtonGroup#selection
            */
            get: function () {
                return this._selection;
            },
            set: function (value) {
                if (this._selection == value)
                    return;
                this._setSelection(value, false);
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 获取指定索引的单选按钮
        * @method egret.RadioButtonGroup#getRadioButtonAt
        * @param index {number} 单选按钮的索引
        * @returns {RadioButton}
        */
        RadioButtonGroup.prototype.getRadioButtonAt = function (index) {
            if (index >= 0 && index < this.numRadioButtons)
                return this.radioButtons[index];

            return null;
        };

        /**
        * 添加单选按钮到组内
        * @method egret.RadioButtonGroup#_addInstance
        * @param instance {RadioButton}
        */
        RadioButtonGroup.prototype._addInstance = function (instance) {
            instance.addEventListener(egret.Event.REMOVED, this.radioButton_removedHandler, this);

            this.radioButtons.push(instance);
            this.radioButtons.sort(breadthOrderCompare);
            for (var i = 0; i < this.radioButtons.length; i++)
                this.radioButtons[i]._indexNumber = i;
            if (this._selectedValue)
                this.selectedValue = this._selectedValue;
            if (instance.selected == true)
                this.selection = instance;

            instance._radioButtonGroup = this;
            instance.invalidateSkinState();

            this.dispatchEventWith("numRadioButtonsChanged");

            function breadthOrderCompare(a, b) {
                var aParent = a.parent;
                var bParent = b.parent;

                if (!aParent || !bParent)
                    return 0;

                var aNestLevel = (a instanceof egret.UIComponent) ? a.nestLevel : -1;
                var bNestLevel = (b instanceof egret.UIComponent) ? b.nestLevel : -1;

                var aIndex = 0;
                var bIndex = 0;

                if (aParent == bParent) {
                    if ("getElementIndex" in aParent && "ownerChanged" in a)
                        aIndex = aParent.getElementIndex(a);
                    else
                        aIndex = aParent.getChildIndex(a);

                    if ("getElementIndex" in bParent && "ownerChanged" in b)
                        bIndex = bParent.getElementIndex(b);
                    else
                        bIndex = bParent.getChildIndex(b);
                }

                if (aNestLevel > bNestLevel || aIndex > bIndex)
                    return 1;
                else if (aNestLevel < bNestLevel || bIndex > aIndex)
                    return -1;
                else if (a == b)
                    return 0;
                else
                    return breadthOrderCompare(aParent, bParent);
            }
        };

        /**
        * 从组里移除单选按钮
        * @method egret.RadioButtonGroup#_removeInstance
        * @param instance {RadioButton}
        */
        RadioButtonGroup.prototype._removeInstance = function (instance) {
            this.doRemoveInstance(instance, false);
        };

        /**
        * 执行从组里移除单选按钮
        */
        RadioButtonGroup.prototype.doRemoveInstance = function (instance, addListener) {
            if (typeof addListener === "undefined") { addListener = true; }
            if (instance) {
                var foundInstance = false;
                for (var i = 0; i < this.numRadioButtons; i++) {
                    var rb = this.getRadioButtonAt(i);

                    if (foundInstance) {
                        rb._indexNumber = rb._indexNumber - 1;
                    } else if (rb == instance) {
                        if (addListener)
                            instance.addEventListener(egret.Event.ADDED, this.radioButton_addedHandler, this);
                        if (instance == this._selection)
                            this._selection = null;

                        instance._radioButtonGroup = null;
                        instance.invalidateSkinState();
                        this.radioButtons.splice(i, 1);
                        foundInstance = true;
                        i--;
                    }
                }

                if (foundInstance)
                    this.dispatchEventWith("numRadioButtonsChanged");
            }
        };

        /**
        * 设置选中的单选按钮
        * @method egret.RadioButtonGroup#_setSelection
        * @param value {RadioButton}
        * @param fireChange {boolean}
        */
        RadioButtonGroup.prototype._setSelection = function (value, fireChange) {
            if (typeof fireChange === "undefined") { fireChange = true; }
            if (this._selection == value)
                return;

            if (!value) {
                if (this.selection) {
                    this._selection.selected = false;
                    this._selection = null;
                    if (fireChange)
                        this.dispatchEventWith(egret.Event.CHANGE);
                }
            } else {
                var n = this.numRadioButtons;
                for (var i = 0; i < n; i++) {
                    if (value == this.getRadioButtonAt(i)) {
                        this.changeSelection(i, fireChange);
                        break;
                    }
                }
            }
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);
        };

        /**
        * 改变选中项
        */
        RadioButtonGroup.prototype.changeSelection = function (index, fireChange) {
            if (typeof fireChange === "undefined") { fireChange = true; }
            var rb = this.getRadioButtonAt(index);
            if (rb && rb != this._selection) {
                if (this._selection)
                    this._selection.selected = false;
                this._selection = rb;
                this._selection.selected = true;
                if (fireChange)
                    this.dispatchEventWith(egret.Event.CHANGE);
            }
        };

        /**
        * 单选按钮添加到显示列表
        */
        RadioButtonGroup.prototype.radioButton_addedHandler = function (event) {
            var rb = (event.target);
            if (rb) {
                rb.removeEventListener(egret.Event.ADDED, this.radioButton_addedHandler, this);
                this._addInstance(rb);
            }
        };

        /**
        * 单选按钮从显示列表移除
        */
        RadioButtonGroup.prototype.radioButton_removedHandler = function (event) {
            var rb = (event.target);
            if (rb) {
                rb.removeEventListener(egret.Event.REMOVED, this.radioButton_removedHandler, this);
                this.doRemoveInstance(rb);
            }
        };
        RadioButtonGroup.groupCount = 0;
        return RadioButtonGroup;
    })(egret.EventDispatcher);
    egret.RadioButtonGroup = RadioButtonGroup;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.RadioButton
    * @classdesc
    * 单选按钮
    * @extends egret.ToggleButtonBase
    */
    var RadioButton = (function (_super) {
        __extends(RadioButton, _super);
        /**
        * 构造函数
        * @method egret.RadioButton#constructor
        */
        function RadioButton() {
            _super.call(this);
            /**
            * 在RadioButtonGroup中的索引
            * @member egret.RadioButton#_indexNumber
            */
            this._indexNumber = 0;
            /**
            * 所属的RadioButtonGroup
            * @member egret.RadioButton#_radioButtonGroup
            */
            this._radioButtonGroup = null;
            this.groupChanged = false;
            this._groupName = "radioGroup";
            this.hostComponentKey = "egret.RadioButton";
            this.groupName = "radioGroup";
        }
        Object.defineProperty(RadioButton.prototype, "enabled", {
            /**
            * @member egret.RadioButton#enabled
            */
            get: function () {
                if (!this._enabled)
                    return false;
                return !this._radioButtonGroup || this._radioButtonGroup.enabled;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(RadioButton.prototype, "group", {
            /**
            * 此单选按钮所属的组。同一个组的多个单选按钮之间互斥。
            * 若不设置此属性，则根据groupName属性自动创建一个唯一的RadioButtonGroup。
            * @member egret.RadioButton#group
            */
            get: function () {
                if (!this._group && this._groupName) {
                    if (!RadioButton.automaticRadioButtonGroups)
                        RadioButton.automaticRadioButtonGroups = {};
                    var g = RadioButton.automaticRadioButtonGroups[this._groupName];
                    if (!g) {
                        g = new egret.RadioButtonGroup();
                        g._name = this._groupName;
                        RadioButton.automaticRadioButtonGroups[this._groupName] = g;
                    }
                    this._group = g;
                }
                return this._group;
            },
            set: function (value) {
                if (this._group == value)
                    return;
                if (this._radioButtonGroup)
                    this._radioButtonGroup._removeInstance(this);
                this._group = value;
                this._groupName = value ? this.group._name : "radioGroup";
                this.groupChanged = true;

                this.invalidateProperties();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(RadioButton.prototype, "groupName", {
            /**
            * 所属组的名称,具有相同组名的多个单选按钮之间互斥。默认值:"radioGroup"。
            * 可以把此属性当做设置组的一个简便方式，作用与设置group属性相同,。
            * @member egret.RadioButton#groupName
            */
            get: function () {
                return this._groupName;
            },
            set: function (value) {
                if (!value || value == "")
                    return;
                this._groupName = value;
                if (this._radioButtonGroup)
                    this._radioButtonGroup._removeInstance(this);
                this._group = null;
                this.groupChanged = true;

                this.invalidateProperties();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @inheritDoc
        */
        RadioButton.prototype._setSelected = function (value) {
            _super.prototype._setSelected.call(this, value);
            this.invalidateDisplayList();
        };

        Object.defineProperty(RadioButton.prototype, "value", {
            /**
            * 与此单选按钮关联的自定义数据。
            * 当被点击时，所属的RadioButtonGroup对象会把此属性赋值给ItemClickEvent.item属性并抛出事件。
            * @member egret.RadioButton#value
            */
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value == value)
                    return;

                this._value = value;

                if (this.selected && this.group)
                    egret.UIEvent.dispatchUIEvent(this.group, egret.UIEvent.VALUE_COMMIT);
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.RadioButton#commitProperties
        */
        RadioButton.prototype.commitProperties = function () {
            if (this.groupChanged) {
                this.addToGroup();
                this.groupChanged = false;
            }
            _super.prototype.commitProperties.call(this);
        };

        /**
        * @method egret.RadioButton#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        RadioButton.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            if (this.group) {
                if (this.selected)
                    this._group.selection = this;
                else if (this.group.selection == this)
                    this._group.selection = null;
            }
        };

        /**
        * @method egret.RadioButton#buttonReleased
        */
        RadioButton.prototype.buttonReleased = function () {
            if (!this.enabled || this.selected)
                return;
            if (!this._radioButtonGroup)
                this.addToGroup();
            _super.prototype.buttonReleased.call(this);
            this.group._setSelection(this);
        };

        /**
        * 添此单选按钮加到组
        */
        RadioButton.prototype.addToGroup = function () {
            var g = this.group;
            if (g)
                g._addInstance(this);
            return g;
        };
        return RadioButton;
    })(egret.ToggleButtonBase);
    egret.RadioButton = RadioButton;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Group
    * @classdesc
    * 自动布局容器
    * @extends egret.GroupBase
    * @implements egret.IVisualElementContainer
    */
    var Group = (function (_super) {
        __extends(Group, _super);
        /**
        * @method egret.Group#constructor
        */
        function Group() {
            _super.call(this);
            /**
            * createChildren()方法已经执行过的标志
            */
            this.createChildrenCalled = false;
            /**
            * elementsContent改变标志
            */
            this.elementsContentChanged = false;
            this._elementsContent = [];
        }
        /**
        * @method egret.Group#createChildren
        */
        Group.prototype.createChildren = function () {
            _super.prototype.createChildren.call(this);
            this.createChildrenCalled = true;
            if (this.elementsContentChanged) {
                this.elementsContentChanged = false;
                this.setElementsContent(this._elementsContent);
            }
        };

        /**
        * 返回子元素列表
        */
        Group.prototype._getElementsContent = function () {
            return this._elementsContent;
        };

        Object.defineProperty(Group.prototype, "elementsContent", {
            /**
            * 设置容器子对象数组 。数组包含要添加到容器的子项列表，之前的已存在于容器中的子项列表被全部移除后添加列表里的每一项到容器。
            * 设置该属性时会对您输入的数组进行一次浅复制操作，所以您之后对该数组的操作不会影响到添加到容器的子项列表数量。
            */
            set: function (value) {
                if (value == null)
                    value = [];
                if (value == this._elementsContent)
                    return;
                if (this.createChildrenCalled) {
                    this.setElementsContent(value);
                } else {
                    this.elementsContentChanged = true;
                    for (var i = this._elementsContent.length - 1; i >= 0; i--) {
                        this._elementRemoved(this._elementsContent[i], i);
                    }
                    this._elementsContent = value;
                }
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 设置容器子对象列表
        */
        Group.prototype.setElementsContent = function (value) {
            var i;

            for (i = this._elementsContent.length - 1; i >= 0; i--) {
                this._elementRemoved(this._elementsContent[i], i);
            }

            this._elementsContent = value.concat();

            var n = this._elementsContent.length;
            for (i = 0; i < n; i++) {
                var elt = this._elementsContent[i];

                if (elt.parent && "removeElement" in elt.parent)
                    (elt.parent).removeElement(elt);
                else if (elt.owner && "removeElement" in elt.owner)
                    (elt.owner).removeElement(elt);

                this._elementAdded(elt, i);
            }
        };

        Object.defineProperty(Group.prototype, "numElements", {
            /**
            * @member egret.Group#numElements
            */
            get: function () {
                return this._elementsContent.length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.Group#getElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        Group.prototype.getElementAt = function (index) {
            this.checkForRangeError(index);
            return this._elementsContent[index];
        };

        Group.prototype.checkForRangeError = function (index, addingElement) {
            if (typeof addingElement === "undefined") { addingElement = false; }
            var maxIndex = this._elementsContent.length - 1;

            if (addingElement)
                maxIndex++;

            if (index < 0 || index > maxIndex)
                throw new RangeError("索引:\"" + index + "\"超出可视元素索引范围");
        };

        /**
        * @method egret.Group#addElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        Group.prototype.addElement = function (element) {
            var index = this.numElements;

            if (element.parent == this)
                index = this.numElements - 1;

            return this.addElementAt(element, index);
        };

        /**
        * @method egret.Group#addElementAt
        * @param element {IVisualElement}
        * @param index {number}
        * @returns {IVisualElement}
        */
        Group.prototype.addElementAt = function (element, index) {
            if (element == this)
                return element;

            this.checkForRangeError(index, true);

            var host = element.owner;
            if (host == this || element.parent == this) {
                this.setElementIndex(element, index);
                return element;
            } else if (host && "removeElement" in host) {
                (element.owner).removeElement(element);
            }

            this._elementsContent.splice(index, 0, element);

            if (!this.elementsContentChanged)
                this._elementAdded(element, index);

            return element;
        };

        /**
        * @method egret.Group#removeElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        Group.prototype.removeElement = function (element) {
            return this.removeElementAt(this.getElementIndex(element));
        };

        /**
        * @method egret.Group#removeElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        Group.prototype.removeElementAt = function (index) {
            this.checkForRangeError(index);

            var element = this._elementsContent[index];

            if (!this.elementsContentChanged)
                this._elementRemoved(element, index);

            this._elementsContent.splice(index, 1);

            return element;
        };

        /**
        * @method egret.Group#removeAllElements
        */
        Group.prototype.removeAllElements = function () {
            for (var i = this.numElements - 1; i >= 0; i--) {
                this.removeElementAt(i);
            }
        };

        /**
        * @method egret.Group#getElementIndex
        * @param element {IVisualElement}
        * @returns {number}
        */
        Group.prototype.getElementIndex = function (element) {
            return this._elementsContent.indexOf(element);
        };

        /**
        * @method egret.Group#setElementIndex
        * @param element {IVisualElement}
        * @param index {number}
        */
        Group.prototype.setElementIndex = function (element, index) {
            this.checkForRangeError(index);

            var oldIndex = this.getElementIndex(element);
            if (oldIndex == -1 || oldIndex == index)
                return;

            if (!this.elementsContentChanged)
                this._elementRemoved(element, oldIndex, false);

            this._elementsContent.splice(oldIndex, 1);
            this._elementsContent.splice(index, 0, element);

            if (!this.elementsContentChanged)
                this._elementAdded(element, index, false);
        };

        /**
        * @method egret.Group#swapElements
        * @param element1 {IVisualElement}
        * @param element2 {IVisualElement}
        */
        Group.prototype.swapElements = function (element1, element2) {
            this.swapElementsAt(this.getElementIndex(element1), this.getElementIndex(element2));
        };

        /**
        * @method egret.Group#swapElementsAt
        * @param index1 {number}
        * @param index2 {number}
        */
        Group.prototype.swapElementsAt = function (index1, index2) {
            this.checkForRangeError(index1);
            this.checkForRangeError(index2);

            if (index1 > index2) {
                var temp = index2;
                index2 = index1;
                index1 = temp;
            } else if (index1 == index2)
                return;

            var elementsContent = this._elementsContent;

            var element1 = elementsContent[index1];
            var element2 = elementsContent[index2];
            if (!this.elementsContentChanged) {
                this._elementRemoved(element1, index1, false);
                this._elementRemoved(element2, index2, false);
            }

            elementsContent[index1] = element2;
            elementsContent[index2] = element1;

            if (!this.elementsContentChanged) {
                this._elementAdded(element2, index1, false);
                this._elementAdded(element1, index2, false);
            }
        };

        /**
        * 添加一个显示元素到容器
        * @method egret.Group#_elementAdded
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        Group.prototype._elementAdded = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (element instanceof egret.DisplayObject) {
                var childDO = element;
                this._addToDisplayListAt(childDO, index, notifyListeners);
            }

            if (notifyListeners) {
                if (this.hasEventListener(egret.ElementExistenceEvent.ELEMENT_ADD))
                    egret.ElementExistenceEvent.dispatchElementExistenceEvent(this, egret.ElementExistenceEvent.ELEMENT_ADD, element, index);
            }

            this.invalidateSize();
            this.invalidateDisplayList();
        };

        /**
        * 从容器移除一个显示元素
        * @method egret.Group#_elementRemoved
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        Group.prototype._elementRemoved = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (notifyListeners) {
                if (this.hasEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE))
                    egret.ElementExistenceEvent.dispatchElementExistenceEvent(this, egret.ElementExistenceEvent.ELEMENT_REMOVE, element, index);
            }

            if (element instanceof egret.DisplayObject && element.parent == this) {
                var childDO = element;
                this._removeFromDisplayList(childDO, notifyListeners);
            }

            this.invalidateSize();
            this.invalidateDisplayList();
        };

        /**
        * @method egret.Group#addChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        Group.prototype.addChild = function (child) {
            throw (new Error("addChild()" + Group.errorStr + "addElement()代替"));
        };

        /**
        * @method egret.Group#addChildAt
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        * @returns {DisplayObject}
        */
        Group.prototype.addChildAt = function (child, index) {
            throw (new Error("addChildAt()" + Group.errorStr + "addElementAt()代替"));
        };

        /**
        * @method egret.Group#removeChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        Group.prototype.removeChild = function (child) {
            throw (new Error("removeChild()" + Group.errorStr + "removeElement()代替"));
        };

        /**
        * @method egret.Group#removeChildAt
        * @deprecated
        * @param index {number}
        * @returns {DisplayObject}
        */
        Group.prototype.removeChildAt = function (index) {
            throw (new Error("removeChildAt()" + Group.errorStr + "removeElementAt()代替"));
        };

        /**
        * @method egret.Group#setChildIndex
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        */
        Group.prototype.setChildIndex = function (child, index) {
            throw (new Error("setChildIndex()" + Group.errorStr + "setElementIndex()代替"));
        };

        /**
        * @method egret.Group#swapChildren
        * @deprecated
        * @param child1 {DisplayObject}
        * @param child2 {DisplayObject}
        */
        Group.prototype.swapChildren = function (child1, child2) {
            throw (new Error("swapChildren()" + Group.errorStr + "swapElements()代替"));
        };

        /**
        * @method egret.Group#swapChildrenAt
        * @deprecated
        * @param index1 {number}
        * @param index2 {number}
        */
        Group.prototype.swapChildrenAt = function (index1, index2) {
            throw (new Error("swapChildrenAt()" + Group.errorStr + "swapElementsAt()代替"));
        };
        Group.errorStr = "在此组件中不可用，若此组件为容器类，请使用";
        return Group;
    })(egret.GroupBase);
    egret.Group = Group;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ViewStack
    * @classdesc
    * 层级堆叠容器,一次只显示一个子对象。
    * @extends egret.Group
    * @implements egret.IViewStack
    * @implements egret.ICollection
    */
    var ViewStack = (function (_super) {
        __extends(ViewStack, _super);
        /**
        * 构造函数
        * @method egret.ViewStack#constructor
        */
        function ViewStack() {
            _super.call(this);
            this._createAllChildren = false;
            /**
            * 在属性提交前缓存选中项索引
            */
            this.proposedSelectedIndex = ViewStack.NO_PROPOSED_SELECTION;
            this._selectedIndex = -1;
            this.notifyTabBar = false;
            /**
            * 子项显示列表顺序发生改变。
            */
            this.childOrderingChanged = false;
            this._setLayout(new egret.BasicLayout());
        }
        Object.defineProperty(ViewStack.prototype, "layout", {
            /**
            * 此容器的布局对象为只读,默认限制为BasicLayout。
            * @member egret.ViewStack#layout
            */
            get: function () {
                return this._layout;
            },
            set: function (value) {
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(ViewStack.prototype, "createAllChildren", {
            /**
            * 是否立即初始化化所有子项。false表示当子项第一次被显示时再初始化它。默认值false。
            * @member egret.ViewStack#createAllChildren
            */
            get: function () {
                return this._createAllChildren;
            },
            set: function (value) {
                if (this._createAllChildren == value)
                    return;
                this._createAllChildren = value;
                if (this._createAllChildren) {
                    var elements = this._getElementsContent();
                    var length = elements.length;
                    for (var i = 0; i < length; i++) {
                        var element = elements[i];
                        if (element instanceof egret.DisplayObject && element.parent != this) {
                            this.childOrderingChanged = true;
                            this._addToDisplayList(element);
                        }
                    }
                    if (this.childOrderingChanged)
                        this.invalidateProperties();
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ViewStack.prototype, "selectedChild", {
            /**
            * @member egret.ViewStack#selectedChild
            */
            get: function () {
                var index = this.selectedIndex;
                if (index >= 0 && index < this.numElements)
                    return this.getElementAt(index);
                return null;
            },
            set: function (value) {
                var index = this.getElementIndex(value);
                if (index >= 0 && index < this.numElements)
                    this._setSelectedIndex(index);
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(ViewStack.prototype, "selectedIndex", {
            /**
            * @member egret.ViewStack#selectedIndex
            */
            get: function () {
                return this.proposedSelectedIndex != ViewStack.NO_PROPOSED_SELECTION ? this.proposedSelectedIndex : this._selectedIndex;
            },
            set: function (value) {
                this._setSelectedIndex(value);
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 设置选中项索引
        * @method egret.ViewStack#_setSelectedIndex
        * @param value {number}
        * @param notifyListeners {boolean}
        */
        ViewStack.prototype._setSelectedIndex = function (value, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (value == this.selectedIndex) {
                return;
            }

            this.proposedSelectedIndex = value;
            this.invalidateProperties();
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);
            this.notifyTabBar = this.notifyTabBar || notifyListeners;
        };

        /**
        * 添加一个显示元素到容器
        * @method egret.ViewStack#_elementAdded
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        ViewStack.prototype._elementAdded = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (this._createAllChildren) {
                if (element instanceof egret.DisplayObject) {
                    var childDO = element;
                    this._addToDisplayListAt(childDO, index, notifyListeners);
                }
            }
            if (notifyListeners) {
                if (this.hasEventListener(egret.ElementExistenceEvent.ELEMENT_ADD))
                    egret.ElementExistenceEvent.dispatchElementExistenceEvent(this, egret.ElementExistenceEvent.ELEMENT_ADD, element, index);
            }

            element.visible = false;
            element.includeInLayout = false;
            if (this.selectedIndex == -1) {
                this._setSelectedIndex(index, false);
            } else if (index <= this.selectedIndex && this.initialized) {
                this._setSelectedIndex(this.selectedIndex + 1);
            }
            this.dispatchCoEvent(egret.CollectionEventKind.ADD, index, -1, [element.name]);
        };

        /**
        * 从容器移除一个显示元素
        * @method egret.ViewStack#_elementRemoved
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        ViewStack.prototype._elementRemoved = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            _super.prototype._elementRemoved.call(this, element, index, notifyListeners);
            element.visible = true;
            element.includeInLayout = true;
            if (index == this.selectedIndex) {
                if (this.numElements > 0) {
                    if (index == 0) {
                        this.proposedSelectedIndex = 0;
                        this.invalidateProperties();
                    } else
                        this._setSelectedIndex(0, false);
                } else
                    this._setSelectedIndex(-1);
            } else if (index < this.selectedIndex) {
                this._setSelectedIndex(this.selectedIndex - 1);
            }
            this.dispatchCoEvent(egret.CollectionEventKind.REMOVE, index, -1, [element.name]);
        };

        /**
        * @method egret.ViewStack#commitProperties
        */
        ViewStack.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);
            if (this.proposedSelectedIndex != ViewStack.NO_PROPOSED_SELECTION) {
                this.commitSelection(this.proposedSelectedIndex);
                this.proposedSelectedIndex = ViewStack.NO_PROPOSED_SELECTION;
            }

            if (this.childOrderingChanged) {
                this.childOrderingChanged = false;
                var elements = this._getElementsContent();
                var length = elements.length;
                for (var i = 0; i < length; i++) {
                    var element = elements[i];
                    if (element instanceof egret.DisplayObject && element.parent == this) {
                        this._addToDisplayList(element);
                    }
                }
            }

            if (this.notifyTabBar) {
                this.notifyTabBar = true;
                this.dispatchEventWith("IndexChanged"); //通知TabBar自己的选中项发生改变
            }
        };

        ViewStack.prototype.commitSelection = function (newIndex) {
            var oldIndex = this._selectedIndex;
            if (newIndex >= 0 && newIndex < this.numElements) {
                this._selectedIndex = newIndex;
                if (this._selectedChild && this._selectedChild.parent == this) {
                    this._selectedChild.visible = false;
                    this._selectedChild.includeInLayout = false;
                }
                this._selectedChild = this.getElementAt(this._selectedIndex);
                this._selectedChild.visible = true;
                this._selectedChild.includeInLayout = true;
                if (this._selectedChild.parent != this && this._selectedChild instanceof egret.DisplayObject) {
                    this._addToDisplayList((this._selectedChild));
                    if (!this.childOrderingChanged) {
                        this.childOrderingChanged = true;
                    }
                }
            } else {
                this._selectedChild = null;
                this._selectedIndex = -1;
            }
            this.invalidateSize();
            this.invalidateDisplayList();
        };

        Object.defineProperty(ViewStack.prototype, "length", {
            /**
            * @member egret.ViewStack#length
            */
            get: function () {
                return this.numElements;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.ViewStack#getItemAt
        * @param index {number}
        * @returns {any}
        */
        ViewStack.prototype.getItemAt = function (index) {
            var element = this.getElementAt(index);
            if (element)
                return element.name;
            return "";
        };

        /**
        * @method egret.ViewStack#getItemIndex
        * @param item {any}
        * @returns {number}
        */
        ViewStack.prototype.getItemIndex = function (item) {
            var list = this._getElementsContent();
            var length = list.length;
            for (var i = 0; i < length; i++) {
                if (list[i].name === item) {
                    return i;
                }
            }
            return -1;
        };

        /**
        * 抛出事件
        */
        ViewStack.prototype.dispatchCoEvent = function (kind, location, oldLocation, items, oldItems) {
            if (typeof kind === "undefined") { kind = null; }
            if (typeof location === "undefined") { location = -1; }
            if (typeof oldLocation === "undefined") { oldLocation = -1; }
            if (typeof items === "undefined") { items = null; }
            if (typeof oldItems === "undefined") { oldItems = null; }
            egret.CollectionEvent.dispatchCollectionEvent(this, egret.CollectionEvent.COLLECTION_CHANGE, kind, location, oldLocation, items, oldItems);
        };
        ViewStack.NO_PROPOSED_SELECTION = -2;
        return ViewStack;
    })(egret.Group);
    egret.ViewStack = ViewStack;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Skin
    * @classdesc
    * 含有视图状态功能的皮肤基类。注意：为了减少嵌套层级，此皮肤没有继承显示对象，若需要显示对象版本皮肤，请使用Skin。
    * @see org.flexlite.domUI.components.supportClasses.Skin
    * @extends egret.EventDispatcher
    * @implements egret.IStateClient
    * @implements egret.ISkin
    * @implements egret.IContainer
    */
    var Skin = (function (_super) {
        __extends(Skin, _super);
        /**
        * 构造函数
        * @method egret.Skin#constructor
        */
        function Skin() {
            _super.call(this);
            /**
            * 组件的最大测量宽度,仅影响measuredWidth属性的取值范围。
            * @member egret.Skin#maxWidth
            */
            this.maxWidth = 10000;
            /**
            * 组件的最小测量宽度,此属性设置为大于maxWidth的值时无效。仅影响measuredWidth属性的取值范围。
            * @member egret.Skin#minWidth
            */
            this.minWidth = 0;
            /**
            * 组件的最大测量高度,仅影响measuredHeight属性的取值范围。
            * @member egret.Skin#maxHeight
            */
            this.maxHeight = 10000;
            /**
            * 组件的最小测量高度,此属性设置为大于maxHeight的值时无效。仅影响measuredHeight属性的取值范围。
            * @member egret.Skin#minHeight
            */
            this.minHeight = 0;
            /**
            * 组件宽度
            * @member egret.Skin#width
            */
            this.width = NaN;
            /**
            * 组件高度
            * @member egret.Skin#height
            */
            this.height = NaN;
            this._initialized = false;
            this._elementsContent = [];
            //========================state相关函数===============start=========================
            this._states = [];
            this.initialized = false;
        }
        /**
        * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
        * 请务必调用super.createChildren()以完成父类组件的初始化
        * @method egret.Skin#createChildren
        */
        Skin.prototype.createChildren = function () {
        };

        Object.defineProperty(Skin.prototype, "hostComponent", {
            /**
            * @member egret.Skin#hostComponent
            */
            get: function () {
                return this._hostComponent;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                this._setHostComponent(value);
            },
            enumerable: true,
            configurable: true
        });


        Skin.prototype._setHostComponent = function (value) {
            if (this._hostComponent == value)
                return;
            var i;
            if (this._hostComponent) {
                for (i = this._elementsContent.length - 1; i >= 0; i--) {
                    this._elementRemoved(this._elementsContent[i], i);
                }
            }

            this._hostComponent = value;
            if (!this._initialized) {
                this._initialized = true;
                this.createChildren();
            }

            if (this._hostComponent) {
                var n = this._elementsContent.length;
                for (i = 0; i < n; i++) {
                    this._elementAdded(this._elementsContent[i], i);
                }

                this.initializeStates();

                if (this.currentStateChanged) {
                    this.commitCurrentState();
                }
            }
        };

        /**
        * 返回子元素列表
        */
        Skin.prototype._getElementsContent = function () {
            return this._elementsContent;
        };

        Object.defineProperty(Skin.prototype, "elementsContent", {
            /**
            * 设置容器子对象数组 。数组包含要添加到容器的子项列表，之前的已存在于容器中的子项列表被全部移除后添加列表里的每一项到容器。
            * 设置该属性时会对您输入的数组进行一次浅复制操作，所以您之后对该数组的操作不会影响到添加到容器的子项列表数量。
            */
            set: function (value) {
                if (value == null)
                    value = [];
                if (value == this._elementsContent)
                    return;
                if (this._hostComponent) {
                    var i;
                    for (i = this._elementsContent.length - 1; i >= 0; i--) {
                        this._elementRemoved(this._elementsContent[i], i);
                    }

                    this._elementsContent = value.concat();

                    var n = this._elementsContent.length;
                    for (i = 0; i < n; i++) {
                        var elt = this._elementsContent[i];

                        if (elt.parent && "removeElement" in elt.parent)
                            (elt.parent).removeElement(elt);
                        else if (elt.owner && "removeElement" in elt.owner)
                            (elt.owner).removeElement(elt);
                        this._elementAdded(elt, i);
                    }
                } else {
                    this._elementsContent = value.concat();
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Skin.prototype, "numElements", {
            /**
            * @member egret.Skin#numElements
            */
            get: function () {
                return this._elementsContent.length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.Skin#getElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        Skin.prototype.getElementAt = function (index) {
            this.checkForRangeError(index);
            return this._elementsContent[index];
        };

        Skin.prototype.checkForRangeError = function (index, addingElement) {
            if (typeof addingElement === "undefined") { addingElement = false; }
            var maxIndex = this._elementsContent.length - 1;

            if (addingElement)
                maxIndex++;

            if (index < 0 || index > maxIndex)
                throw new RangeError("索引:\"" + index + "\"超出可视元素索引范围");
        };

        /**
        * @method egret.Skin#addElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        Skin.prototype.addElement = function (element) {
            var index = this.numElements;

            if (element.owner == this)
                index = this.numElements - 1;

            return this.addElementAt(element, index);
        };

        /**
        * @method egret.Skin#addElementAt
        * @param element {IVisualElement}
        * @param index {number}
        * @returns {IVisualElement}
        */
        Skin.prototype.addElementAt = function (element, index) {
            this.checkForRangeError(index, true);

            var host = element.owner;
            if (host == this) {
                this.setElementIndex(element, index);
                return element;
            } else if (host && "removeElement" in host) {
                host.removeElement(element);
            }

            this._elementsContent.splice(index, 0, element);

            if (this._hostComponent)
                this._elementAdded(element, index);
            else
                element.ownerChanged(this);

            return element;
        };

        /**
        * @method egret.Skin#removeElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        Skin.prototype.removeElement = function (element) {
            return this.removeElementAt(this.getElementIndex(element));
        };

        /**
        * @method egret.Skin#removeElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        Skin.prototype.removeElementAt = function (index) {
            this.checkForRangeError(index);

            var element = this._elementsContent[index];

            if (this._hostComponent)
                this._elementRemoved(element, index);
            else
                element.ownerChanged(null);
            this._elementsContent.splice(index, 1);

            return element;
        };

        /**
        * @method egret.Skin#getElementIndex
        * @param element {IVisualElement}
        * @returns {number}
        */
        Skin.prototype.getElementIndex = function (element) {
            return this._elementsContent.indexOf(element);
        };

        /**
        * @method egret.Skin#setElementIndex
        * @param element {IVisualElement}
        * @param index {number}
        */
        Skin.prototype.setElementIndex = function (element, index) {
            this.checkForRangeError(index);

            var oldIndex = this.getElementIndex(element);
            if (oldIndex == -1 || oldIndex == index)
                return;

            if (this._hostComponent)
                this._elementRemoved(element, oldIndex, false);

            this._elementsContent.splice(oldIndex, 1);
            this._elementsContent.splice(index, 0, element);

            if (this._hostComponent)
                this._elementAdded(element, index, false);
        };

        /**
        * 添加一个显示元素到容器
        * @method egret.Skin#_elementAdded
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        Skin.prototype._elementAdded = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            element.ownerChanged(this);
            if (element instanceof egret.DisplayObject) {
                var childDO = element;
                this._hostComponent._addToDisplayListAt(childDO, index, notifyListeners);
            }

            if (notifyListeners) {
                if (this.hasEventListener(egret.ElementExistenceEvent.ELEMENT_ADD))
                    egret.ElementExistenceEvent.dispatchElementExistenceEvent(this, egret.ElementExistenceEvent.ELEMENT_ADD, element, index);
            }

            this._hostComponent.invalidateSize();
            this._hostComponent.invalidateDisplayList();
        };

        /**
        * 从容器移除一个显示元素
        * @method egret.Skin#_elementRemoved
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        Skin.prototype._elementRemoved = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (notifyListeners) {
                if (this.hasEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE))
                    egret.ElementExistenceEvent.dispatchElementExistenceEvent(this, egret.ElementExistenceEvent.ELEMENT_REMOVE, element, index);
            }

            if (element instanceof egret.DisplayObject && element.parent == this._hostComponent) {
                var childDO = element;
                this._hostComponent._removeFromDisplayList(childDO, notifyListeners);
            }

            element.ownerChanged(null);
            this._hostComponent.invalidateSize();
            this._hostComponent.invalidateDisplayList();
        };

        Object.defineProperty(Skin.prototype, "states", {
            /**
            * 为此组件定义的视图状态。
            * @member egret.StateClientHelper#states
            */
            get: function () {
                return this._states;
            },
            set: function (value) {
                this._setStates(value);
            },
            enumerable: true,
            configurable: true
        });

        Skin.prototype._setStates = function (value) {
            if (!value)
                value = [];
            if (typeof (value[0]) == "string") {
                var length = value.length;
                for (var i = 0; i < length; i++) {
                    var state = new egret.State(value[i], []);
                    value[i] = state;
                }
            }

            this._states = value;
            this.currentStateChanged = true;
            this.requestedCurrentState = this._currentState;
            if (!this.hasState(this.requestedCurrentState)) {
                this.requestedCurrentState = this.getDefaultState();
            }
        };

        Object.defineProperty(Skin.prototype, "currentState", {
            /**
            * 组件的当前视图状态。将其设置为 "" 或 null 可将组件重置回其基本状态。
            * @member egret.StateClientHelper#currentState
            */
            get: function () {
                if (this.currentStateChanged)
                    return this.requestedCurrentState;
                return this._currentState ? this._currentState : this.getDefaultState();
            },
            set: function (value) {
                if (!value)
                    value = this.getDefaultState();
                if (value != this.currentState && value && this.currentState) {
                    this.requestedCurrentState = value;
                    this.currentStateChanged = true;
                    if (this._hostComponent) {
                        this.commitCurrentState();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 返回是否含有指定名称的视图状态
        * @method egret.Skin#hasState
        * @param stateName {string}
        * @returns {boolean}
        */
        Skin.prototype.hasState = function (stateName) {
            return (this.getState(stateName) != null);
        };

        /**
        * 返回默认状态
        */
        Skin.prototype.getDefaultState = function () {
            if (this._states.length > 0) {
                return this._states[0].name;
            }
            return null;
        };

        /**
        * 应用当前的视图状态。子类覆盖此方法在视图状态发生改变时执行相应更新操作。
        * @method egret.Skin#commitCurrentState
        */
        Skin.prototype.commitCurrentState = function () {
            if (!this.currentStateChanged)
                return;
            this.currentStateChanged = false;
            var destination = this.getState(this.requestedCurrentState);
            if (!destination) {
                this.requestedCurrentState = this.getDefaultState();
            }
            var oldState = this._currentState ? this._currentState : "";
            if (this.hasEventListener(egret.StateChangeEvent.CURRENT_STATE_CHANGING)) {
                egret.StateChangeEvent.dispatchStateChangeEvent(this, egret.StateChangeEvent.CURRENT_STATE_CHANGING, oldState, this.requestedCurrentState ? this.requestedCurrentState : "");
            }

            this.removeState(this._currentState);
            this._currentState = this.requestedCurrentState;

            if (this._currentState) {
                this.applyState(this._currentState);
            }

            if (this.hasEventListener(egret.StateChangeEvent.CURRENT_STATE_CHANGE)) {
                egret.StateChangeEvent.dispatchStateChangeEvent(this, egret.StateChangeEvent.CURRENT_STATE_CHANGE, oldState, this._currentState ? this._currentState : "");
            }
        };

        /**
        * 通过名称返回视图状态
        */
        Skin.prototype.getState = function (stateName) {
            if (!stateName)
                return null;
            var states = this._states;
            var length = states.length;
            for (var i = 0; i < length; i++) {
                var state = states[i];
                if (state.name == stateName)
                    return state;
            }
            return null;
        };

        /**
        * 移除指定的视图状态以及所依赖的所有父级状态，除了与新状态的共同状态外
        */
        Skin.prototype.removeState = function (stateName) {
            var state = this.getState(stateName);
            if (state) {
                var overrides = state.overrides;
                for (var i = overrides.length - 1; i >= 0; i--)
                    overrides[i].remove(this);
            }
        };

        /**
        * 应用新状态
        */
        Skin.prototype.applyState = function (stateName) {
            var state = this.getState(stateName);
            if (state) {
                var overrides = state.overrides;
                var length = overrides.length;
                for (var i = 0; i < length; i++)
                    overrides[i].apply((this));
            }
        };

        /**
        * 初始化所有视图状态
        * @method egret.StateClientHelper#initializeStates
        */
        Skin.prototype.initializeStates = function () {
            if (this.initialized)
                return;
            this.initialized = true;
            var states = this._states;
            var length = states.length;
            for (var i = 0; i < length; i++) {
                var state = (states[i]);
                state.initialize(this);
            }
        };
        return Skin;
    })(egret.EventDispatcher);
    egret.Skin = Skin;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DataGroup
    * @classdesc
    * 数据项目的容器基类
    * 将数据项目转换为可视元素以进行显示。
    * @extends egret.GroupBase
    */
    var DataGroup = (function (_super) {
        __extends(DataGroup, _super);
        /**
        * 构造函数
        * @method egret.DataGroup#constructor
        */
        function DataGroup() {
            _super.call(this);
            this.useVirtualLayoutChanged = false;
            this.rendererToClassMap = [];
            this.freeRenderers = [];
            /**
            * 是否创建了新的项呈示器标志
            */
            this.createNewRendererFlag = false;
            this.dataProviderChanged = false;
            /**
            * 对象池字典
            */
            this.recyclerDic = [];
            this.itemRendererSkinNameChange = false;
            /**
            * 正在进行虚拟布局阶段
            */
            this.virtualLayoutUnderway = false;
            this.typicalItemChanged = false;
            /**
            * 索引到项呈示器的转换数组
            */
            this.indexToRenderer = [];
            /**
            * 清理freeRenderer标志
            */
            this.cleanFreeRenderer = false;
            /**
            * 正在更新数据项的标志
            */
            this.renderersBeingUpdated = false;
        }
        Object.defineProperty(DataGroup.prototype, "layout", {
            /**
            * @member egret.DataGroup#layout
            */
            get: function () {
                return this._layout;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (value == this.layout)
                    return;

                if (this.layout) {
                    this.layout.typicalLayoutRect = null;
                    this.layout.removeEventListener("useVirtualLayoutChanged", this.layout_useVirtualLayoutChangedHandler, this);
                }

                if (this.layout && value && (this.layout.useVirtualLayout != value.useVirtualLayout))
                    this.changeUseVirtualLayout();
                this._setLayout(value);
                if (value) {
                    value.typicalLayoutRect = this.typicalLayoutRect;
                    value.addEventListener("useVirtualLayoutChanged", this.layout_useVirtualLayoutChangedHandler, this);
                }
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 是否使用虚拟布局标记改变
        */
        DataGroup.prototype.layout_useVirtualLayoutChangedHandler = function (event) {
            this.changeUseVirtualLayout();
        };

        /**
        * @method egret.DataGroup#setVirtualElementIndicesInView
        * @param startIndex {number}
        * @param endIndex {number}
        */
        DataGroup.prototype.setVirtualElementIndicesInView = function (startIndex, endIndex) {
            if (!this.layout || !this.layout.useVirtualLayout)
                return;
            this.virtualRendererIndices = [];
            for (var i = startIndex; i <= endIndex; i++) {
                this.virtualRendererIndices.push(i);
            }
            for (var index in this.indexToRenderer) {
                index = parseInt(index);
                if (this.virtualRendererIndices.indexOf(index) == -1) {
                    this.freeRendererByIndex(index);
                }
            }
        };

        /**
        * @method egret.DataGroup#getVirtualElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        DataGroup.prototype.getVirtualElementAt = function (index) {
            if (index < 0 || index >= this.dataProvider.length)
                return null;
            var element = this.indexToRenderer[index];
            if (!element) {
                var item = this.dataProvider.getItemAt(index);
                var renderer = this.createVirtualRenderer(index);
                this.indexToRenderer[index] = renderer;
                this.updateRenderer(renderer, index, item);
                if (this.createNewRendererFlag) {
                    if ("validateNow" in renderer)
                        renderer.validateNow();
                    this.createNewRendererFlag = false;
                    egret.RendererExistenceEvent.dispatchRendererExistenceEvent(this, egret.RendererExistenceEvent.RENDERER_ADD, renderer, index, item);
                }
                element = renderer;
            }
            return element;
        };

        /**
        * 释放指定索引处的项呈示器
        */
        DataGroup.prototype.freeRendererByIndex = function (index) {
            if (!this.indexToRenderer[index])
                return;
            var renderer = (this.indexToRenderer[index]);
            delete this.indexToRenderer[index];
            if (renderer && renderer instanceof egret.DisplayObject) {
                this.doFreeRenderer(renderer);
            }
        };

        /**
        * 释放指定的项呈示器
        */
        DataGroup.prototype.doFreeRenderer = function (renderer) {
            var rendererFactory = this.rendererToClassMap[renderer.hashCode];
            var hashCode = rendererFactory.hashCode;
            if (!this.freeRenderers[hashCode]) {
                this.freeRenderers[hashCode] = [];
            }
            this.freeRenderers[hashCode].push(renderer);
            renderer.visible = false;
        };

        /**
        * @method egret.DataGroup#invalidateSize
        */
        DataGroup.prototype.invalidateSize = function () {
            if (!this.createNewRendererFlag)
                _super.prototype.invalidateSize.call(this);
        };

        /**
        * 为指定索引创建虚拟的项呈示器
        */
        DataGroup.prototype.createVirtualRenderer = function (index) {
            var item = this.dataProvider.getItemAt(index);
            var renderer;
            var rendererFactory = this.itemToRendererClass(item);
            var hashCode = rendererFactory.hashCode;
            var freeRenderers = this.freeRenderers;
            if (freeRenderers[hashCode] && freeRenderers[hashCode].length > 0) {
                renderer = freeRenderers[hashCode].pop();
                renderer.visible = true;
                return renderer;
            }
            this.createNewRendererFlag = true;
            return this.createOneRenderer(rendererFactory);
        };

        /**
        * 根据rendererClass创建一个Renderer,并添加到显示列表
        */
        DataGroup.prototype.createOneRenderer = function (rendererFactory) {
            var renderer;
            var hashCode = rendererFactory.hashCode;
            var recycler = this.recyclerDic[hashCode];
            if (recycler) {
                renderer = recycler.pop();
                if (recycler.length == 0)
                    delete this.recyclerDic[hashCode];
            }
            if (!renderer) {
                renderer = (rendererFactory.newInstance());
                this.rendererToClassMap[renderer.hashCode] = rendererFactory;
            }
            if (!renderer || !(renderer instanceof egret.DisplayObject))
                return null;
            if (this._itemRendererSkinName) {
                this.setItemRenderSkinName(renderer);
            }
            this._addToDisplayList(renderer);
            renderer.setLayoutBoundsSize(NaN, NaN);
            return renderer;
        };

        /**
        * 设置项呈示器的默认皮肤
        */
        DataGroup.prototype.setItemRenderSkinName = function (renderer) {
            if (!renderer)
                return;
            var comp = renderer;
            if (comp) {
                if (!comp._skinNameExplicitlySet)
                    comp.skinName = this._itemRendererSkinName;
            } else {
                var client = renderer;
                if (client && !client.skinName)
                    client.skinName = this._itemRendererSkinName;
            }
        };

        /**
        * 虚拟布局结束清理不可见的项呈示器
        */
        DataGroup.prototype.finishVirtualLayout = function () {
            if (!this.virtualLayoutUnderway)
                return;
            this.virtualLayoutUnderway = false;
            var found = false;
            for (var hashCode in this.freeRenderers) {
                if (this.freeRenderers[hashCode].length > 0) {
                    found = true;
                    break;
                }
            }
            if (!found)
                return;
            if (!this.cleanTimer) {
                this.cleanTimer = new egret.Timer(3000, 1);
                this.cleanTimer.addEventListener(egret.TimerEvent.TIMER, this.cleanAllFreeRenderer, this);
            }

            //为了提高持续滚动过程中的性能，防止反复地添加移除子项，这里不直接清理而是延迟后在滚动停止时清理一次。
            this.cleanTimer.reset();
            this.cleanTimer.start();
        };

        /**
        * 延迟清理多余的在显示列表中的ItemRenderer。
        */
        DataGroup.prototype.cleanAllFreeRenderer = function (event) {
            if (typeof event === "undefined") { event = null; }
            var renderer;
            var freeRenderers = this.freeRenderers;
            for (var hashCode in freeRenderers) {
                var list = freeRenderers[hashCode];
                var length = list.length;
                for (var i = 0; i < length; i++) {
                    renderer = list[i];
                    renderer.visible = true;
                    this.recycle(renderer);
                }
            }
            this.freeRenderers = [];
            this.cleanFreeRenderer = false;
        };

        /**
        * @method egret.DataGroup#getElementIndicesInView
        * @returns {number}
        */
        DataGroup.prototype.getElementIndicesInView = function () {
            if (this.layout && this.layout.useVirtualLayout)
                return this.virtualRendererIndices ? this.virtualRendererIndices : [];
            return _super.prototype.getElementIndicesInView.call(this);
        };

        /**
        * 更改是否使用虚拟布局
        */
        DataGroup.prototype.changeUseVirtualLayout = function () {
            this.useVirtualLayoutChanged = true;
            this.cleanFreeRenderer = true;
            this.removeDataProviderListener();
            this.invalidateProperties();
        };

        Object.defineProperty(DataGroup.prototype, "dataProvider", {
            /**
            * 列表数据源，请使用实现了ICollection接口的数据类型，例如ArrayCollection
            * @member egret.DataGroup#dataProvider
            */
            get: function () {
                return this._dataProvider;
            },
            set: function (value) {
                if (this._dataProvider == value)
                    return;
                this.removeDataProviderListener();
                this._dataProvider = value;
                this.dataProviderChanged = true;
                this.cleanFreeRenderer = true;
                this.invalidateProperties();
                this.invalidateSize();
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 移除数据源监听
        */
        DataGroup.prototype.removeDataProviderListener = function () {
            if (this._dataProvider)
                this._dataProvider.removeEventListener(egret.CollectionEvent.COLLECTION_CHANGE, this.onCollectionChange, this);
        };

        /**
        * 数据源改变事件处理
        */
        DataGroup.prototype.onCollectionChange = function (event) {
            switch (event.kind) {
                case egret.CollectionEventKind.ADD:
                    this.itemAddedHandler(event.items, event.location);
                    break;
                case egret.CollectionEventKind.MOVE:
                    this.itemMovedHandler(event.items[0], event.location, event.oldLocation);
                    break;
                case egret.CollectionEventKind.REMOVE:
                    this.itemRemovedHandler(event.items, event.location);
                    break;
                case egret.CollectionEventKind.UPDATE:
                    this.itemUpdatedHandler(event.items[0], event.location);
                    break;
                case egret.CollectionEventKind.REPLACE:
                    this.itemRemoved(event.oldItems[0], event.location);
                    this.itemAdded(event.items[0], event.location);
                    break;
                case egret.CollectionEventKind.RESET:
                case egret.CollectionEventKind.REFRESH:
                    if (this.layout && this.layout.useVirtualLayout) {
                        for (var index in this.indexToRenderer) {
                            index = parseInt(index);
                            this.freeRendererByIndex(index);
                        }
                    }
                    this.dataProviderChanged = true;
                    this.invalidateProperties();
                    break;
            }
            this.invalidateSize();
            this.invalidateDisplayList();
        };

        /**
        * 数据源添加项目事件处理
        */
        DataGroup.prototype.itemAddedHandler = function (items, index) {
            var length = items.length;
            for (var i = 0; i < length; i++) {
                this.itemAdded(items[i], index + i);
            }
            this.resetRenderersIndices();
        };

        /**
        * 数据源移动项目事件处理
        */
        DataGroup.prototype.itemMovedHandler = function (item, location, oldLocation) {
            this.itemRemoved(item, oldLocation);
            this.itemAdded(item, location);
            this.resetRenderersIndices();
        };

        /**
        * 数据源移除项目事件处理
        */
        DataGroup.prototype.itemRemovedHandler = function (items, location) {
            var length = items.length;
            for (var i = length - 1; i >= 0; i--) {
                this.itemRemoved(items[i], location + i);
            }

            this.resetRenderersIndices();
        };

        /**
        * 添加一项
        */
        DataGroup.prototype.itemAdded = function (item, index) {
            if (this.layout)
                this.layout.elementAdded(index);

            if (this.layout && this.layout.useVirtualLayout) {
                var virtualRendererIndices = this.virtualRendererIndices;
                if (virtualRendererIndices) {
                    var length = virtualRendererIndices.length;
                    for (var i = 0; i < length; i++) {
                        var vrIndex = virtualRendererIndices[i];
                        if (vrIndex >= index)
                            virtualRendererIndices[i] = vrIndex + 1;
                    }
                    this.indexToRenderer.splice(index, 0, null);
                }
                return;
            }
            var rendererFactory = this.itemToRendererClass(item);
            var renderer = this.createOneRenderer(rendererFactory);
            this.indexToRenderer.splice(index, 0, renderer);
            if (!renderer)
                return;
            this.updateRenderer(renderer, index, item);
            egret.RendererExistenceEvent.dispatchRendererExistenceEvent(this, egret.RendererExistenceEvent.RENDERER_ADD, renderer, index, item);
        };

        /**
        * 移除一项
        */
        DataGroup.prototype.itemRemoved = function (item, index) {
            if (this.layout)
                this.layout.elementRemoved(index);
            var virtualRendererIndices = this.virtualRendererIndices;
            if (virtualRendererIndices && (virtualRendererIndices.length > 0)) {
                var vrItemIndex = -1;
                var length = virtualRendererIndices.length;
                for (var i = 0; i < length; i++) {
                    var vrIndex = virtualRendererIndices[i];
                    if (vrIndex == index)
                        vrItemIndex = i;
                    else if (vrIndex > index)
                        virtualRendererIndices[i] = vrIndex - 1;
                }
                if (vrItemIndex != -1)
                    virtualRendererIndices.splice(vrItemIndex, 1);
            }
            var oldRenderer = this.indexToRenderer[index];

            if (this.indexToRenderer.length > index)
                this.indexToRenderer.splice(index, 1);

            egret.RendererExistenceEvent.dispatchRendererExistenceEvent(this, egret.RendererExistenceEvent.RENDERER_REMOVE, oldRenderer, index, item);

            if (oldRenderer && oldRenderer instanceof egret.DisplayObject) {
                this.recycle(oldRenderer);
            }
        };

        /**
        * 回收一个ItemRenderer实例
        */
        DataGroup.prototype.recycle = function (renderer) {
            this._removeFromDisplayList(renderer);
            if ("ownerChanged" in renderer) {
                renderer.ownerChanged(null);
            }
            var rendererFactory = this.rendererToClassMap[renderer.hashCode];
            var hashCode = rendererFactory.hashCode;
            if (!this.recyclerDic[hashCode]) {
                this.recyclerDic[hashCode] = new egret.Recycler();
            }
            this.recyclerDic[hashCode].push(renderer);
        };

        /**
        * 更新当前所有项的索引
        */
        DataGroup.prototype.resetRenderersIndices = function () {
            if (this.indexToRenderer.length == 0)
                return;

            if (this.layout && this.layout.useVirtualLayout) {
                var virtualRendererIndices = this.virtualRendererIndices;
                var length = virtualRendererIndices.length;
                for (var i = 0; i < length; i++) {
                    var index = virtualRendererIndices[i];
                    this.resetRendererItemIndex(index);
                }
            } else {
                var indexToRendererLength = this.indexToRenderer.length;
                for (index = 0; index < indexToRendererLength; index++)
                    this.resetRendererItemIndex(index);
            }
        };

        /**
        * 数据源更新或替换项目事件处理
        */
        DataGroup.prototype.itemUpdatedHandler = function (item, location) {
            if (this.renderersBeingUpdated)
                return;

            var renderer = this.indexToRenderer[location];
            if (renderer)
                this.updateRenderer(renderer, location, item);
        };

        /**
        * 调整指定项呈示器的索引值
        */
        DataGroup.prototype.resetRendererItemIndex = function (index) {
            var renderer = (this.indexToRenderer[index]);
            if (renderer)
                renderer.itemIndex = index;
        };

        Object.defineProperty(DataGroup.prototype, "itemRenderer", {
            /**
            * 用于数据项目的项呈示器。该类必须实现 IItemRenderer 接口。<br/>
            * rendererClass获取顺序：itemRendererFunction > itemRenderer > 默认ItemRenerer。
            * @member egret.DataGroup#itemRenderer
            */
            get: function () {
                return this._itemRenderer;
            },
            set: function (value) {
                if (this._itemRenderer === value)
                    return;
                this._itemRenderer = value;
                this.itemRendererChanged = true;
                this.typicalItemChanged = true;
                this.cleanFreeRenderer = true;
                this.removeDataProviderListener();
                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DataGroup.prototype, "itemRendererSkinName", {
            /**
            * 条目渲染器的可选皮肤标识符。在实例化itemRenderer时，若其内部没有设置过skinName,则将此属性的值赋值给它的skinName。
            * 注意:若itemRenderer不是ISkinnableClient，则此属性无效。
            * @member egret.DataGroup#itemRendererSkinName
            */
            get: function () {
                return this._itemRendererSkinName;
            },
            set: function (value) {
                if (this._itemRendererSkinName == value)
                    return;
                this._itemRendererSkinName = value;
                if (this._itemRendererSkinName && this.initialized) {
                    this.itemRendererSkinNameChange = true;
                    this.invalidateProperties();
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DataGroup.prototype, "itemRendererFunction", {
            /**
            * 为某个特定项目返回一个项呈示器Class的函数。<br/>
            * rendererClass获取顺序：itemRendererFunction > itemRenderer > 默认ItemRenerer。<br/>
            * 应该定义一个与此示例函数类似的呈示器函数： <br/>
            * function myItemRendererFunction(item:Object):IFactory
            * @member egret.DataGroup#itemRendererFunction
            */
            get: function () {
                return this._itemRendererFunction;
            },
            set: function (value) {
                if (this._itemRendererFunction == value)
                    return;
                this._itemRendererFunction = value;

                this.itemRendererChanged = true;
                this.typicalItemChanged = true;
                this.removeDataProviderListener();
                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 为特定的数据项返回项呈示器的工厂实例
        */
        DataGroup.prototype.itemToRendererClass = function (item) {
            var rendererFactory;
            if (this._itemRendererFunction != null) {
                rendererFactory = this._itemRendererFunction(item);
                if (!rendererFactory)
                    rendererFactory = this._itemRenderer;
            } else {
                rendererFactory = this._itemRenderer;
            }
            return rendererFactory ? rendererFactory : DataGroup.defaultRendererFactory;
        };

        /**
        * @method egret.DataGroup#createChildren
        * 设置默认的ItemRenderer
        * @private
        *
        */
        DataGroup.prototype.createChildren = function () {
            if (!this.layout) {
                var _layout = new egret.VerticalLayout();
                _layout.gap = 0;
                _layout.horizontalAlign = egret.HorizontalAlign.CONTENT_JUSTIFY;
                this.layout = _layout;
            }
            _super.prototype.createChildren.call(this);
        };

        /**
        * @method egret.DataGroup#commitProperties
        */
        DataGroup.prototype.commitProperties = function () {
            if (this.itemRendererChanged || this.dataProviderChanged || this.useVirtualLayoutChanged) {
                this.removeAllRenderers();
                if (this.layout)
                    this.layout.clearVirtualLayoutCache();
                this.setTypicalLayoutRect(null);
                this.useVirtualLayoutChanged = false;
                this.itemRendererChanged = false;
                if (this._dataProvider)
                    this._dataProvider.addEventListener(egret.CollectionEvent.COLLECTION_CHANGE, this.onCollectionChange, this);
                if (this.layout && this.layout.useVirtualLayout) {
                    this.invalidateSize();
                    this.invalidateDisplayList();
                } else {
                    this.createRenderers();
                }
                if (this.dataProviderChanged) {
                    this.dataProviderChanged = false;
                    this.verticalScrollPosition = this.horizontalScrollPosition = 0;
                }
            }

            _super.prototype.commitProperties.call(this);

            if (this.typicalItemChanged) {
                this.typicalItemChanged = false;
                if (this._dataProvider && this._dataProvider.length > 0) {
                    this.typicalItem = this._dataProvider.getItemAt(0);
                    this.measureRendererSize();
                }
            }
            if (this.itemRendererSkinNameChange) {
                this.itemRendererSkinNameChange = false;
                var length = this.indexToRenderer.length;
                for (var i = 0; i < length; i++) {
                    this.setItemRenderSkinName(this.indexToRenderer[i]);
                }
                var freeRenderers = this.freeRenderers;
                for (var hashCode in freeRenderers) {
                    var list = freeRenderers[hashCode];
                    if (list) {
                        length = list.length;
                        for (i = 0; i < length; i++) {
                            this.setItemRenderSkinName(list[i]);
                        }
                    }
                }
            }
        };

        /**
        * @method egret.DataGroup#measure
        */
        DataGroup.prototype.measure = function () {
            if (this.layout && this.layout.useVirtualLayout) {
                this.ensureTypicalLayoutElement();
            }
            _super.prototype.measure.call(this);
        };

        /**
        * @method egret.DataGroup#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        DataGroup.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            if (this._layoutInvalidateDisplayListFlag && this.layout && this.layout.useVirtualLayout) {
                this.virtualLayoutUnderway = true;
                this.ensureTypicalLayoutElement();
            }
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            if (this.virtualLayoutUnderway)
                this.finishVirtualLayout();
        };

        /**
        * 确保测量过默认条目大小。
        */
        DataGroup.prototype.ensureTypicalLayoutElement = function () {
            if (this.layout.typicalLayoutRect)
                return;

            if (this._dataProvider && this._dataProvider.length > 0) {
                this.typicalItem = this._dataProvider.getItemAt(0);
                this.measureRendererSize();
            }
        };

        /**
        * 测量项呈示器默认尺寸
        */
        DataGroup.prototype.measureRendererSize = function () {
            if (!this.typicalItem) {
                this.setTypicalLayoutRect(null);
                return;
            }
            var rendererFactory = this.itemToRendererClass(this.typicalItem);
            var typicalRenderer = this.createOneRenderer(rendererFactory);
            if (!typicalRenderer) {
                this.setTypicalLayoutRect(null);
                return;
            }
            this.createNewRendererFlag = true;
            this.updateRenderer(typicalRenderer, 0, this.typicalItem);
            if ("validateNow" in typicalRenderer)
                typicalRenderer.validateNow();
            var rect = new egret.Rectangle(0, 0, typicalRenderer.preferredWidth, typicalRenderer.preferredHeight);
            this.recycle(typicalRenderer);
            this.setTypicalLayoutRect(rect);
            this.createNewRendererFlag = false;
        };

        /**
        * 设置项目默认大小
        */
        DataGroup.prototype.setTypicalLayoutRect = function (rect) {
            this.typicalLayoutRect = rect;
            if (this.layout)
                this.layout.typicalLayoutRect = rect;
        };

        /**
        * 移除所有项呈示器
        */
        DataGroup.prototype.removeAllRenderers = function () {
            var length = this.indexToRenderer.length;
            var renderer;
            for (var i = 0; i < length; i++) {
                renderer = this.indexToRenderer[i];
                if (renderer) {
                    this.recycle(renderer);
                    egret.RendererExistenceEvent.dispatchRendererExistenceEvent(this, egret.RendererExistenceEvent.RENDERER_REMOVE, renderer, renderer.itemIndex, renderer.data);
                }
            }
            this.indexToRenderer = [];
            this.virtualRendererIndices = null;
            if (!this.cleanFreeRenderer)
                return;
            this.cleanAllFreeRenderer();
        };

        /**
        * 为数据项创建项呈示器
        */
        DataGroup.prototype.createRenderers = function () {
            if (!this._dataProvider)
                return;
            var index = 0;
            var length = this._dataProvider.length;
            for (var i = 0; i < length; i++) {
                var item = this._dataProvider.getItemAt(i);
                var rendererFactory = this.itemToRendererClass(item);
                var renderer = this.createOneRenderer(rendererFactory);
                if (!renderer)
                    continue;
                this.indexToRenderer[index] = renderer;
                this.updateRenderer(renderer, index, item);
                egret.RendererExistenceEvent.dispatchRendererExistenceEvent(this, egret.RendererExistenceEvent.RENDERER_ADD, renderer, index, item);
                index++;
            }
        };

        /**
        * 更新项呈示器
        * @method egret.DataGroup#updateRenderer
        * @param renderer {IItemRenderer}
        * @param itemIndex {number}
        * @param data {any}
        * @returns {IItemRenderer}
        */
        DataGroup.prototype.updateRenderer = function (renderer, itemIndex, data) {
            this.renderersBeingUpdated = true;

            if (this._rendererOwner) {
                renderer = this._rendererOwner.updateRenderer(renderer, itemIndex, data);
            } else {
                if ("ownerChanged" in renderer) {
                    renderer.ownerChanged(this);
                }
                renderer.itemIndex = itemIndex;
                renderer.label = this.itemToLabel(data);
                renderer.data = data;
            }

            this.renderersBeingUpdated = false;
            return renderer;
        };

        /**
        * 返回可在项呈示器中显示的 String。
        * 若DataGroup被作为SkinnableDataContainer的皮肤组件,此方法将不会执行，被SkinnableDataContainer.itemToLabel()所替代。
        * @method egret.DataGroup#itemToLabel
        * @param item {any}
        * @returns {string}
        */
        DataGroup.prototype.itemToLabel = function (item) {
            if (item)
                return item.toString();
            else
                return " ";
        };

        /**
        * @method egret.DataGroup#getElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        DataGroup.prototype.getElementAt = function (index) {
            return this.indexToRenderer[index];
        };

        /**
        * @method egret.DataGroup#getElementIndex
        * @param element {IVisualElement}
        * @returns {number}
        */
        DataGroup.prototype.getElementIndex = function (element) {
            if (!element)
                return -1;
            return this.indexToRenderer.indexOf(element);
        };

        Object.defineProperty(DataGroup.prototype, "numElements", {
            /**
            * @member egret.DataGroup#numElements
            */
            get: function () {
                if (!this._dataProvider)
                    return 0;
                return this._dataProvider.length;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.DataGroup#addChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        DataGroup.prototype.addChild = function (child) {
            throw (new Error("addChild()" + DataGroup.errorStr + "addElement()代替"));
        };

        /**
        * @method egret.DataGroup#addChildAt
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        * @returns {DisplayObject}
        */
        DataGroup.prototype.addChildAt = function (child, index) {
            throw (new Error("addChildAt()" + DataGroup.errorStr + "addElementAt()代替"));
        };

        /**
        * @method egret.DataGroup#removeChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        DataGroup.prototype.removeChild = function (child) {
            throw (new Error("removeChild()" + DataGroup.errorStr + "removeElement()代替"));
        };

        /**
        * @method egret.DataGroup#removeChildAt
        * @deprecated
        * @param index {number}
        * @returns {DisplayObject}
        */
        DataGroup.prototype.removeChildAt = function (index) {
            throw (new Error("removeChildAt()" + DataGroup.errorStr + "removeElementAt()代替"));
        };

        /**
        * @method egret.DataGroup#setChildIndex
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        */
        DataGroup.prototype.setChildIndex = function (child, index) {
            throw (new Error("setChildIndex()" + DataGroup.errorStr + "setElementIndex()代替"));
        };

        /**
        * @method egret.DataGroup#swapChildren
        * @deprecated
        * @param child1 {DisplayObject}
        * @param child2 {DisplayObject}
        */
        DataGroup.prototype.swapChildren = function (child1, child2) {
            throw (new Error("swapChildren()" + DataGroup.errorStr + "swapElements()代替"));
        };

        /**
        * @method egret.DataGroup#swapChildrenAt
        * @deprecated
        * @param index1 {number}
        * @param index2 {number}
        */
        DataGroup.prototype.swapChildrenAt = function (index1, index2) {
            throw (new Error("swapChildrenAt()" + DataGroup.errorStr + "swapElementsAt()代替"));
        };
        DataGroup.defaultRendererFactory = new egret.ClassFactory(egret.ItemRenderer);

        DataGroup.errorStr = "在此组件中不可用，若此组件为容器类，请使用";
        return DataGroup;
    })(egret.GroupBase);
    egret.DataGroup = DataGroup;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SkinnableContainer
    * @classdesc
    * 可设置外观的容器的基类
    * @extends egret.SkinnableComponent
    * @implements egret.IVisualElementContainer
    */
    var SkinnableContainer = (function (_super) {
        __extends(SkinnableContainer, _super);
        /**
        * @method egret.SkinnableContainer#constructor
        */
        function SkinnableContainer() {
            _super.call(this);
            /**
            * contentGroup发生改变时传递的参数
            */
            this.contentGroupProperties = {};
            this.hostComponentKey = "egret.SkinnableContainer";
        }
        /**
        * 获取当前的实体容器
        */
        SkinnableContainer.prototype._getCurrentContentGroup = function () {
            if (this.contentGroup == null) {
                if (this._placeHolderGroup == null) {
                    this._placeHolderGroup = new egret.Group();
                    this._placeHolderGroup.visible = false;
                    this._addToDisplayList(this._placeHolderGroup);
                }
                this._placeHolderGroup.addEventListener(egret.ElementExistenceEvent.ELEMENT_ADD, this._contentGroup_elementAddedHandler, this);
                this._placeHolderGroup.addEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE, this._contentGroup_elementRemovedHandler, this);
                return this._placeHolderGroup;
            } else {
                return this.contentGroup;
            }
        };

        Object.defineProperty(SkinnableContainer.prototype, "elementsContent", {
            /**
            * 设置容器子对象数组 。数组包含要添加到容器的子项列表，之前的已存在于容器中的子项列表被全部移除后添加列表里的每一项到容器。
            * 设置该属性时会对您输入的数组进行一次浅复制操作，所以您之后对该数组的操作不会影响到添加到容器的子项列表数量。
            */
            set: function (value) {
                this._getCurrentContentGroup().elementsContent = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(SkinnableContainer.prototype, "numElements", {
            /**
            * @member egret.SkinnableContainer#numElements
            */
            get: function () {
                return this._getCurrentContentGroup().numElements;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.SkinnableContainer#getElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        SkinnableContainer.prototype.getElementAt = function (index) {
            return this._getCurrentContentGroup().getElementAt(index);
        };

        /**
        * @method egret.SkinnableContainer#addElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        SkinnableContainer.prototype.addElement = function (element) {
            return this._getCurrentContentGroup().addElement(element);
        };

        /**
        * @method egret.SkinnableContainer#addElementAt
        * @param element {IVisualElement}
        * @param index {number}
        * @returns {IVisualElement}
        */
        SkinnableContainer.prototype.addElementAt = function (element, index) {
            return this._getCurrentContentGroup().addElementAt(element, index);
        };

        /**
        * @method egret.SkinnableContainer#removeElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        SkinnableContainer.prototype.removeElement = function (element) {
            return this._getCurrentContentGroup().removeElement(element);
        };

        /**
        * @method egret.SkinnableContainer#removeElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        SkinnableContainer.prototype.removeElementAt = function (index) {
            return this._getCurrentContentGroup().removeElementAt(index);
        };

        /**
        * @method egret.SkinnableContainer#removeAllElements
        */
        SkinnableContainer.prototype.removeAllElements = function () {
            this._getCurrentContentGroup().removeAllElements();
        };

        /**
        * @method egret.SkinnableContainer#getElementIndex
        * @param element {IVisualElement}
        * @returns {number}
        */
        SkinnableContainer.prototype.getElementIndex = function (element) {
            return this._getCurrentContentGroup().getElementIndex(element);
        };

        /**
        * @method egret.SkinnableContainer#setElementIndex
        * @param element {IVisualElement}
        * @param index {number}
        */
        SkinnableContainer.prototype.setElementIndex = function (element, index) {
            this._getCurrentContentGroup().setElementIndex(element, index);
        };

        /**
        * @method egret.SkinnableContainer#swapElements
        * @param element1 {IVisualElement}
        * @param element2 {IVisualElement}
        */
        SkinnableContainer.prototype.swapElements = function (element1, element2) {
            this._getCurrentContentGroup().swapElements(element1, element2);
        };

        /**
        * @method egret.SkinnableContainer#swapElementsAt
        * @param index1 {number}
        * @param index2 {number}
        */
        SkinnableContainer.prototype.swapElementsAt = function (index1, index2) {
            this._getCurrentContentGroup().swapElementsAt(index1, index2);
        };

        Object.defineProperty(SkinnableContainer.prototype, "layout", {
            /**
            * 此容器的布局对象
            * @member egret.SkinnableContainer#layout
            */
            get: function () {
                return this.contentGroup != null ? this.contentGroup.layout : this.contentGroupProperties.layout;
            },
            set: function (value) {
                if (this.contentGroup != null) {
                    this.contentGroup.layout = value;
                } else {
                    this.contentGroupProperties.layout = value;
                }
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.SkinnableContainer#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        SkinnableContainer.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);
            if (instance == this.contentGroup) {
                if (this.contentGroupProperties.layout !== undefined) {
                    this.contentGroup.layout = this.contentGroupProperties.layout;
                    this.contentGroupProperties = {};
                }
                if (this._placeHolderGroup) {
                    this._placeHolderGroup.removeEventListener(egret.ElementExistenceEvent.ELEMENT_ADD, this._contentGroup_elementAddedHandler, this);
                    this._placeHolderGroup.removeEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE, this._contentGroup_elementRemovedHandler, this);
                    var sourceContent = this._placeHolderGroup._getElementsContent().concat();
                    for (var i = this._placeHolderGroup.numElements; i > 0; i--) {
                        var element = this._placeHolderGroup.removeElementAt(0);
                        element.ownerChanged(null);
                    }
                    this._removeFromDisplayList(this._placeHolderGroup);
                    this.contentGroup.elementsContent = sourceContent;
                    for (i = sourceContent.length - 1; i >= 0; i--) {
                        element = sourceContent[i];
                        element.ownerChanged(this);
                    }
                    this._placeHolderGroup = null;
                }
                this.contentGroup.addEventListener(egret.ElementExistenceEvent.ELEMENT_ADD, this._contentGroup_elementAddedHandler, this);
                this.contentGroup.addEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE, this._contentGroup_elementRemovedHandler, this);
            }
        };

        /**
        * @method egret.SkinnableContainer#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        SkinnableContainer.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);
            if (instance == this.contentGroup) {
                this.contentGroup.removeEventListener(egret.ElementExistenceEvent.ELEMENT_ADD, this._contentGroup_elementAddedHandler, this);
                this.contentGroup.removeEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE, this._contentGroup_elementRemovedHandler, this);
                this.contentGroupProperties.layout = this.contentGroup.layout;
                this.contentGroup.layout = null;
                if (this.contentGroup.numElements > 0) {
                    this._placeHolderGroup = new egret.Group;

                    while (this.contentGroup.numElements > 0) {
                        this._placeHolderGroup.addElement(this.contentGroup.getElementAt(0));
                    }
                    this._placeHolderGroup.addEventListener(egret.ElementExistenceEvent.ELEMENT_ADD, this._contentGroup_elementAddedHandler, this);
                    this._placeHolderGroup.addEventListener(egret.ElementExistenceEvent.ELEMENT_REMOVE, this._contentGroup_elementRemovedHandler, this);
                }
            }
        };

        /**
        * 容器添加元素事件
        * @method egret.SkinnableContainer#_contentGroup_elementAddedHandler
        * @param event {ElementExistenceEvent}
        */
        SkinnableContainer.prototype._contentGroup_elementAddedHandler = function (event) {
            event.element.ownerChanged(this);
            this.dispatchEvent(event);
        };

        /**
        * 容器移除元素事件
        * @method egret.SkinnableContainer#_contentGroup_elementRemovedHandler
        * @param event {ElementExistenceEvent}
        */
        SkinnableContainer.prototype._contentGroup_elementRemovedHandler = function (event) {
            event.element.ownerChanged(null);
            this.dispatchEvent(event);
        };
        return SkinnableContainer;
    })(egret.SkinnableComponent);
    egret.SkinnableContainer = SkinnableContainer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SkinnableDataContainer
    * @classdesc
    * 可设置外观的数据项目容器基类
    * @extends egret.SkinnableComponent
    * @implements egret.IItemRendererOwner
    */
    var SkinnableDataContainer = (function (_super) {
        __extends(SkinnableDataContainer, _super);
        /**
        * 构造函数
        * @method egret.SkinnableDataContainer#constructor
        */
        function SkinnableDataContainer() {
            _super.call(this);
            /**
            * dataGroup发生改变时传递的参数
            */
            this._dataGroupProperties = {};
            this.hostComponentKey = "egret.SkinnableDataContainer";
        }
        /**
        * @method egret.SkinnableDataContainer#updateRenderer
        * @param renderer {IItemRenderer}
        * @param itemIndex {number}
        * @param data {any}
        * @returns {IItemRenderer}
        */
        SkinnableDataContainer.prototype.updateRenderer = function (renderer, itemIndex, data) {
            if ("ownerChanged" in renderer) {
                renderer.ownerChanged(this);
            }
            renderer.itemIndex = itemIndex;
            renderer.label = this.itemToLabel(data);
            renderer.data = data;
            return renderer;
        };

        /**
        * 返回可在项呈示器中显示的 String
        * @method egret.SkinnableDataContainer#itemToLabel
        * @param item {any}
        * @returns {string}
        */
        SkinnableDataContainer.prototype.itemToLabel = function (item) {
            if (item !== null)
                return item.toString();
            else
                return " ";
        };

        Object.defineProperty(SkinnableDataContainer.prototype, "dataProvider", {
            /**
            * 列表数据源，请使用实现了ICollection接口的数据类型，例如ArrayCollection
            * @member egret.SkinnableDataContainer#dataProvider
            */
            get: function () {
                return this._getDataProvider();
            },
            set: function (value) {
                this._setDataProvider(value);
            },
            enumerable: true,
            configurable: true
        });

        SkinnableDataContainer.prototype._getDataProvider = function () {
            return this.dataGroup != null ? this.dataGroup.dataProvider : this._dataGroupProperties.dataProvider;
        };


        SkinnableDataContainer.prototype._setDataProvider = function (value) {
            if (this.dataGroup == null) {
                this._dataGroupProperties.dataProvider = value;
            } else {
                this.dataGroup.dataProvider = value;
                this._dataGroupProperties.dataProvider = true;
            }
        };

        Object.defineProperty(SkinnableDataContainer.prototype, "itemRenderer", {
            /**
            * 用于数据项目的项呈示器。该类必须实现 IItemRenderer 接口。 <br/>
            * rendererClass获取顺序：itemRendererFunction > itemRenderer > 默认ItemRenerer。
            * @member egret.SkinnableDataContainer#itemRenderer
            */
            get: function () {
                return (this.dataGroup) ? this.dataGroup.itemRenderer : this._dataGroupProperties.itemRenderer;
            },
            set: function (value) {
                if (this.dataGroup == null) {
                    this._dataGroupProperties.itemRenderer = value;
                } else {
                    this.dataGroup.itemRenderer = value;
                    this._dataGroupProperties.itemRenderer = true;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableDataContainer.prototype, "itemRendererSkinName", {
            /**
            * 条目渲染器的可选皮肤标识符。在实例化itemRenderer时，若其内部没有设置过skinName,则将此属性的值赋值给它的skinName。
            * 注意:若itemRenderer不是ISkinnableClient，则此属性无效。
            * @member egret.SkinnableDataContainer#itemRendererSkinName
            */
            get: function () {
                return (this.dataGroup) ? this.dataGroup.itemRendererSkinName : this._dataGroupProperties.itemRendererSkinName;
            },
            set: function (value) {
                if (this.dataGroup == null) {
                    this._dataGroupProperties.itemRendererSkinName = value;
                } else {
                    this.dataGroup.itemRendererSkinName = value;
                    this._dataGroupProperties.itemRendererSkinName = true;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableDataContainer.prototype, "itemRendererFunction", {
            /**
            * 为某个特定项目返回一个项呈示器Class的函数。 <br/>
            * rendererClass获取顺序：itemRendererFunction > itemRenderer > 默认ItemRenerer。 <br/>
            * 应该定义一个与此示例函数类似的呈示器函数： <br/>
            * function myItemRendererFunction(item:Object):IFactory
            * @member egret.SkinnableDataContainer#itemRendererFunction
            */
            get: function () {
                return (this.dataGroup) ? this.dataGroup.itemRendererFunction : this._dataGroupProperties.itemRendererFunction;
            },
            set: function (value) {
                if (this.dataGroup == null) {
                    this._dataGroupProperties.itemRendererFunction = value;
                } else {
                    this.dataGroup.itemRendererFunction = value;
                    this._dataGroupProperties.itemRendererFunction = true;
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(SkinnableDataContainer.prototype, "layout", {
            /**
            * 布局对象
            * @member egret.SkinnableDataContainer#layout
            */
            get: function () {
                return (this.dataGroup) ? this.dataGroup.layout : this._dataGroupProperties.layout;
            },
            set: function (value) {
                this._setLayout(value);
            },
            enumerable: true,
            configurable: true
        });


        SkinnableDataContainer.prototype._setLayout = function (value) {
            if (this.dataGroup == null) {
                this._dataGroupProperties.layout = value;
            } else {
                this.dataGroup.layout = value;
                this._dataGroupProperties.layout = true;
            }
        };

        /**
        * @method egret.SkinnableDataContainer#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        SkinnableDataContainer.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.dataGroup) {
                var newDataGroupProperties = {};

                if (this._dataGroupProperties.layout !== undefined) {
                    this.dataGroup.layout = this._dataGroupProperties.layout;
                    newDataGroupProperties.layout = true;
                }

                if (this._dataGroupProperties.dataProvider !== undefined) {
                    this.dataGroup.dataProvider = this._dataGroupProperties.dataProvider;
                    newDataGroupProperties.dataProvider = true;
                }

                if (this._dataGroupProperties.itemRenderer !== undefined) {
                    this.dataGroup.itemRenderer = this._dataGroupProperties.itemRenderer;
                    newDataGroupProperties.itemRenderer = true;
                }

                if (this._dataGroupProperties.itemRendererSkinName !== undefined) {
                    this.dataGroup.itemRendererSkinName = this._dataGroupProperties.itemRendererSkinName;
                    newDataGroupProperties.itemRendererSkinName = true;
                }

                if (this._dataGroupProperties.itemRendererFunction !== undefined) {
                    this.dataGroup.itemRendererFunction = this._dataGroupProperties.itemRendererFunction;
                    newDataGroupProperties.itemRendererFunction = true;
                }
                this.dataGroup._rendererOwner = this;
                this._dataGroupProperties = newDataGroupProperties;

                if (this.hasEventListener(egret.RendererExistenceEvent.RENDERER_ADD)) {
                    this.dataGroup.addEventListener(egret.RendererExistenceEvent.RENDERER_ADD, this.dispatchEvent, this);
                }

                if (this.hasEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE)) {
                    this.dataGroup.addEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE, this.dispatchEvent, this);
                }
            }
        };

        /**
        * @method egret.SkinnableDataContainer#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        SkinnableDataContainer.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);

            if (instance == this.dataGroup) {
                this.dataGroup.removeEventListener(egret.RendererExistenceEvent.RENDERER_ADD, this.dispatchEvent, this);
                this.dataGroup.removeEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE, this.dispatchEvent, this);
                var newDataGroupProperties = {};
                if (this._dataGroupProperties.layout)
                    newDataGroupProperties.layout = this.dataGroup.layout;
                if (this._dataGroupProperties.dataProvider)
                    newDataGroupProperties.dataProvider = this.dataGroup.dataProvider;
                if (this._dataGroupProperties.itemRenderer)
                    newDataGroupProperties.itemRenderer = this.dataGroup.itemRenderer;
                if (this._dataGroupProperties.itemRendererSkinName)
                    newDataGroupProperties.itemRendererSkinName = this.dataGroup.itemRendererSkinName;
                if (this._dataGroupProperties.itemRendererFunction)
                    newDataGroupProperties.itemRendererFunction = this.dataGroup.itemRendererFunction;
                this._dataGroupProperties = newDataGroupProperties;
                this.dataGroup._rendererOwner = null;
                this.dataGroup.dataProvider = null;
                this.dataGroup.layout = null;
            }
        };

        /**
        * @method egret.SkinnableDataContainer#addEventListener
        * @param type {string}
        * @param listener {Function}
        * @param thisObject {any}
        * @param useCapture {boolean}
        * @param priority {number}
        */
        SkinnableDataContainer.prototype.addEventListener = function (type, listener, thisObject, useCapture, priority) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            if (typeof priority === "undefined") { priority = 0; }
            _super.prototype.addEventListener.call(this, type, listener, thisObject, useCapture, priority);

            if (type == egret.RendererExistenceEvent.RENDERER_ADD && this.dataGroup) {
                this.dataGroup.addEventListener(egret.RendererExistenceEvent.RENDERER_ADD, this.dispatchEvent, this);
            }

            if (type == egret.RendererExistenceEvent.RENDERER_REMOVE && this.dataGroup) {
                this.dataGroup.addEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE, this.dispatchEvent, this);
            }
        };

        /**
        * @method egret.SkinnableDataContainer#removeEventListener
        * @param type {string}
        * @param listener {Function}
        * @param thisObject {any}
        * @param useCapture {boolean}
        */
        SkinnableDataContainer.prototype.removeEventListener = function (type, listener, thisObject, useCapture) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            _super.prototype.removeEventListener.call(this, type, listener, thisObject, useCapture);

            if (type == egret.RendererExistenceEvent.RENDERER_ADD && this.dataGroup) {
                if (!this.hasEventListener(egret.RendererExistenceEvent.RENDERER_ADD)) {
                    this.dataGroup.removeEventListener(egret.RendererExistenceEvent.RENDERER_ADD, this.dispatchEvent, this);
                }
            }

            if (type == egret.RendererExistenceEvent.RENDERER_REMOVE && this.dataGroup) {
                if (!this.hasEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE)) {
                    this.dataGroup.removeEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE, this.dispatchEvent, this);
                }
            }
        };
        return SkinnableDataContainer;
    })(egret.SkinnableComponent);
    egret.SkinnableDataContainer = SkinnableDataContainer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ListBase
    * @classdesc
    * 支持选择内容的所有组件的基类。
    * @extends egret.SkinnableDataContainer
    */
    var ListBase = (function (_super) {
        __extends(ListBase, _super);
        /**
        * @method egret.ListBase#constructor
        */
        function ListBase() {
            _super.call(this);
            /**
            * 正在进行所有数据源的刷新操作
            * @member egret.ListBase#_doingWholesaleChanges
            */
            this._doingWholesaleChanges = false;
            this._labelField = "label";
            this._requireSelection = false;
            this.requireSelectionChanged = false;
            /**
            * 在属性提交前缓存真实的选中项的值
            */
            this._proposedSelectedIndex = ListBase.NO_PROPOSED_SELECTION;
            this._selectedIndex = ListBase.NO_SELECTION;
            /**
            * 是否允许自定义的选中项
            * @member egret.ListBase#_allowCustomSelectedItem
            */
            this._allowCustomSelectedItem = false;
            /**
            * 索引改变后是否需要抛出事件
            * @member egret.ListBase#_dispatchChangeAfterSelection
            */
            this._dispatchChangeAfterSelection = false;
            this._useVirtualLayout = false;
            this.selectedIndexAdjusted = false;
        }
        ListBase.prototype._setDataProvider = function (value) {
            if (this.dataProvider)
                this.dataProvider.removeEventListener(egret.CollectionEvent.COLLECTION_CHANGE, this.dataProvider_collectionChangeHandler, this);

            this.dataProviderChanged = true;
            this._doingWholesaleChanges = true;

            if (value)
                value.addEventListener(egret.CollectionEvent.COLLECTION_CHANGE, this.dataProvider_collectionChangeHandler, this);

            _super.prototype._setDataProvider.call(this, value);
            this.invalidateProperties();
        };

        Object.defineProperty(ListBase.prototype, "layout", {
            /**
            * 布局对象
            * @member egret.ListBase#layout
            */
            get: function () {
                return (this.dataGroup) ? this.dataGroup.layout : this._dataGroupProperties.layout;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (value && this.useVirtualLayout)
                    value.useVirtualLayout = true;

                this._setLayout(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ListBase.prototype, "labelField", {
            /**
            * 数据项如果是一个对象，此属性为数据项中用来显示标签文字的字段名称。
            * 若设置了labelFunction，则设置此属性无效。
            * @member egret.ListBase#labelField
            */
            get: function () {
                return this._labelField;
            },
            set: function (value) {
                this._setLabelField(value);
            },
            enumerable: true,
            configurable: true
        });


        ListBase.prototype._setLabelField = function (value) {
            if (value == this._labelField)
                return;
            this._labelField = value;
            this.labelFieldOrFunctionChanged = true;
            this.invalidateProperties();
        };

        Object.defineProperty(ListBase.prototype, "labelFunction", {
            /**
            * 用户提供的函数，在每个项目上运行以确定其标签。
            * 示例：function labelFunc(item:Object):String 。
            * @member egret.ListBase#labelFunction
            */
            get: function () {
                return this._labelFunction;
            },
            set: function (value) {
                this._setLabelFunction(value);
            },
            enumerable: true,
            configurable: true
        });


        ListBase.prototype._setLabelFunction = function (value) {
            if (value == this._labelFunction)
                return;

            this._labelFunction = value;
            this.labelFieldOrFunctionChanged = true;
            this.invalidateProperties();
        };

        Object.defineProperty(ListBase.prototype, "requireSelection", {
            /**
            * 如果为 true，则必须始终在控件中选中数据项目。<br/>
            * 如果该值为 true，则始终将 selectedIndex 属性设置为 0 和 (dataProvider.length - 1) 之间的一个值。
            * @member egret.ListBase#requireSelection
            */
            get: function () {
                return this._requireSelection;
            },
            set: function (value) {
                this._setRequireSelection(value);
            },
            enumerable: true,
            configurable: true
        });


        ListBase.prototype._setRequireSelection = function (value) {
            if (value == this._requireSelection)
                return;

            this._requireSelection = value;

            if (value) {
                this.requireSelectionChanged = true;
                this.invalidateProperties();
            }
        };

        Object.defineProperty(ListBase.prototype, "selectedIndex", {
            /**
            * 选中项目的基于 0 的索引。<br/>
            * 或者如果未选中项目，则为-1。设置 selectedIndex 属性会取消选择当前选定的项目并选择指定索引位置的数据项目。 <br/>
            * 当用户通过与控件交互来更改 selectedIndex 属性时，此控件将分派 change 和 changing 事件。<br/>
            * 当以编程方式更改 selectedIndex 属性的值时，此控件不分派 change 和 changing 事件。
            * @member egret.ListBase#selectedIndex
            */
            get: function () {
                return this._getSelectedIndex();
            },
            set: function (value) {
                this._setSelectedIndex(value, false);
            },
            enumerable: true,
            configurable: true
        });

        ListBase.prototype._getSelectedIndex = function () {
            if (this._proposedSelectedIndex != ListBase.NO_PROPOSED_SELECTION)
                return this._proposedSelectedIndex;

            return this._selectedIndex;
        };


        /**
        * 设置选中项
        */
        ListBase.prototype._setSelectedIndex = function (value, dispatchChangeEvent) {
            if (typeof dispatchChangeEvent === "undefined") { dispatchChangeEvent = false; }
            if (value == this.selectedIndex) {
                return;
            }

            if (dispatchChangeEvent)
                this._dispatchChangeAfterSelection = (this._dispatchChangeAfterSelection || dispatchChangeEvent);
            this._proposedSelectedIndex = value;
            this.invalidateProperties();
        };

        Object.defineProperty(ListBase.prototype, "selectedItem", {
            /**
            * 当前已选中的项目。设置此属性会取消选中当前选定的项目并选择新指定的项目。<br/>
            * 当用户通过与控件交互来更改 selectedItem 属性时，此控件将分派 change 和 changing 事件。<br/>
            * 当以编程方式更改 selectedItem 属性的值时，此控件不分派 change 和 changing 事件。
            * @member egret.ListBase#selectedItem
            */
            get: function () {
                if (this._pendingSelectedItem !== undefined)
                    return this._pendingSelectedItem;

                if (this._allowCustomSelectedItem && this.selectedIndex == ListBase.CUSTOM_SELECTED_ITEM)
                    return this._selectedItem;

                if (this.selectedIndex == ListBase.NO_SELECTION || this.dataProvider == null)
                    return undefined;

                return this.dataProvider.length > this.selectedIndex ? this.dataProvider.getItemAt(this.selectedIndex) : undefined;
            },
            set: function (value) {
                this._setSelectedItem(value, false);
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 设置选中项数据源
        * @method egret.ListBase#_setSelectedItem
        * @param value {any}
        * @param dispatchChangeEvent {boolean}
        */
        ListBase.prototype._setSelectedItem = function (value, dispatchChangeEvent) {
            if (typeof dispatchChangeEvent === "undefined") { dispatchChangeEvent = false; }
            if (this.selectedItem === value)
                return;

            if (dispatchChangeEvent)
                this._dispatchChangeAfterSelection = (this._dispatchChangeAfterSelection || dispatchChangeEvent);

            this._pendingSelectedItem = value;
            this.invalidateProperties();
        };

        Object.defineProperty(ListBase.prototype, "useVirtualLayout", {
            /**
            * 是否使用虚拟布局,默认flase
            * @member egret.ListBase#useVirtualLayout
            */
            get: function () {
                return this._getUseVirtualLayout();
            },
            set: function (value) {
                this._setUseVirtualLayout(value);
            },
            enumerable: true,
            configurable: true
        });

        ListBase.prototype._getUseVirtualLayout = function () {
            return (this.layout) ? this.layout.useVirtualLayout : this._useVirtualLayout;
        };


        ListBase.prototype._setUseVirtualLayout = function (value) {
            if (value == this.useVirtualLayout)
                return;

            this._useVirtualLayout = value;
            if (this.layout)
                this.layout.useVirtualLayout = value;
        };

        /**
        * @method egret.ListBase#commitProperties
        */
        ListBase.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);

            if (this.dataProviderChanged) {
                this.dataProviderChanged = false;
                this._doingWholesaleChanges = false;

                if (this.selectedIndex >= 0 && this.dataProvider && this.selectedIndex < this.dataProvider.length)
                    this.itemSelected(this.selectedIndex, true);
                else if (this.requireSelection)
                    this._proposedSelectedIndex = 0;
                else
                    this._setSelectedIndex(-1, false);
            }

            if (this.requireSelectionChanged) {
                this.requireSelectionChanged = false;

                if (this.requireSelection && this.selectedIndex == ListBase.NO_SELECTION && this.dataProvider && this.dataProvider.length > 0) {
                    this._proposedSelectedIndex = 0;
                }
            }

            if (this._pendingSelectedItem !== undefined) {
                if (this.dataProvider)
                    this._proposedSelectedIndex = this.dataProvider.getItemIndex(this._pendingSelectedItem);
                else
                    this._proposedSelectedIndex = ListBase.NO_SELECTION;

                if (this._allowCustomSelectedItem && this._proposedSelectedIndex == -1) {
                    this._proposedSelectedIndex = ListBase.CUSTOM_SELECTED_ITEM;
                    this._selectedItem = this._pendingSelectedItem;
                }

                this._pendingSelectedItem = undefined;
            }

            var changedSelection = false;
            if (this._proposedSelectedIndex != ListBase.NO_PROPOSED_SELECTION)
                changedSelection = this.commitSelection();

            if (this.selectedIndexAdjusted) {
                this.selectedIndexAdjusted = false;
                if (!changedSelection) {
                    egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);
                }
            }

            if (this.labelFieldOrFunctionChanged) {
                if (this.dataGroup != null) {
                    var itemIndex;

                    if (this.layout && this.layout.useVirtualLayout) {
                        var list = this.dataGroup.getElementIndicesInView();
                        var length = list.length;
                        for (var i = 0; i < length; i++) {
                            var itemIndex = list[i];
                            this.updateRendererLabelProperty(itemIndex);
                        }
                    } else {
                        var n = this.dataGroup.numElements;
                        for (itemIndex = 0; itemIndex < n; itemIndex++) {
                            this.updateRendererLabelProperty(itemIndex);
                        }
                    }
                }

                this.labelFieldOrFunctionChanged = false;
            }
        };

        /**
        *  更新项呈示器文字标签
        */
        ListBase.prototype.updateRendererLabelProperty = function (itemIndex) {
            var renderer = (this.dataGroup.getElementAt(itemIndex));
            if (renderer)
                renderer.label = this.itemToLabel(renderer.data);
        };

        /**
        * @method egret.ListBase#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        ListBase.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.dataGroup) {
                if (this._useVirtualLayout && this.dataGroup.layout)
                    this.dataGroup.layout.useVirtualLayout = true;

                this.dataGroup.addEventListener(egret.RendererExistenceEvent.RENDERER_ADD, this.dataGroup_rendererAddHandler, this);
                this.dataGroup.addEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE, this.dataGroup_rendererRemoveHandler, this);
            }
        };

        /**
        * @method egret.ListBase#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        ListBase.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);

            if (instance == this.dataGroup) {
                this.dataGroup.removeEventListener(egret.RendererExistenceEvent.RENDERER_ADD, this.dataGroup_rendererAddHandler, this);
                this.dataGroup.removeEventListener(egret.RendererExistenceEvent.RENDERER_REMOVE, this.dataGroup_rendererRemoveHandler, this);
            }
        };

        /**
        * @method egret.ListBase#updateRenderer
        * @param renderer {IItemRenderer}
        * @param itemIndex {number}
        * @param data {any}
        * @returns {IItemRenderer}
        */
        ListBase.prototype.updateRenderer = function (renderer, itemIndex, data) {
            this.itemSelected(itemIndex, this._isItemIndexSelected(itemIndex));
            return _super.prototype.updateRenderer.call(this, renderer, itemIndex, data);
        };

        /**
        * @method egret.ListBase#itemToLabel
        * @param item {any}
        * @returns {string}
        */
        ListBase.prototype.itemToLabel = function (item) {
            if (this._labelFunction != null)
                return this._labelFunction(item);

            if (typeof (item) == "string")
                return item;

            if (item instanceof egret.XML) {
                try  {
                    if (item[this.labelField].length() != 0)
                        item = item[this.labelField];
                } catch (e) {
                }
            } else if (item instanceof Object) {
                try  {
                    if (item[this.labelField] != null)
                        item = item[this.labelField];
                } catch (e) {
                }
            }

            if (typeof (item) == "string")
                return item;

            try  {
                if (item !== null)
                    return item.toString();
            } catch (e) {
            }

            return " ";
        };

        /**
        * 选中或取消选中项目时调用。子类必须覆盖此方法才可设置选中项。
        * @method egret.ListBase#itemSelected
        * @param index {number} 已选中的项目索引。
        * @param selected {boolean} true为选中，false取消选中
        */
        ListBase.prototype.itemSelected = function (index, selected) {
            if (!this.dataGroup)
                return;
            var renderer = (this.dataGroup.getElementAt(index));
            if (renderer == null)
                return;
            renderer.selected = selected;
        };

        /**
        * 返回指定索引是否等于当前选中索引
        */
        ListBase.prototype._isItemIndexSelected = function (index) {
            return index == this.selectedIndex;
        };

        /**
        * 提交选中项属性，返回是否成功提交，false表示被取消
        * @method egret.ListBase#commitSelection
        * @param dispatchChangedEvents {boolean}
        * @returns {boolean}
        */
        ListBase.prototype.commitSelection = function (dispatchChangedEvents) {
            if (typeof dispatchChangedEvents === "undefined") { dispatchChangedEvents = true; }
            var maxIndex = this.dataProvider ? this.dataProvider.length - 1 : -1;
            var oldSelectedIndex = this._selectedIndex;
            var e;

            if (!this._allowCustomSelectedItem || this._proposedSelectedIndex != ListBase.CUSTOM_SELECTED_ITEM) {
                if (this._proposedSelectedIndex < ListBase.NO_SELECTION)
                    this._proposedSelectedIndex = ListBase.NO_SELECTION;
                if (this._proposedSelectedIndex > maxIndex)
                    this._proposedSelectedIndex = maxIndex;
                if (this.requireSelection && this._proposedSelectedIndex == ListBase.NO_SELECTION && this.dataProvider && this.dataProvider.length > 0) {
                    this._proposedSelectedIndex = ListBase.NO_PROPOSED_SELECTION;
                    this._dispatchChangeAfterSelection = false;
                    return false;
                }
            }

            var tmpProposedIndex = this._proposedSelectedIndex;

            if (this._dispatchChangeAfterSelection) {
                var result = egret.IndexChangeEvent.dispatchIndexChangeEvent(this, egret.IndexChangeEvent.CHANGING, this._selectedIndex, this._proposedSelectedIndex, true);
                if (!result) {
                    this.itemSelected(this._proposedSelectedIndex, false);
                    this._proposedSelectedIndex = ListBase.NO_PROPOSED_SELECTION;
                    this._dispatchChangeAfterSelection = false;
                    return false;
                }
            }

            this._selectedIndex = tmpProposedIndex;
            this._proposedSelectedIndex = ListBase.NO_PROPOSED_SELECTION;

            if (oldSelectedIndex != ListBase.NO_SELECTION)
                this.itemSelected(oldSelectedIndex, false);
            if (this._selectedIndex != ListBase.NO_SELECTION)
                this.itemSelected(this._selectedIndex, true);

            //子类若需要自身抛出Change事件，而不是在此处抛出，可以设置dispatchChangedEvents为false
            if (dispatchChangedEvents) {
                if (this._dispatchChangeAfterSelection) {
                    egret.IndexChangeEvent.dispatchIndexChangeEvent(this, egret.IndexChangeEvent.CHANGE, oldSelectedIndex, this._selectedIndex);
                    this._dispatchChangeAfterSelection = false;
                }
                egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);
                ;
            }

            return true;
        };

        /**
        * 仅调整选中索引值而不更新选中项,即在提交属性阶段itemSelected方法不会被调用，也不会触发changing和change事件。
        * @method egret.ListBase#adjustSelection
        * @param newIndex {number} 新索引。
        * @param add {boolean} 如果已将项目添加到组件，则为 true；如果已删除项目，则为 false。
        */
        ListBase.prototype.adjustSelection = function (newIndex, add) {
            if (typeof add === "undefined") { add = false; }
            if (this._proposedSelectedIndex != ListBase.NO_PROPOSED_SELECTION)
                this._proposedSelectedIndex = newIndex;
            else
                this._selectedIndex = newIndex;
            this.selectedIndexAdjusted = true;
            this.invalidateProperties();
        };

        /**
        * 数据项添加
        * @method egret.ListBase#itemAdded
        * @param index {number}
        */
        ListBase.prototype.itemAdded = function (index) {
            if (this._doingWholesaleChanges)
                return;

            if (this.selectedIndex == ListBase.NO_SELECTION) {
                if (this.requireSelection)
                    this.adjustSelection(index, true);
            } else if (index <= this.selectedIndex) {
                this.adjustSelection(this.selectedIndex + 1, true);
            }
        };

        /**
        * 数据项移除
        * @method egret.ListBase#itemRemoved
        * @param index {number}
        */
        ListBase.prototype.itemRemoved = function (index) {
            if (this.selectedIndex == ListBase.NO_SELECTION || this._doingWholesaleChanges)
                return;

            if (index == this.selectedIndex) {
                if (this.requireSelection && this.dataProvider && this.dataProvider.length > 0) {
                    if (index == 0) {
                        this._proposedSelectedIndex = 0;
                        this.invalidateProperties();
                    } else
                        this._setSelectedIndex(0, false);
                } else
                    this.adjustSelection(-1, false);
            } else if (index < this.selectedIndex) {
                this.adjustSelection(this.selectedIndex - 1, false);
            }
        };

        /**
        * 项呈示器被添加
        * @method egret.ListBase#dataGroup_rendererAddHandler
        * @param event {RendererExistenceEvent}
        */
        ListBase.prototype.dataGroup_rendererAddHandler = function (event) {
            var renderer = (event.renderer);

            if (renderer == null)
                return;

            renderer.addEventListener(egret.TouchEvent.TOUCH_ROLL_OVER, this.item_mouseEventHandler, this);
            renderer.addEventListener(egret.TouchEvent.TOUCH_ROLL_OUT, this.item_mouseEventHandler, this);
        };

        /**
        * 项呈示器被移除
        * @method egret.ListBase#dataGroup_rendererRemoveHandler
        * @param event {RendererExistenceEvent}
        */
        ListBase.prototype.dataGroup_rendererRemoveHandler = function (event) {
            var renderer = (event.renderer);

            if (renderer == null)
                return;

            renderer.removeEventListener(egret.TouchEvent.TOUCH_ROLL_OVER, this.item_mouseEventHandler, this);
            renderer.removeEventListener(egret.TouchEvent.TOUCH_ROLL_OUT, this.item_mouseEventHandler, this);
        };

        /**
        * 项呈示器鼠标事件
        */
        ListBase.prototype.item_mouseEventHandler = function (event) {
            var type = event.type;
            type = ListBase.TYPE_MAP[type];
            if (this.hasEventListener(type)) {
                var itemRenderer = (event.currentTarget);
                this._dispatchListEvent(event, type, itemRenderer);
            }
        };

        /**
        * 抛出列表事件
        * @method egret.ListBase#_dispatchListEvent
        * @param touchEvent {TouchEvent} 相关联的鼠标事件
        * @param type {string} 事件名称
        * @param itemRenderer {IItemRenderer} 关联的条目渲染器实例
        */
        ListBase.prototype._dispatchListEvent = function (touchEvent, type, itemRenderer) {
            var itemIndex = -1;
            if (itemRenderer)
                itemIndex = itemRenderer.itemIndex;
            else
                itemIndex = this.dataGroup.getElementIndex((touchEvent.currentTarget));

            var item = this.dataProvider.getItemAt(itemIndex);
            egret.ListEvent.dispatchListEvent(this, type, touchEvent, itemIndex, item, itemRenderer);
        };

        /**
        * 数据源发生改变
        * @method egret.ListBase#dataProvider_collectionChangeHandler
        * @param event {CollectionEvent}
        */
        ListBase.prototype.dataProvider_collectionChangeHandler = function (event) {
            var items = event.items;
            if (event.kind == egret.CollectionEventKind.ADD) {
                var length = items.length;
                for (var i = 0; i < length; i++) {
                    this.itemAdded(event.location + i);
                }
            } else if (event.kind == egret.CollectionEventKind.REMOVE) {
                length = items.length;
                for (i = length - 1; i >= 0; i--) {
                    this.itemRemoved(event.location + i);
                }
            } else if (event.kind == egret.CollectionEventKind.MOVE) {
                this.itemRemoved(event.oldLocation);
                this.itemAdded(event.location);
            } else if (event.kind == egret.CollectionEventKind.RESET) {
                if (this.dataProvider.length == 0) {
                    this._setSelectedIndex(ListBase.NO_SELECTION, false);
                } else {
                    this.dataProviderChanged = true;
                    this.invalidateProperties();
                }
            } else if (event.kind == egret.CollectionEventKind.REFRESH) {
                this._setSelectedIndex(ListBase.NO_SELECTION, false);
            }
        };
        ListBase.NO_SELECTION = -1;

        ListBase.NO_PROPOSED_SELECTION = -2;

        ListBase.CUSTOM_SELECTED_ITEM = -3;

        ListBase.TYPE_MAP = {
            rollOver: "itemRollOver",
            rollOut: "itemRollOut" };
        return ListBase;
    })(egret.SkinnableDataContainer);
    egret.ListBase = ListBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Panel
    * @classdesc
    * 带有标题，内容区域的面板组件
    * @extends egret.SkinnableContainer
    */
    var Panel = (function (_super) {
        __extends(Panel, _super);
        /**
        * 构造函数
        * @method egret.Panel#constructor
        */
        function Panel() {
            _super.call(this);
            this._title = "";
            this.hostComponentKey = "egret.Panel";
            this.touchEnabled = false;
        }
        Object.defineProperty(Panel.prototype, "title", {
            /**
            * 标题文本内容
            * @member egret.Panel#title
            */
            get: function () {
                return this._title;
            },
            set: function (value) {
                this._title = value;

                if (this.titleDisplay)
                    this.titleDisplay.text = this.title;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.Panel#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        Panel.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.titleDisplay) {
                this.titleDisplay.text = this.title;
            }
        };
        return Panel;
    })(egret.SkinnableContainer);
    egret.Panel = Panel;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TitleWindow
    * @classdesc
    * 可移动窗口组件。注意，此窗口必须使用PopUpManager.addPopUp()弹出之后才能移动。
    * @extends egret.Panel
    */
    var TitleWindow = (function (_super) {
        __extends(TitleWindow, _super);
        /**
        * @method egret.TitleWindow#constructor
        */
        function TitleWindow() {
            _super.call(this);
            this._showCloseButton = true;
            this._autoBackToStage = true;
            this.hostComponentKey = "egret.TitleWindow";
            this.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onWindowMouseDown, this, true, 100);
        }
        /**
        * 在窗体上按下时前置窗口
        */
        TitleWindow.prototype.onWindowMouseDown = function (event) {
            if (this.enabled && this.isPopUp && event.target != this.closeButton) {
                egret.PopUpManager.bringToFront(this);
            }
        };

        Object.defineProperty(TitleWindow.prototype, "showCloseButton", {
            /**
            * 是否显示关闭按钮,默认true。
            * @member egret.TitleWindow#showCloseButton
            */
            get: function () {
                return this._showCloseButton;
            },
            set: function (value) {
                if (this._showCloseButton == value)
                    return;
                this._showCloseButton = value;
                if (this.closeButton)
                    this.closeButton.visible = this._showCloseButton;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TitleWindow.prototype, "autoBackToStage", {
            /**
            * 在拖拽窗口时，有可能把窗口完全拖出屏幕外，导致无法点中moveArea而不能拖回屏幕。
            * 此属性为true时，将会在拖拽结束时，自动调整窗口位置，使moveArea可以被再次点中。
            * 反之不调整。默认值为true。
            * @member egret.TitleWindow#autoBackToStage
            */
            get: function () {
                return this._autoBackToStage;
            },
            set: function (value) {
                this._autoBackToStage = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.TitleWindow#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        TitleWindow.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.moveArea) {
                this.moveArea.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.moveArea_mouseDownHandler, this);
            } else if (instance == this.closeButton) {
                this.closeButton.addEventListener(egret.TouchEvent.TOUCH_TAP, this.closeButton_clickHandler, this);
                this.closeButton.visible = this._showCloseButton;
            }
        };

        /**
        * @method egret.TitleWindow#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        TitleWindow.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);

            if (instance == this.moveArea)
                this.moveArea.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.moveArea_mouseDownHandler, this);
            else if (instance == this.closeButton)
                this.closeButton.removeEventListener(egret.TouchEvent.TOUCH_TAP, this.closeButton_clickHandler, this);
        };

        /**
        * @method egret.TitleWindow#closeButton_clickHandler
        * @param event {TouchEvent}
        */
        TitleWindow.prototype.closeButton_clickHandler = function (event) {
            egret.CloseEvent.dispatchCloseEvent(this, egret.CloseEvent.CLOSE);
        };

        /**
        * 鼠标在可移动区域按下
        * @method egret.TitleWindow#moveArea_mouseDownHandler
        * @param event {TouchEvent}
        */
        TitleWindow.prototype.moveArea_mouseDownHandler = function (event) {
            if (this.enabled && this.isPopUp) {
                var offsetPoint = this.globalToLocal(event.stageX, event.stageY, egret.Point.identity);
                this._offsetPointX = offsetPoint.x;
                this._offsetPointY = offsetPoint.y;
                this._includeInLayout = false;
                egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE, this.moveArea_mouseMoveHandler, this);
                egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.moveArea_mouseUpHandler, this);
                egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.moveArea_mouseUpHandler, this);
            }
        };

        /**
        * 鼠标拖拽时的移动事件
        * @method egret.TitleWindow#moveArea_mouseMoveHandler
        * @param event {TouchEvent}
        */
        TitleWindow.prototype.moveArea_mouseMoveHandler = function (event) {
            var pos = this.globalToLocal(event.stageX, event.stageY, egret.Point.identity);
            this.x += pos.x - this._offsetPointX;
            this.y += pos.y - this._offsetPointY;
        };

        /**
        * 鼠标在舞台上弹起事件
        * @method egret.TitleWindow#moveArea_mouseUpHandler
        * @param event {Event}
        */
        TitleWindow.prototype.moveArea_mouseUpHandler = function (event) {
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE, this.moveArea_mouseMoveHandler, this);
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.moveArea_mouseUpHandler, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.moveArea_mouseUpHandler, this);
            if (this._autoBackToStage) {
                this.adjustPosForStage();
            }
            egret.LayoutUtil.adjustRelativeByXY(this);
            this.includeInLayout = true;
        };

        /**
        * 调整窗口位置，使其可以在舞台中被点中
        */
        TitleWindow.prototype.adjustPosForStage = function () {
            if (!this.moveArea || !this.stage)
                return;
            var pos = this.moveArea.localToGlobal(0, 0);
            var stageX = pos.x;
            var stageY = pos.y;
            if (pos.x + this.moveArea.width < 35) {
                stageX = 35 - this.moveArea.width;
            }
            if (pos.x > this.stage.stageWidth - 20) {
                stageX = this.stage.stageWidth - 20;
            }
            if (pos.y + this.moveArea.height < 20) {
                stageY = 20 - this.moveArea.height;
            }
            if (pos.y > this.stage.stageHeight - 20) {
                stageY = this.stage.stageHeight - 20;
            }
            this.x += stageX - pos.x;
            this.y += stageY - pos.y;
        };
        return TitleWindow;
    })(egret.Panel);
    egret.TitleWindow = TitleWindow;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Alert
    * @classdesc
    * 弹出对话框，可能包含消息、标题、按钮（“确定”、“取消”、“是”和“否”的任意组合)。
    * @extends egret.TitleWindow
    */
    var Alert = (function (_super) {
        __extends(Alert, _super);
        /**
        * 构造函数，请通过静态方法Alert.show()来创建对象实例。
        * @method egret.Alert#constructor
        */
        function Alert() {
            _super.call(this);
            this._firstButtonLabel = "";
            this._secondButtonLabel = "";
            this._contentText = "";
            this.hostComponentKey = "egret.Alert";
        }
        /**
        * 弹出Alert控件的静态方法。在Alert控件中选择一个按钮，将关闭该控件。
        * @method egret.Alert.show
        * @param text {string} 要显示的文本内容字符串。
        * @param title {string} 对话框标题
        * @param closeHandler {Function} 按下Alert控件上的任意按钮时的回调函数。示例:closeHandler(event:CloseEvent);
        * event的detail属性包含 Alert.FIRST_BUTTON、Alert.SECOND_BUTTON和Alert.CLOSE_BUTTON。
        * @param firstButtonLabel {string} 第一个按钮上显示的文本。
        * @param secondButtonLabel {string} 第二个按钮上显示的文本，若为null，则不显示第二个按钮。
        * @param modal {boolean} 是否启用模态。即禁用弹出框以下的鼠标事件。默认true。
        * @param center {boolean} 是否居中。默认true。
        * @returns {Alert}
        */
        Alert.show = function (text, title, closeHandler, firstButtonLabel, secondButtonLabel, modal, center) {
            if (typeof text === "undefined") { text = ""; }
            if (typeof title === "undefined") { title = ""; }
            if (typeof closeHandler === "undefined") { closeHandler = null; }
            if (typeof firstButtonLabel === "undefined") { firstButtonLabel = "确定"; }
            if (typeof secondButtonLabel === "undefined") { secondButtonLabel = ""; }
            if (typeof modal === "undefined") { modal = true; }
            if (typeof center === "undefined") { center = true; }
            var alert = new Alert();
            alert.contentText = text;
            alert.title = title;
            alert._firstButtonLabel = firstButtonLabel;
            alert._secondButtonLabel = secondButtonLabel;
            alert.closeHandler = closeHandler;
            egret.PopUpManager.addPopUp(alert, modal, center);
            return alert;
        };

        Object.defineProperty(Alert.prototype, "firstButtonLabel", {
            /**
            * 第一个按钮上显示的文本
            * @member egret.Alert#firstButtonLabel
            */
            get: function () {
                return this._firstButtonLabel;
            },
            set: function (value) {
                if (this._firstButtonLabel == value)
                    return;
                this._firstButtonLabel = value;
                if (this.firstButton)
                    this.firstButton.label = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Alert.prototype, "secondButtonLabel", {
            /**
            * 第二个按钮上显示的文本
            * @member egret.Alert#secondButtonLabel
            */
            get: function () {
                return this._secondButtonLabel;
            },
            set: function (value) {
                if (this._secondButtonLabel == value)
                    return;
                this._secondButtonLabel = value;
                if (this.secondButton) {
                    if (value == null || value == "")
                        this.secondButton.includeInLayout = this.secondButton.visible = (this._secondButtonLabel != "" && this._secondButtonLabel != null);
                }
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Alert.prototype, "contentText", {
            /**
            * 文本内容
            * @member egret.Alert#contentText
            */
            get: function () {
                return this._contentText;
            },
            set: function (value) {
                if (this._contentText == value)
                    return;
                this._contentText = value;
                if (this.contentDisplay)
                    this.contentDisplay.text = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 关闭事件
        */
        Alert.prototype.onClose = function (event) {
            egret.PopUpManager.removePopUp(this);
            if (this.closeHandler != null) {
                var closeEvent = new egret.CloseEvent(egret.CloseEvent.CLOSE);
                switch (event.currentTarget) {
                    case this.firstButton:
                        closeEvent.detail = Alert.FIRST_BUTTON;
                        break;
                    case this.secondButton:
                        closeEvent.detail = Alert.SECOND_BUTTON;
                        break;
                }
                this.closeHandler(closeEvent);
            }
        };

        /**
        * @method egret.Alert#closeButton_clickHandler
        * @param event {TouchEvent}
        */
        Alert.prototype.closeButton_clickHandler = function (event) {
            _super.prototype.closeButton_clickHandler.call(this, event);
            egret.PopUpManager.removePopUp(this);
            var closeEvent = new egret.CloseEvent(egret.CloseEvent.CLOSE, false, false, Alert.CLOSE_BUTTON);
            if (this.closeHandler != null)
                this.closeHandler(closeEvent);
        };

        /**
        * @method egret.Alert#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        Alert.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);
            if (instance == this.contentDisplay) {
                this.contentDisplay.text = this._contentText;
            } else if (instance == this.firstButton) {
                this.firstButton.label = this._firstButtonLabel;
                this.firstButton.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onClose, this);
            } else if (instance == this.secondButton) {
                this.secondButton.label = this._secondButtonLabel;
                this.secondButton.includeInLayout = this.secondButton.visible = (this._secondButtonLabel != "" && this._secondButtonLabel != null);
                this.secondButton.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onClose, this);
            }
        };

        /**
        * @method egret.Alert#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        Alert.prototype.partRemoved = function (partName, instance) {
            _super.prototype.partRemoved.call(this, partName, instance);
            if (instance == this.firstButton) {
                this.firstButton.removeEventListener(egret.TouchEvent.TOUCH_TAP, this.onClose, this);
            } else if (instance == this.secondButton) {
                this.secondButton.removeEventListener(egret.TouchEvent.TOUCH_TAP, this.onClose, this);
            }
        };
        Alert.FIRST_BUTTON = "firstButton";

        Alert.SECOND_BUTTON = "secondButton";

        Alert.CLOSE_BUTTON = "closeButton";
        return Alert;
    })(egret.TitleWindow);
    egret.Alert = Alert;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ProgressBar
    * @classdesc
    * 进度条控件。
    * @extends egret.Range
    */
    var ProgressBar = (function (_super) {
        __extends(ProgressBar, _super);
        /**
        * @method egret.ProgressBar#constructor
        */
        function ProgressBar() {
            _super.call(this);
            this._slideDuration = 500;
            this._direction = egret.ProgressBarDirection.LEFT_TO_RIGHT;
            this.animationValue = 0;
            this.trackResizedOrMoved = false;
            this.hostComponentKey = "egret.ProgressBar";
        }
        Object.defineProperty(ProgressBar.prototype, "labelFunction", {
            /**
            * 进度条文本格式化回调函数。示例：labelFunction(value:Number,maximum:Number):String;
            * @member egret.ProgressBar#labelFunction
            */
            get: function () {
                return this._labelFunction;
            },
            set: function (value) {
                if (this._labelFunction == value)
                    return;
                this._labelFunction = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 将当前value转换成文本
        * @method egret.ProgressBar#valueToLabel
        * @param value {number}
        * @param maximum {number}
        * @returns {string}
        */
        ProgressBar.prototype.valueToLabel = function (value, maximum) {
            if (this.labelFunction != null) {
                return this._labelFunction(value, maximum);
            }
            return value + " / " + maximum;
        };

        Object.defineProperty(ProgressBar.prototype, "slideDuration", {
            /**
            * value改变时调整thumb长度的缓动动画时间，单位毫秒。设置为0则不执行缓动。默认值500。
            * @member egret.ProgressBar#slideDuration
            */
            get: function () {
                return this._slideDuration;
            },
            set: function (value) {
                if (this._slideDuration == value)
                    return;
                this._slideDuration = value;
                if (this.animator && this.animator.isPlaying) {
                    this.animator.stop();
                    this._setValue(this.slideToValue);
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ProgressBar.prototype, "direction", {
            /**
            * 进度条增长方向。请使用ProgressBarDirection定义的常量。默认值：ProgressBarDirection.LEFT_TO_RIGHT。
            * @member egret.ProgressBar#direction
            */
            get: function () {
                return this._direction;
            },
            set: function (value) {
                if (this._direction == value)
                    return;
                this._direction = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(ProgressBar.prototype, "value", {
            /**
            * 进度条的当前值。
            * 注意：当组件添加到显示列表后，若slideDuration不为0。设置此属性，并不会立即应用。而是作为目标值，开启缓动动画缓慢接近。
            * 若需要立即重置属性，请先设置slideDuration为0，或者把组件从显示列表移除。
            * @member egret.ProgressBar#value
            */
            get: function () {
                return this._getValue();
            },
            set: function (newValue) {
                if (this._getValue() == newValue)
                    return;
                this._setValue(newValue);
                if (this._slideDuration > 0 && this.stage) {
                    this.validateProperties(); //最大值最小值发生改变时要立即应用，防止当前起始值不正确。
                    if (!this.animator) {
                        this.animator = new egret.Animation(this.animationUpdateHandler, this);
                    }
                    if (this.animator.isPlaying) {
                        this.animationValue = this.slideToValue;
                        this.invalidateDisplayList();
                        this.animator.stop();
                    }
                    this.slideToValue = this.nearestValidValue(newValue, this.snapInterval);
                    if (this.slideToValue == this.animationValue)
                        return;
                    var duration = this._slideDuration * (Math.abs(this.animationValue - this.slideToValue) / (this.maximum - this.minimum));
                    this.animator.duration = duration === Infinity ? 0 : duration;
                    this.animator.motionPaths = [
                        { prop: "value", from: this.animationValue, to: this.slideToValue }
                    ];
                    this.animator.play();
                } else {
                    this.animationValue = this._getValue();
                }
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 动画播放更新数值
        */
        ProgressBar.prototype.animationUpdateHandler = function (animation) {
            var value = this.nearestValidValue(animation.currentValue["value"], this.snapInterval);
            this.animationValue = Math.min(this.maximum, Math.max(this.minimum, value));
            this.invalidateDisplayList();
        };

        /**
        * @method egret.ProgressBar#setValue
        * @param value {number}
        */
        ProgressBar.prototype.setValue = function (value) {
            _super.prototype.setValue.call(this, value);
            this.invalidateDisplayList();
        };

        /**
        * @method egret.ProgressBar#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        ProgressBar.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            this.updateSkinDisplayList();
        };

        /**
        * @method egret.ProgressBar#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        ProgressBar.prototype.partAdded = function (partName, instance) {
            if (instance == this.track) {
                if (this.track instanceof egret.UIComponent) {
                    this.track.addEventListener(egret.ResizeEvent.RESIZE, this.onTrackResizeOrMove, this);
                    this.track.addEventListener(egret.MoveEvent.MOVE, this.onTrackResizeOrMove, this);
                }
            }
        };

        /**
        * @method egret.ProgressBar#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        ProgressBar.prototype.partRemoved = function (partName, instance) {
            if (instance == this.track) {
                if (this.track instanceof egret.UIComponent) {
                    this.track.removeEventListener(egret.ResizeEvent.RESIZE, this.onTrackResizeOrMove, this);
                    this.track.removeEventListener(egret.MoveEvent.MOVE, this.onTrackResizeOrMove, this);
                }
            }
        };

        /**
        * track的位置或尺寸发生改变
        */
        ProgressBar.prototype.onTrackResizeOrMove = function (event) {
            this.trackResizedOrMoved = true;
            this.invalidateProperties();
        };

        /**
        * @method egret.ProgressBar#commitProperties
        */
        ProgressBar.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);
            if (this.trackResizedOrMoved) {
                this.trackResizedOrMoved = false;
                this.updateSkinDisplayList();
            }
        };

        /**
        * 更新皮肤部件大小和可见性。
        * @method egret.ProgressBar#updateSkinDisplayList
        */
        ProgressBar.prototype.updateSkinDisplayList = function () {
            this.trackResizedOrMoved = false;
            var currentValue = this.value;
            if (this.animator && this.animator.isPlaying) {
                currentValue = this.animationValue;
            } else {
                currentValue = this.value;
                if (isNaN(currentValue)) {
                    currentValue = 0;
                }
            }
            var maxValue = isNaN(this.maximum) ? 0 : this.maximum;
            if (this.thumb && this.track) {
                var trackWidth = isNaN(this.track.width) ? 0 : this.track.width;
                trackWidth *= this.track.scaleX;
                var trackHeight = isNaN(this.track.height) ? 0 : this.track.height;
                trackHeight *= this.track.scaleY;
                var thumbWidth = Math.round((currentValue / maxValue) * trackWidth);
                if (isNaN(thumbWidth) || thumbWidth < 0 || thumbWidth === Infinity)
                    thumbWidth = 0;
                var thumbHeight = Math.round((currentValue / maxValue) * trackHeight);
                if (isNaN(thumbHeight) || thumbHeight < 0 || thumbHeight === Infinity)
                    thumbHeight = 0;

                var p = this.track.localToGlobal(0, 0);
                var thumbPos = this.globalToLocal(p.x, p.y, egret.Point.identity);
                var thumbPosX = thumbPos.x;
                var thumbPosY = thumbPos.y;

                switch (this._direction) {
                    case egret.ProgressBarDirection.LEFT_TO_RIGHT:
                        this.thumb.width = thumbWidth;
                        this.thumb.height = trackHeight;
                        this.thumb.x = thumbPosX;
                        break;
                    case egret.ProgressBarDirection.RIGHT_TO_LEFT:
                        this.thumb.width = thumbWidth;
                        this.thumb.height = trackHeight;
                        this.thumb.x = thumbPosX + trackWidth - thumbWidth;
                        break;
                    case egret.ProgressBarDirection.TOP_TO_BOTTOM:
                        this.thumb.width = trackWidth;
                        this.thumb.height = thumbHeight;
                        this.thumb.y = thumbPosY;
                        break;
                    case egret.ProgressBarDirection.BOTTOM_TO_TOP:
                        this.thumb.width = trackWidth;
                        this.thumb.height = thumbHeight;
                        this.thumb.y = thumbPosY + trackHeight - thumbHeight;
                        break;
                }
            }
            if (this.labelDisplay) {
                this.labelDisplay.text = this.valueToLabel(currentValue, maxValue);
            }
        };
        return ProgressBar;
    })(egret.Range);
    egret.ProgressBar = ProgressBar;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.ProgressBarDirection
    * @classdesc
    * 定义进度条控件增长方向的常量
    */
    var ProgressBarDirection = (function () {
        function ProgressBarDirection() {
        }
        ProgressBarDirection.LEFT_TO_RIGHT = "leftToRight";

        ProgressBarDirection.RIGHT_TO_LEFT = "rightToLeft";

        ProgressBarDirection.TOP_TO_BOTTOM = "topToBottom";

        ProgressBarDirection.BOTTOM_TO_TOP = "bottomToTop";
        return ProgressBarDirection;
    })();
    egret.ProgressBarDirection = ProgressBarDirection;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.HSlider
    * @classdesc
    * 水平滑块控件
    * @extends egret.SliderBase
    */
    var HSlider = (function (_super) {
        __extends(HSlider, _super);
        /**
        * 构造函数
        * @method egret.HSlider#constructor
        */
        function HSlider() {
            _super.call(this);
            this.hostComponentKey = "egret.HSlider";
        }
        /**
        * @method egret.HSlider#pointToValue
        * @param x {number}
        * @param y {number}
        * @returns {number}
        */
        HSlider.prototype.pointToValue = function (x, y) {
            if (!this.thumb || !this.track)
                return 0;

            var range = this.maximum - this.minimum;
            var thumbRange = this.track.layoutBoundsWidth - this.thumb.layoutBoundsWidth;
            return this.minimum + ((thumbRange != 0) ? (x / thumbRange) * range : 0);
        };

        /**
        * @method egret.HSlider#updateSkinDisplayList
        */
        HSlider.prototype.updateSkinDisplayList = function () {
            if (!this.thumb || !this.track)
                return;

            var thumbRange = this.track.layoutBoundsWidth - this.thumb.layoutBoundsWidth;
            var range = this.maximum - this.minimum;
            var thumbPosTrackX = (range > 0) ? ((this.pendingValue - this.minimum) / range) * thumbRange : 0;
            var thumbPos = this.track.localToGlobal(thumbPosTrackX, 0);
            var thumbPosX = thumbPos.x;
            var thumbPosY = thumbPos.y;
            var thumbPosParentX = this.thumb.parent.globalToLocal(thumbPosX, thumbPosY, egret.Point.identity).x;

            this.thumb.setLayoutBoundsPosition(Math.round(thumbPosParentX), this.thumb.layoutBoundsY);
            if (this.showTrackHighlight && this.trackHighlight && this.trackHighlight.parent) {
                var trackHighlightX = this.trackHighlight.parent.globalToLocal(thumbPosX, thumbPosY, egret.Point.identity).x - thumbPosTrackX;
                this.trackHighlight.x = Math.round(trackHighlightX);
                this.trackHighlight.width = Math.round(thumbPosTrackX);
            }
        };
        return HSlider;
    })(egret.SliderBase);
    egret.HSlider = HSlider;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.VSlider
    * @classdesc
    * 垂直滑块控件
    * @extends egret.SliderBase
    */
    var VSlider = (function (_super) {
        __extends(VSlider, _super);
        /**
        * 构造函数
        * @method egret.VSlider#constructor
        */
        function VSlider() {
            _super.call(this);
            this.hostComponentKey = "egret.VSlider";
        }
        /**
        * @method egret.VSlider#pointToValue
        * @param x {number}
        * @param y {number}
        * @returns {number}
        */
        VSlider.prototype.pointToValue = function (x, y) {
            if (!this.thumb || !this.track)
                return 0;

            var range = this.maximum - this.minimum;
            var thumbRange = this.track.layoutBoundsHeight - this.thumb.layoutBoundsHeight;
            return this.minimum + ((thumbRange != 0) ? ((thumbRange - y) / thumbRange) * range : 0);
        };

        /**
        * @method egret.VSlider#updateSkinDisplayList
        */
        VSlider.prototype.updateSkinDisplayList = function () {
            if (!this.thumb || !this.track)
                return;

            var thumbHeight = this.thumb.layoutBoundsHeight;
            var thumbRange = this.track.layoutBoundsHeight - thumbHeight;
            var range = this.maximum - this.minimum;
            var thumbPosTrackY = (range > 0) ? thumbRange - (((this.pendingValue - this.minimum) / range) * thumbRange) : 0;
            var thumbPos = this.track.localToGlobal(0, thumbPosTrackY);
            var thumbPosX = thumbPos.x;
            var thumbPosY = thumbPos.y;
            var thumbPosParentY = this.thumb.parent.globalToLocal(thumbPosX, thumbPosY, egret.Point.identity).y;

            this.thumb.setLayoutBoundsPosition(this.thumb.layoutBoundsX, Math.round(thumbPosParentY));
            if (this.showTrackHighlight && this.trackHighlight && this.trackHighlight._parent) {
                var trackHighlightY = this.trackHighlight._parent.globalToLocal(thumbPosX, thumbPosY, egret.Point.identity).y;
                this.trackHighlight.y = Math.round(trackHighlightY + thumbHeight);
                this.trackHighlight.height = Math.round(thumbRange - trackHighlightY);
            }
        };
        return VSlider;
    })(egret.SliderBase);
    egret.VSlider = VSlider;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.List
    * @classdesc
    * 列表组件
    * @extends egret.ListBase
    */
    var List = (function (_super) {
        __extends(List, _super);
        /**
        * @method egret.List#constructor
        */
        function List() {
            _super.call(this);
            this._allowMultipleSelection = false;
            this._selectedIndices = [];
            /**
            * 是否捕获ItemRenderer以便在MouseUp时抛出ItemClick事件
            */
            this._captureItemRenderer = true;
            this.hostComponentKey = "egret.List";
            this.useVirtualLayout = true;
        }
        /**
        * @method egret.List#createChildren
        */
        List.prototype.createChildren = function () {
            if (!this.itemRenderer)
                this.itemRenderer = egret.DataGroup.defaultRendererFactory;
            _super.prototype.createChildren.call(this);
        };

        Object.defineProperty(List.prototype, "useVirtualLayout", {
            /**
            * 是否使用虚拟布局,默认true
            * @member egret.List#useVirtualLayout
            */
            get: function () {
                return this._getUseVirtualLayout();
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                this._setUseVirtualLayout(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(List.prototype, "allowMultipleSelection", {
            /**
            * 是否允许同时选中多项
            * @member egret.List#allowMultipleSelection
            */
            get: function () {
                return this._allowMultipleSelection;
            },
            set: function (value) {
                this._allowMultipleSelection = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(List.prototype, "selectedIndices", {
            /**
            * 当前选中的一个或多个项目的索引列表
            * @member egret.List#selectedIndices
            */
            get: function () {
                if (this._proposedSelectedIndices)
                    return this._proposedSelectedIndices;
                return this._selectedIndices;
            },
            set: function (value) {
                this._setSelectedIndices(value, false);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(List.prototype, "selectedIndex", {
            /**
            * @member egret.List#selectedIndex
            */
            get: function () {
                if (this._proposedSelectedIndices) {
                    if (this._proposedSelectedIndices.length > 0)
                        return this._proposedSelectedIndices[0];
                    return -1;
                }
                return this._getSelectedIndex();
            },
            set: function (value) {
                this._setSelectedIndex(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(List.prototype, "selectedItems", {
            /**
            * 当前选中的一个或多个项目的数据源列表
            * @member egret.List#selectedItems
            */
            get: function () {
                var result = [];
                var list = this.selectedIndices;
                if (list) {
                    var count = list.length;

                    for (var i = 0; i < count; i++)
                        result[i] = this.dataProvider.getItemAt(list[i]);
                }

                return result;
            },
            set: function (value) {
                var indices = [];

                if (value) {
                    var count = value.length;

                    for (var i = 0; i < count; i++) {
                        var index = this.dataProvider.getItemIndex(value[i]);
                        if (index != -1) {
                            indices.splice(0, 0, index);
                        }
                        if (index == -1) {
                            indices = [];
                            break;
                        }
                    }
                }
                this._setSelectedIndices(indices, false);
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 设置多个选中项
        */
        List.prototype._setSelectedIndices = function (value, dispatchChangeEvent) {
            if (typeof dispatchChangeEvent === "undefined") { dispatchChangeEvent = false; }
            if (dispatchChangeEvent)
                this._dispatchChangeAfterSelection = (this._dispatchChangeAfterSelection || dispatchChangeEvent);

            if (value)
                this._proposedSelectedIndices = value;
            else
                this._proposedSelectedIndices = [];
            this.invalidateProperties();
        };

        /**
        * @method egret.List#commitProperties
        */
        List.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);
            if (this._proposedSelectedIndices) {
                this.commitSelection();
            }
        };

        /**
        * @method egret.List#commitSelection
        * @param dispatchChangedEvents {boolean}
        * @returns {boolean}
        */
        List.prototype.commitSelection = function (dispatchChangedEvents) {
            if (typeof dispatchChangedEvents === "undefined") { dispatchChangedEvents = true; }
            var oldSelectedIndex = this._selectedIndex;
            if (this._proposedSelectedIndices) {
                this._proposedSelectedIndices = this._proposedSelectedIndices.filter(this.isValidIndex);

                if (!this.allowMultipleSelection && this._proposedSelectedIndices.length > 0) {
                    var temp = [];
                    temp.push(this._proposedSelectedIndices[0]);
                    this._proposedSelectedIndices = temp;
                }
                if (this._proposedSelectedIndices.length > 0) {
                    this._proposedSelectedIndex = this._proposedSelectedIndices[0];
                } else {
                    this._proposedSelectedIndex = -1;
                }
            }

            var retVal = _super.prototype.commitSelection.call(this, false);

            if (!retVal) {
                this._proposedSelectedIndices = null;
                return false;
            }

            if (this.selectedIndex > egret.ListBase.NO_SELECTION) {
                if (this._proposedSelectedIndices) {
                    if (this._proposedSelectedIndices.indexOf(this.selectedIndex) == -1)
                        this._proposedSelectedIndices.push(this.selectedIndex);
                } else {
                    this._proposedSelectedIndices = [this.selectedIndex];
                }
            }

            if (this._proposedSelectedIndices) {
                if (this._proposedSelectedIndices.indexOf(oldSelectedIndex) != -1)
                    this.itemSelected(oldSelectedIndex, true);
                this.commitMultipleSelection();
            }

            if (dispatchChangedEvents && retVal) {
                if (this._dispatchChangeAfterSelection) {
                    egret.IndexChangeEvent.dispatchIndexChangeEvent(this, egret.IndexChangeEvent.CHANGE, oldSelectedIndex, this._selectedIndex);
                    this._dispatchChangeAfterSelection = false;
                }
                egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.VALUE_COMMIT);
            }

            return retVal;
        };

        /**
        * 是否是有效的索引
        */
        List.prototype.isValidIndex = function (item, index, v) {
            return this.dataProvider && (item >= 0) && (item < this.dataProvider.length);
        };

        /**
        * 提交多项选中项属性
        * @method egret.List#commitMultipleSelection
        */
        List.prototype.commitMultipleSelection = function () {
            var removedItems = [];
            var addedItems = [];
            var i;
            var count;

            if (this._selectedIndices.length > 0 && this._proposedSelectedIndices.length > 0) {
                count = this._proposedSelectedIndices.length;
                for (i = 0; i < count; i++) {
                    if (this._selectedIndices.indexOf(this._proposedSelectedIndices[i]) == -1)
                        addedItems.push(this._proposedSelectedIndices[i]);
                }
                count = this._selectedIndices.length;
                for (i = 0; i < count; i++) {
                    if (this._proposedSelectedIndices.indexOf(this._selectedIndices[i]) == -1)
                        removedItems.push(this._selectedIndices[i]);
                }
            } else if (this._selectedIndices.length > 0) {
                removedItems = this._selectedIndices;
            } else if (this._proposedSelectedIndices.length > 0) {
                addedItems = this._proposedSelectedIndices;
            }

            this._selectedIndices = this._proposedSelectedIndices;

            if (removedItems.length > 0) {
                count = removedItems.length;
                for (i = 0; i < count; i++) {
                    this.itemSelected(removedItems[i], false);
                }
            }

            if (addedItems.length > 0) {
                count = addedItems.length;
                for (i = 0; i < count; i++) {
                    this.itemSelected(addedItems[i], true);
                }
            }

            this._proposedSelectedIndices = null;
        };

        List.prototype._isItemIndexSelected = function (index) {
            if (this._allowMultipleSelection)
                return this._selectedIndices.indexOf(index) != -1;

            return _super.prototype._isItemIndexSelected.call(this, index);
        };

        /**
        * @method egret.List#dataGroup_rendererAddHandler
        * @param event {RendererExistenceEvent}
        */
        List.prototype.dataGroup_rendererAddHandler = function (event) {
            _super.prototype.dataGroup_rendererAddHandler.call(this, event);

            var renderer = (event.renderer);
            if (renderer == null)
                return;

            renderer.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.item_mouseDownHandler, this);

            //由于ItemRenderer.mouseChildren有可能不为false，在鼠标按下时会出现切换素材的情况，
            //导致target变化而无法抛出原生的click事件,所以此处监听MouseUp来抛出ItemClick事件。
            renderer.addEventListener(egret.TouchEvent.TOUCH_END, this.item_mouseUpHandler, this);
        };

        /**
        * @method egret.List#dataGroup_rendererRemoveHandler
        * @param event {RendererExistenceEvent}
        */
        List.prototype.dataGroup_rendererRemoveHandler = function (event) {
            _super.prototype.dataGroup_rendererRemoveHandler.call(this, event);

            var renderer = (event.renderer);
            if (renderer == null)
                return;

            renderer.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.item_mouseDownHandler, this);
            renderer.removeEventListener(egret.TouchEvent.TOUCH_END, this.item_mouseUpHandler, this);
        };

        /**
        * 鼠标在项呈示器上按下
        * @method egret.List#item_mouseDownHandler
        * @param event {TouchEvent}
        */
        List.prototype.item_mouseDownHandler = function (event) {
            if (event.isDefaultPrevented())
                return;

            var itemRenderer = (event.currentTarget);
            var newIndex;
            if (itemRenderer)
                newIndex = itemRenderer.itemIndex;
            else
                newIndex = this.dataGroup.getElementIndex((event.currentTarget));
            if (this._allowMultipleSelection) {
                this._setSelectedIndices(this.calculateSelectedIndices(newIndex, event.shiftKey, event.ctrlKey), true);
            } else {
                this._setSelectedIndex(newIndex, true);
            }
            if (!this._captureItemRenderer)
                return;
            this.mouseDownItemRenderer = itemRenderer;
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
        };

        /**
        * 计算当前的选中项列表
        */
        List.prototype.calculateSelectedIndices = function (index, shiftKey, ctrlKey) {
            var i;
            var interval = [];
            if (!shiftKey) {
                if (ctrlKey) {
                    if (this._selectedIndices.length > 0) {
                        if (this._selectedIndices.length == 1 && (this._selectedIndices[0] == index)) {
                            if (!this.requireSelection)
                                return interval;

                            interval.splice(0, 0, this._selectedIndices[0]);
                            return interval;
                        } else {
                            var found = false;
                            for (i = 0; i < this._selectedIndices.length; i++) {
                                if (this._selectedIndices[i] == index)
                                    found = true;
                                else if (this._selectedIndices[i] != index)
                                    interval.splice(0, 0, this._selectedIndices[i]);
                            }
                            if (!found) {
                                interval.splice(0, 0, index);
                            }
                            return interval;
                        }
                    } else {
                        interval.splice(0, 0, index);
                        return interval;
                    }
                } else {
                    interval.splice(0, 0, index);
                    return interval;
                }
            } else {
                var start = this._selectedIndices.length > 0 ? this._selectedIndices[this._selectedIndices.length - 1] : 0;
                var end = index;
                if (start < end) {
                    for (i = start; i <= end; i++) {
                        interval.splice(0, 0, i);
                    }
                } else {
                    for (i = start; i >= end; i--) {
                        interval.splice(0, 0, i);
                    }
                }
                return interval;
            }
        };

        /**
        * 鼠标在项呈示器上弹起，抛出ItemClick事件。
        */
        List.prototype.item_mouseUpHandler = function (event) {
            var itemRenderer = (event.currentTarget);
            if (itemRenderer != this.mouseDownItemRenderer)
                return;
            this._dispatchListEvent(event, egret.ListEvent.ITEM_CLICK, itemRenderer);
        };

        /**
        * 鼠标在舞台上弹起
        */
        List.prototype.stage_mouseUpHandler = function (event) {
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
            this.mouseDownItemRenderer = null;
        };
        return List;
    })(egret.ListBase);
    egret.List = List;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.PopUpAnchor
    * @classdesc
    * PopUpAnchor组件用于定位布局中的弹出控件或下拉控件
    * @extends egret.UIComponent
    */
    var PopUpAnchor = (function (_super) {
        __extends(PopUpAnchor, _super);
        /**
        * 构造函数
        * @method egret.PopUpAnchor#constructor
        */
        function PopUpAnchor() {
            _super.call(this);
            /**
            * popUp已经弹出的标志
            */
            this.popUpIsDisplayed = false;
            /**
            * 自身已经添加到舞台标志
            */
            this.addedToStage = false;
            this._popUpHeightMatchesAnchorHeight = false;
            this._popUpWidthMatchesAnchorWidth = false;
            this._displayPopUp = false;
            this._popUpPosition = egret.PopUpPosition.TOP_LEFT;
            /**
            * 正在播放动画的标志
            */
            this.inAnimation = false;
            /**
            * 动画类实例
            */
            this.animator = null;
            this._openDuration = 250;
            this._closeDuration = 150;
            this.valueRange = 1;
            this.addEventListener(egret.Event.ADDED_TO_STAGE, this.addedToStageHandler, this);
            this.addEventListener(egret.Event.REMOVED_FROM_STAGE, this.removedFromStageHandler, this);
        }
        Object.defineProperty(PopUpAnchor.prototype, "popUpHeightMatchesAnchorHeight", {
            /**
            * 如果为 true，则将popUp控件的高度设置为 PopUpAnchor的高度值。
            * @member egret.PopUpAnchor#popUpHeightMatchesAnchorHeight
            */
            get: function () {
                return this._popUpHeightMatchesAnchorHeight;
            },
            set: function (value) {
                if (this._popUpHeightMatchesAnchorHeight == value)
                    return;

                this._popUpHeightMatchesAnchorHeight = value;

                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(PopUpAnchor.prototype, "popUpWidthMatchesAnchorWidth", {
            /**
            * 如果为true，则将popUp控件的宽度设置为PopUpAnchor的宽度值。
            * @member egret.PopUpAnchor#popUpWidthMatchesAnchorWidth
            */
            get: function () {
                return this._popUpWidthMatchesAnchorWidth;
            },
            set: function (value) {
                if (this._popUpWidthMatchesAnchorWidth == value)
                    return;

                this._popUpWidthMatchesAnchorWidth = value;

                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(PopUpAnchor.prototype, "displayPopUp", {
            /**
            * 如果为 true，则将popUp对象弹出。若为false，关闭弹出的popUp。
            * @member egret.PopUpAnchor#displayPopUp
            */
            get: function () {
                return this._displayPopUp;
            },
            set: function (value) {
                if (this._displayPopUp == value)
                    return;

                this._displayPopUp = value;
                this.addOrRemovePopUp();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(PopUpAnchor.prototype, "popUp", {
            /**
            * 要弹出或移除的目标显示对象。
            * @member egret.PopUpAnchor#popUp
            */
            get: function () {
                return this._popUp;
            },
            set: function (value) {
                if (this._popUp == value)
                    return;

                this._popUp = value;

                this.dispatchEventWith("popUpChanged");
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(PopUpAnchor.prototype, "popUpPosition", {
            /**
            * popUp相对于PopUpAnchor的弹出位置。请使用PopUpPosition里定义的常量。默认值TOP_LEFT。
            * @see org.flexlite.domUI.core.PopUpPosition
            * @member egret.PopUpAnchor#popUpPosition
            */
            get: function () {
                return this._popUpPosition;
            },
            set: function (value) {
                if (this._popUpPosition == value)
                    return;

                this._popUpPosition = value;
                this.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.PopUpAnchor#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        PopUpAnchor.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            this.applyPopUpTransform(unscaledWidth, unscaledHeight);
        };

        /**
        * 手动刷新popUp的弹出位置和尺寸。
        * @method egret.PopUpAnchor#updatePopUpTransform
        */
        PopUpAnchor.prototype.updatePopUpTransform = function () {
            this.applyPopUpTransform(this.width, this.height);
        };

        /**
        * 计算popUp的弹出位置
        */
        PopUpAnchor.prototype.calculatePopUpPosition = function () {
            var registrationPoint = egret.Point.identity;
            switch (this._popUpPosition) {
                case egret.PopUpPosition.BELOW:
                    registrationPoint.x = 0;
                    registrationPoint.y = this.height;
                    break;
                case egret.PopUpPosition.ABOVE:
                    registrationPoint.x = 0;
                    registrationPoint.y = -this.popUp.layoutBoundsHeight;
                    break;
                case egret.PopUpPosition.LEFT:
                    registrationPoint.x = -this.popUp.layoutBoundsWidth;
                    registrationPoint.y = 0;
                    break;
                case egret.PopUpPosition.RIGHT:
                    registrationPoint.x = this.width;
                    registrationPoint.y = 0;
                    break;
                case egret.PopUpPosition.CENTER:
                    registrationPoint.x = (this.width - this.popUp.layoutBoundsWidth) * 0.5;
                    registrationPoint.y = (this.height - this.popUp.layoutBoundsHeight) * 0.5;
                    break;
                case egret.PopUpPosition.TOP_LEFT:
                    break;
            }
            registrationPoint = this.localToGlobal(registrationPoint.x, registrationPoint.y, registrationPoint);
            registrationPoint = this.popUp.parent.globalToLocal(registrationPoint.x, registrationPoint.y, registrationPoint);
            return registrationPoint;
        };

        Object.defineProperty(PopUpAnchor.prototype, "openDuration", {
            /**
            * 窗口弹出的动画时间(以毫秒为单位)，设置为0则直接弹出窗口而不播放动画效果。默认值250。
            * @member egret.PopUpAnchor#openDuration
            */
            get: function () {
                return this._openDuration;
            },
            set: function (value) {
                this._openDuration = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(PopUpAnchor.prototype, "closeDuration", {
            /**
            * 窗口关闭的动画时间(以毫秒为单位)，设置为0则直接关闭窗口而不播放动画效果。默认值150。
            * @member egret.PopUpAnchor#closeDuration
            */
            get: function () {
                return this._closeDuration;
            },
            set: function (value) {
                this._closeDuration = value;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 动画开始播放触发的函数
        */
        PopUpAnchor.prototype.animationStartHandler = function (animation) {
            this.inAnimation = true;
            if (this.popUp && "enabled" in this.popUp)
                (this.popUp).enabled = false;
        };

        /**
        * 动画播放过程中触发的更新数值函数
        */
        PopUpAnchor.prototype.animationUpdateHandler = function (animation) {
            var rect = (this.popUp)._scrollRect;
            var x = Math.round(animation.currentValue["x"]);
            var y = Math.round(animation.currentValue["y"]);
            if (rect) {
                rect.x = x;
                rect.y = y;
                rect.width = this.popUp.width;
                rect.height = this.popUp.height;
            } else {
                (this.popUp)._scrollRect = new egret.Rectangle(x, y, this.popUp.width, this.popUp.height);
            }
        };

        /**
        * 动画播放完成触发的函数
        */
        PopUpAnchor.prototype.animationEndHandler = function (animation) {
            this.inAnimation = false;
            if (this.popUp && "enabled" in this.popUp)
                (this.popUp).enabled = true;
            (this.popUp).scrollRect = null;
            if (!this.popUpIsDisplayed) {
                egret.PopUpManager.removePopUp(this.popUp);
                this.popUp.ownerChanged(null);
            }
        };

        /**
        * 添加或移除popUp
        */
        PopUpAnchor.prototype.addOrRemovePopUp = function () {
            if (!this.addedToStage || !this.popUp)
                return;

            if (this.popUp.parent == null && this.displayPopUp) {
                egret.PopUpManager.addPopUp(this.popUp, false, false);
                this.popUp.ownerChanged(this);
                this.popUpIsDisplayed = true;
                if (this.inAnimation)
                    this.animator.end();
                if (this.initialized) {
                    this.applyPopUpTransform(this.width, this.height);
                    if (this._openDuration > 0)
                        this.startAnimation();
                } else {
                    egret.callLater(function () {
                        if (this.openDuration > 0)
                            this.startAnimation();
                    }, this);
                }
            } else if (this.popUp.parent != null && !this.displayPopUp) {
                this.removeAndResetPopUp();
            }
        };

        /**
        * 移除并重置popUp
        */
        PopUpAnchor.prototype.removeAndResetPopUp = function () {
            if (this.inAnimation)
                this.animator.end();
            this.popUpIsDisplayed = false;
            if (this._closeDuration > 0) {
                this.startAnimation();
            } else {
                egret.PopUpManager.removePopUp(this.popUp);
                this.popUp.ownerChanged(null);
            }
        };

        /**
        * 对popUp应用尺寸和位置调整
        */
        PopUpAnchor.prototype.applyPopUpTransform = function (unscaledWidth, unscaledHeight) {
            if (!this.popUpIsDisplayed)
                return;
            if (this.popUpWidthMatchesAnchorWidth)
                this.popUp.width = unscaledWidth;
            if (this.popUpHeightMatchesAnchorHeight)
                this.popUp.height = unscaledHeight;
            if ("validateNow" in this.popUp)
                (this.popUp).validateNow();
            var popUpPoint = this.calculatePopUpPosition();
            this.popUp.x = popUpPoint.x;
            this.popUp.y = popUpPoint.y;
        };

        /**
        * 开始播放动画
        */
        PopUpAnchor.prototype.startAnimation = function () {
            if (!this.animator) {
                this.animator = new egret.Animation(this.animationUpdateHandler, this);
                this.animator.endFunction = this.animationEndHandler;
                this.animator.startFunction = this.animationStartHandler;
            }
            this.animator.motionPaths = this.createMotionPath();
            if (this.popUpIsDisplayed) {
                this.animator.duration = this._openDuration;
            } else {
                this.animator.duration = this._closeDuration;
            }
            this.animator.play();
        };

        /**
        * 创建动画轨迹
        */
        PopUpAnchor.prototype.createMotionPath = function () {
            var xPath = { prop: "x" };
            var yPath = { prop: "y" };
            var path = [xPath, yPath];
            switch (this._popUpPosition) {
                case egret.PopUpPosition.TOP_LEFT:
                case egret.PopUpPosition.CENTER:
                case egret.PopUpPosition.BELOW:
                    xPath.from = xPath.to = 0;
                    yPath.from = this.popUp.height;
                    yPath.to = 0;
                    this.valueRange = this.popUp.height;
                    break;
                case egret.PopUpPosition.ABOVE:
                    xPath.from = xPath.to = 0;
                    yPath.from = -this.popUp.height;
                    yPath.to = 0;
                    this.valueRange = this.popUp.height;
                    break;
                case egret.PopUpPosition.LEFT:
                    yPath.from = yPath.to = 0;
                    xPath.from = -this.popUp.width;
                    xPath.to = 0;
                    this.valueRange = this.popUp.width;
                    break;
                case egret.PopUpPosition.RIGHT:
                    yPath.from = yPath.to = 0;
                    xPath.from = this.popUp.width;
                    xPath.to = 0;
                    this.valueRange = this.popUp.width;
                    break;
                default:
                    this.valueRange = 1;
                    break;
            }
            this.valueRange = Math.abs(this.valueRange);
            if (!this.popUpIsDisplayed) {
                var tempValue = xPath.from;
                xPath.from = xPath.to;
                xPath.to = tempValue;
                tempValue = yPath.from;
                yPath.from = yPath.to;
                yPath.to = tempValue;
            }
            return path;
        };

        /**
        * 添加到舞台事件
        */
        PopUpAnchor.prototype.addedToStageHandler = function (event) {
            this.addedToStage = true;
            egret.callLater(this.checkPopUpState, this);
        };

        /**
        * 延迟检查弹出状态，防止堆栈溢出。
        */
        PopUpAnchor.prototype.checkPopUpState = function () {
            if (this.addedToStage) {
                this.addOrRemovePopUp();
            } else {
                if (this.popUp != null && (this.popUp).parent != null)
                    this.removeAndResetPopUp();
            }
        };

        /**
        * 从舞台移除事件
        */
        PopUpAnchor.prototype.removedFromStageHandler = function (event) {
            this.addedToStage = false;
            egret.callLater(this.checkPopUpState, this);
        };
        return PopUpAnchor;
    })(egret.UIComponent);
    egret.PopUpAnchor = PopUpAnchor;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DropDownController
    * @classdesc
    * 用于处理因用户交互而打开和关闭下拉列表的操作的控制器
    * @extends egret.EventDispatcher
    */
    var DropDownController = (function (_super) {
        __extends(DropDownController, _super);
        /**
        * 构造函数
        * @method egret.DropDownController#constructor
        */
        function DropDownController() {
            _super.call(this);
            this._isOpen = false;
            this._closeOnResize = true;
            this._rollOverOpenDelay = NaN;
        }
        Object.defineProperty(DropDownController.prototype, "openButton", {
            /**
            * 下拉按钮实例
            * @member egret.DropDownController#openButton
            */
            get: function () {
                return this._openButton;
            },
            set: function (value) {
                if (this._openButton === value)
                    return;
                this.removeOpenTriggers();
                this._openButton = value;
                this.addOpenTriggers();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DropDownController.prototype, "dropDown", {
            /**
            * 下拉区域显示对象
            * @member egret.DropDownController#dropDown
            */
            get: function () {
                return this._dropDown;
            },
            set: function (value) {
                if (this._dropDown === value)
                    return;

                this._dropDown = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DropDownController.prototype, "isOpen", {
            /**
            * 下拉列表已经打开的标志
            * @member egret.DropDownController#isOpen
            */
            get: function () {
                return this._isOpen;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(DropDownController.prototype, "closeOnResize", {
            /**
            * 如果为 true，则在调整舞台大小时会关闭下拉列表。
            * @member egret.DropDownController#closeOnResize
            */
            get: function () {
                return this._closeOnResize;
            },
            set: function (value) {
                if (this._closeOnResize == value)
                    return;
                if (this.isOpen)
                    this.removeCloseOnResizeTrigger();

                this._closeOnResize = value;

                this.addCloseOnResizeTrigger();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DropDownController.prototype, "rollOverOpenDelay", {
            /**
            * 指定滑过锚点按钮时打开下拉列表要等待的延迟（以毫秒为单位）。
            * 如果设置为 NaN，则下拉列表会在单击时打开，而不是在滑过时打开。默认值NaN
            * @member egret.DropDownController#rollOverOpenDelay
            */
            get: function () {
                return this._rollOverOpenDelay;
            },
            set: function (value) {
                if (this._rollOverOpenDelay == value)
                    return;

                this.removeOpenTriggers();

                this._rollOverOpenDelay = value;

                this.addOpenTriggers();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 添加触发下拉列表打开的事件监听
        */
        DropDownController.prototype.addOpenTriggers = function () {
            if (this.openButton) {
                if (isNaN(this.rollOverOpenDelay))
                    this.openButton.addEventListener(egret.UIEvent.BUTTON_DOWN, this._openButton_buttonDownHandler, this);
                else
                    this.openButton.addEventListener(egret.TouchEvent.TOUCH_ROLL_OVER, this._openButton_rollOverHandler, this);
            }
        };

        /**
        * 移除触发下拉列表打开的事件监听
        */
        DropDownController.prototype.removeOpenTriggers = function () {
            if (this.openButton) {
                if (isNaN(this.rollOverOpenDelay))
                    this.openButton.removeEventListener(egret.UIEvent.BUTTON_DOWN, this._openButton_buttonDownHandler, this);
                else
                    this.openButton.removeEventListener(egret.TouchEvent.TOUCH_ROLL_OVER, this._openButton_rollOverHandler, this);
            }
        };

        /**
        * 添加触发下拉列表关闭的事件监听
        */
        DropDownController.prototype.addCloseTriggers = function () {
            if (egret.UIGlobals.stage) {
                if (isNaN(this.rollOverOpenDelay)) {
                    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.stage_mouseDownHandler, this);
                    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler_noRollOverOpenDelay, this);
                } else {
                    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE, this.stage_mouseMoveHandler, this);
                }

                this.addCloseOnResizeTrigger();
            }
        };

        /**
        * 移除触发下拉列表关闭的事件监听
        */
        DropDownController.prototype.removeCloseTriggers = function () {
            if (egret.UIGlobals.stage) {
                if (isNaN(this.rollOverOpenDelay)) {
                    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.stage_mouseDownHandler, this);
                    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler_noRollOverOpenDelay, this);
                } else {
                    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE, this.stage_mouseMoveHandler, this);
                    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
                    egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
                }

                this.removeCloseOnResizeTrigger();
            }
        };

        /**
        * 添加舞台尺寸改变的事件监听
        */
        DropDownController.prototype.addCloseOnResizeTrigger = function () {
            if (this.closeOnResize)
                egret.UIGlobals.stage.addEventListener(egret.Event.RESIZE, this.stage_resizeHandler, this);
        };

        /**
        * 移除舞台尺寸改变的事件监听
        */
        DropDownController.prototype.removeCloseOnResizeTrigger = function () {
            if (this.closeOnResize)
                egret.UIGlobals.stage.removeEventListener(egret.Event.RESIZE, this.stage_resizeHandler, this);
        };

        /**
        * 检查鼠标是否在DropDown或者openButton区域内。
        */
        DropDownController.prototype.isTargetOverDropDownOrOpenButton = function (target) {
            if (target) {
                if (this.openButton && this.openButton.contains(target))
                    return true;
                if (this.hitAreaAdditions != null) {
                    for (var i = 0; i < this.hitAreaAdditions.length; i++) {
                        if (this.hitAreaAdditions[i] == target || ((this.hitAreaAdditions[i] instanceof egret.DisplayObjectContainer) && (this.hitAreaAdditions[i]).contains(target)))
                            return true;
                    }
                }
                if (this.dropDown instanceof egret.DisplayObjectContainer) {
                    if ((this.dropDown).contains(target))
                        return true;
                } else {
                    if (target == this.dropDown)
                        return true;
                }
            }

            return false;
        };

        /**
        * 打开下拉列表
        * @method egret.DropDownController#openDropDown
        */
        DropDownController.prototype.openDropDown = function () {
            this.openDropDownHelper();
        };

        /**
        * 执行打开下拉列表
        */
        DropDownController.prototype.openDropDownHelper = function () {
            if (!this.isOpen) {
                this.addCloseTriggers();

                this._isOpen = true;

                if (this.openButton)
                    this.openButton._setKeepDown(true);
                egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.OPEN);
            }
        };

        /**
        * 关闭下拉列表
        * @method egret.DropDownController#closeDropDown
        * @param commit {boolean}
        */
        DropDownController.prototype.closeDropDown = function (commit) {
            if (this.isOpen) {
                this._isOpen = false;
                if (this.openButton)
                    this.openButton._setKeepDown(false);

                var dde = new egret.UIEvent(egret.UIEvent.CLOSE, false, true);

                if (!commit)
                    dde.preventDefault();

                this.dispatchEvent(dde);

                this.removeCloseTriggers();
            }
        };

        /**
        * openButton上按下鼠标事件
        * @method egret.DropDownController#_openButton_buttonDownHandler
        * @param event {Event}
        */
        DropDownController.prototype._openButton_buttonDownHandler = function (event) {
            if (this.isOpen)
                this.closeDropDown(true);
            else {
                this.mouseIsDown = true;
                this.openDropDownHelper();
            }
        };

        /**
        * openButton上鼠标经过事件
        * @method egret.DropDownController#_openButton_rollOverHandler
        * @param event {TouchEvent}
        */
        DropDownController.prototype._openButton_rollOverHandler = function (event) {
            if (this.rollOverOpenDelay == 0)
                this.openDropDownHelper();
            else {
                this.openButton.addEventListener(egret.TouchEvent.TOUCH_ROLL_OUT, this.openButton_rollOutHandler, this);
                this.rollOverOpenDelayTimer = new egret.Timer(this.rollOverOpenDelay, 1);
                this.rollOverOpenDelayTimer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, this.rollOverDelay_timerCompleteHandler, this);
                this.rollOverOpenDelayTimer.start();
            }
        };

        /**
        * openButton上鼠标移出事件
        */
        DropDownController.prototype.openButton_rollOutHandler = function (event) {
            if (this.rollOverOpenDelayTimer && this.rollOverOpenDelayTimer.running) {
                this.rollOverOpenDelayTimer.stop();
                this.rollOverOpenDelayTimer = null;
            }

            this.openButton.removeEventListener(egret.TouchEvent.TOUCH_ROLL_OUT, this.openButton_rollOutHandler, this);
        };

        /**
        * 到达鼠标移入等待延迟打开的时间。
        */
        DropDownController.prototype.rollOverDelay_timerCompleteHandler = function (event) {
            this.openButton.removeEventListener(egret.TouchEvent.TOUCH_ROLL_OUT, this.openButton_rollOutHandler, this);
            this.rollOverOpenDelayTimer = null;

            this.openDropDownHelper();
        };

        /**
        * 舞台上鼠标按下事件
        * @method egret.DropDownController#stage_mouseDownHandler
        * @param event {Event}
        */
        DropDownController.prototype.stage_mouseDownHandler = function (event) {
            if (this.mouseIsDown) {
                this.mouseIsDown = false;
                return;
            }

            if (!this.dropDown || (this.dropDown && (event.target == this.dropDown || (this.dropDown instanceof egret.DisplayObjectContainer && !(this.dropDown).contains((event.target)))))) {
                var target = (event.target);
                if (this.openButton && target && this.openButton.contains(target))
                    return;

                if (this.hitAreaAdditions != null) {
                    for (var i = 0; i < this.hitAreaAdditions.length; i++) {
                        if (this.hitAreaAdditions[i] == event.target || ((this.hitAreaAdditions[i] instanceof egret.DisplayObjectContainer) && (this.hitAreaAdditions[i]).contains((event.target))))
                            return;
                    }
                }

                this.closeDropDown(true);
            }
        };

        /**
        * 舞台上鼠标移动事件
        * @method egret.DropDownController#stage_mouseMoveHandler
        * @param event {Event}
        */
        DropDownController.prototype.stage_mouseMoveHandler = function (event) {
            var target = (event.target);
            var containedTarget = this.isTargetOverDropDownOrOpenButton(target);

            if (containedTarget)
                return;
            if (event instanceof egret.TouchEvent && event.touchDown) {
                egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
                egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
                return;
            }
            this.closeDropDown(true);
        };

        /**
        * 舞台上鼠标弹起事件
        * @method egret.DropDownController#stage_mouseUpHandler_noRollOverOpenDelay
        * @param event {Event}
        */
        DropDownController.prototype.stage_mouseUpHandler_noRollOverOpenDelay = function (event) {
            if (this.mouseIsDown) {
                this.mouseIsDown = false;
                return;
            }
        };

        /**
        * 舞台上鼠标弹起事件
        * @method egret.DropDownController#stage_mouseUpHandler
        * @param event {Event}
        */
        DropDownController.prototype.stage_mouseUpHandler = function (event) {
            var target = (event.target);
            var containedTarget = this.isTargetOverDropDownOrOpenButton(target);
            if (containedTarget) {
                egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
                egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.stage_mouseUpHandler, this);
                return;
            }

            this.closeDropDown(true);
        };

        /**
        * 舞台尺寸改变事件
        * @method egret.DropDownController#stage_resizeHandler
        * @param event {Event}
        */
        DropDownController.prototype.stage_resizeHandler = function (event) {
            this.closeDropDown(true);
        };

        /**
        * 舞台上鼠标滚轮事件
        */
        DropDownController.prototype.stage_mouseWheelHandler = function (event) {
            if (this.dropDown && !((this.dropDown).contains((event.target)) && event.isDefaultPrevented()))
                this.closeDropDown(false);
        };
        return DropDownController;
    })(egret.EventDispatcher);
    egret.DropDownController = DropDownController;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DropDownListBase
    * @classdesc
    * 下拉列表控件基类
    * @extends egret.List
    */
    var DropDownListBase = (function (_super) {
        __extends(DropDownListBase, _super);
        /**
        * 构造函数
        * @method egret.DropDownListBase#constructor
        */
        function DropDownListBase() {
            _super.call(this);
            /**
            * 文本改变标志
            */
            this._labelChanged = false;
            this._userProposedSelectedIndex = egret.ListBase.NO_SELECTION;
            this._captureItemRenderer = false;
            this.dropDownController = new egret.DropDownController();
        }
        /**
        * @inheritDoc
        */
        DropDownListBase.prototype._setDataProvider = function (value) {
            if (this.dataProvider === value)
                return;

            _super.prototype._setDataProvider.call(this, value);
            this._labelChanged = true;
            this.invalidateProperties();
        };

        /**
        * @inheritDoc
        */
        DropDownListBase.prototype._setLabelField = function (value) {
            if (this.labelField == value)
                return;

            _super.prototype._setLabelField.call(this, value);
            this._labelChanged = true;
            this.invalidateProperties();
        };

        /**
        * @inheritDoc
        */
        DropDownListBase.prototype._setLabelFunction = function (value) {
            if (this.labelFunction == value)
                return;

            _super.prototype._setLabelFunction.call(this, value);
            this._labelChanged = true;
            this.invalidateProperties();
        };

        Object.defineProperty(DropDownListBase.prototype, "dropDownController", {
            /**
            * 下拉控制器
            * @member egret.DropDownListBase#dropDownController
            */
            get: function () {
                return this._dropDownController;
            },
            set: function (value) {
                if (this._dropDownController == value)
                    return;

                this._dropDownController = value;

                this._dropDownController.addEventListener(egret.UIEvent.OPEN, this._dropDownController_openHandler, this);
                this._dropDownController.addEventListener(egret.UIEvent.CLOSE, this.dropDownController_closeHandler, this);

                if (this.openButton)
                    this._dropDownController.openButton = this.openButton;
                if (this.dropDown)
                    this._dropDownController.dropDown = this.dropDown;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(DropDownListBase.prototype, "isDropDownOpen", {
            /**
            * 下拉列表是否已经已打开
            * @member egret.DropDownListBase#isDropDownOpen
            */
            get: function () {
                if (this.dropDownController)
                    return this.dropDownController.isOpen;
                else
                    return false;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.DropDownListBase#commitProperties
        */
        DropDownListBase.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);

            if (this._labelChanged) {
                this._labelChanged = false;
                this.updateLabelDisplay();
            }
        };

        /**
        * @method egret.DropDownListBase#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        DropDownListBase.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.openButton) {
                if (this.dropDownController)
                    this.dropDownController.openButton = this.openButton;
            } else if (instance == this.dropDown && this.dropDownController) {
                this.dropDownController.dropDown = this.dropDown;
            }
        };

        /**
        * @method egret.DropDownListBase#partRemoved
        * @param partName {string}
        * @param instance {any}
        */
        DropDownListBase.prototype.partRemoved = function (partName, instance) {
            if (this.dropDownController) {
                if (instance == this.openButton)
                    this.dropDownController.openButton = null;

                if (instance == this.dropDown)
                    this.dropDownController.dropDown = null;
            }

            _super.prototype.partRemoved.call(this, partName, instance);
        };

        /**
        * @method egret.DropDownListBase#getCurrentSkinState
        * @returns {string}
        */
        DropDownListBase.prototype.getCurrentSkinState = function () {
            return !this.enabled ? "disabled" : this.isDropDownOpen ? "open" : "normal";
        };

        /**
        * @method egret.DropDownListBase#commitSelection
        * @param dispatchChangedEvents {boolean}
        * @returns {boolean}
        */
        DropDownListBase.prototype.commitSelection = function (dispatchChangedEvents) {
            if (typeof dispatchChangedEvents === "undefined") { dispatchChangedEvents = true; }
            var retVal = _super.prototype.commitSelection.call(this, dispatchChangedEvents);
            this.updateLabelDisplay();
            return retVal;
        };

        /**
        * @method egret.DropDownListBase#_isItemIndexSelected
        * @param index {number}
        * @returns {boolean}
        */
        DropDownListBase.prototype._isItemIndexSelected = function (index) {
            return this._userProposedSelectedIndex == index;
        };

        /**
        * 打开下拉列表并抛出UIEvent.OPEN事件。
        * @method egret.DropDownListBase#openDropDown
        */
        DropDownListBase.prototype.openDropDown = function () {
            this.dropDownController.openDropDown();
        };

        /**
        * 关闭下拉列表并抛出UIEvent.CLOSE事件。
        * @method egret.DropDownListBase#closeDropDown
        * @param commit {boolean}
        */
        DropDownListBase.prototype.closeDropDown = function (commit) {
            this.dropDownController.closeDropDown(commit);
        };

        /**
        * 更新选中项的提示文本
        * @method egret.DropDownListBase#updateLabelDisplay
        * @param displayItem {any}
        */
        DropDownListBase.prototype.updateLabelDisplay = function (displayItem) {
            if (typeof displayItem === "undefined") { displayItem = undefined; }
        };

        /**
        * 改变高亮的选中项
        * @method egret.DropDownListBase#_changeHighlightedSelection
        * @param newIndex {number}
        * @param scrollToTop {boolean}
        */
        DropDownListBase.prototype._changeHighlightedSelection = function (newIndex, scrollToTop) {
            if (typeof scrollToTop === "undefined") { scrollToTop = false; }
            this.itemSelected(this._userProposedSelectedIndex, false);
            this._userProposedSelectedIndex = newIndex;
            this.itemSelected(this._userProposedSelectedIndex, true);
        };

        /**
        * @method egret.DropDownListBase#dataProvider_collectionChangeHandler
        * @param event {CollectionEvent}
        */
        DropDownListBase.prototype.dataProvider_collectionChangeHandler = function (event) {
            _super.prototype.dataProvider_collectionChangeHandler.call(this, event);

            this._labelChanged = true;
            this.invalidateProperties();
        };

        /**
        * @method egret.DropDownListBase#item_mouseDownHandler
        * @param event {TouchEvent}
        */
        DropDownListBase.prototype.item_mouseDownHandler = function (event) {
            _super.prototype.item_mouseDownHandler.call(this, event);

            var itemRenderer = (event.currentTarget);
            this._dispatchListEvent(event, egret.ListEvent.ITEM_CLICK, itemRenderer);

            this._userProposedSelectedIndex = this.selectedIndex;
            this.closeDropDown(true);
        };

        /**
        * 控制器抛出打开列表事件
        * @method egret.DropDownListBase#_dropDownController_openHandler
        * @param event {UIEvent}
        */
        DropDownListBase.prototype._dropDownController_openHandler = function (event) {
            this.addEventListener(egret.UIEvent.UPDATE_COMPLETE, this._open_updateCompleteHandler, this);
            this._userProposedSelectedIndex = this.selectedIndex;
            this.invalidateSkinState();
        };

        /**
        * 打开列表后组件一次失效验证全部完成
        * @method egret.DropDownListBase#_open_updateCompleteHandler
        * @param event {UIEvent}
        */
        DropDownListBase.prototype._open_updateCompleteHandler = function (event) {
            this.removeEventListener(egret.UIEvent.UPDATE_COMPLETE, this._open_updateCompleteHandler, this);
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.OPEN);
        };

        /**
        * 控制器抛出关闭列表事件
        * @method egret.DropDownListBase#dropDownController_closeHandler
        * @param event {UIEvent}
        */
        DropDownListBase.prototype.dropDownController_closeHandler = function (event) {
            this.addEventListener(egret.UIEvent.UPDATE_COMPLETE, this.close_updateCompleteHandler, this);
            this.invalidateSkinState();

            if (!event.isDefaultPrevented()) {
                this._setSelectedIndex(this._userProposedSelectedIndex, true);
            } else {
                this._changeHighlightedSelection(this.selectedIndex);
            }
        };

        /**
        * 关闭列表后组件一次失效验证全部完成
        */
        DropDownListBase.prototype.close_updateCompleteHandler = function (event) {
            this.removeEventListener(egret.UIEvent.UPDATE_COMPLETE, this.close_updateCompleteHandler, this);
            egret.UIEvent.dispatchUIEvent(this, egret.UIEvent.CLOSE);
        };
        DropDownListBase.PAGE_SIZE = 5;
        return DropDownListBase;
    })(egret.List);
    egret.DropDownListBase = DropDownListBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Tree
    * @classdesc
    * 树状列表组件
    * @extends egret.List
    */
    var Tree = (function (_super) {
        __extends(Tree, _super);
        /**
        * 构造函数
        * @method egret.Tree#constructor
        */
        function Tree() {
            _super.call(this);
            /**
            * 图标字段或函数改变标志
            */
            this.iconFieldOrFunctionChanged = false;
            this.hostComponentKey = "egret.Tree";
        }
        /**
        * @method egret.Tree#createChildren
        */
        Tree.prototype.createChildren = function () {
            if (!this.itemRenderer)
                this.itemRenderer = Tree.defaultTreeRendererFactory;
            _super.prototype.createChildren.call(this);
        };

        /**
        * @method egret.Tree#updateRenderer
        * @param renderer {IItemRenderer}
        * @param itemIndex {number}
        * @param data {any}
        * @returns {IItemRenderer}
        */
        Tree.prototype.updateRenderer = function (renderer, itemIndex, data) {
            if ("hasChildren" in renderer && "hasChildren" in this.dataProvider) {
                var treeCollection = (this.dataProvider);
                var treeRenderer = renderer;
                treeRenderer.hasChildren = treeCollection.hasChildren(data);
                treeRenderer.opened = treeCollection.isItemOpen(data);
                treeRenderer.depth = treeCollection.getDepth(data);
                treeRenderer.iconSkinName = this.itemToIcon(data);
            }
            return _super.prototype.updateRenderer.call(this, renderer, itemIndex, data);
        };

        /**
        * 根据数据项返回项呈示器中图标的skinName属性值
        * @method egret.Tree#itemToIcon
        * @param data {any}
        * @returns {any}
        */
        Tree.prototype.itemToIcon = function (data) {
            if (!data)
                return null;

            if (this._iconFunction != null)
                return this._iconFunction(data);

            var skinName;
            if (data instanceof Object) {
                try  {
                    if (data[this.iconField]) {
                        skinName = data[this.iconField];
                    }
                } catch (e) {
                }
            }
            return skinName;
        };

        /**
        * @method egret.Tree#dataGroup_rendererAddHandler
        * @param event {RendererExistenceEvent}
        */
        Tree.prototype.dataGroup_rendererAddHandler = function (event) {
            _super.prototype.dataGroup_rendererAddHandler.call(this, event);
            if (event.renderer && "hasChildren" in event.renderer)
                event.renderer.addEventListener(egret.TreeEvent.ITEM_OPENING, this.onItemOpening, this);
        };

        /**
        * 节点即将打开
        */
        Tree.prototype.onItemOpening = function (event) {
            var renderer = event.itemRenderer;
            var item = event.item;
            var dp = this._getDataProvider();
            if (!renderer || !dp || !("hasChildren" in dp))
                return;
            if (this.dispatchEvent(event)) {
                var opend = !renderer.opened;
                dp.expandItem(item, opend);
                var type = opend ? egret.TreeEvent.ITEM_OPEN : egret.TreeEvent.ITEM_CLOSE;
                egret.TreeEvent.dispatchTreeEvent(this, type, renderer.itemIndex, item, renderer);
            }
        };

        /**
        * @method egret.Tree#dataGroup_rendererRemoveHandler
        * @param event {RendererExistenceEvent}
        */
        Tree.prototype.dataGroup_rendererRemoveHandler = function (event) {
            _super.prototype.dataGroup_rendererRemoveHandler.call(this, event);
            if (event.renderer && "hasChildren" in event.renderer)
                event.renderer.removeEventListener(egret.TreeEvent.ITEM_OPENING, this.onItemOpening, this);
        };

        Object.defineProperty(Tree.prototype, "iconField", {
            /**
            * 数据项中用来确定图标skinName属性值的字段名称。另请参考UIAsset.skinName。
            * 若设置了iconFunction，则设置此属性无效。
            * @member egret.Tree#iconField
            */
            get: function () {
                return this._iconField;
            },
            set: function (value) {
                if (this._iconField == value)
                    return;
                this._iconField = value;
                this.iconFieldOrFunctionChanged = true;
                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Tree.prototype, "iconFunction", {
            /**
            * 用户提供的函数，在每个数据项目上运行以确定其图标的skinName值。另请参考UIAsset.skinName。
            * 示例：iconFunction(item:Object):Object
            * @member egret.Tree#iconFunction
            */
            get: function () {
                return this._iconFunction;
            },
            set: function (value) {
                if (this._iconFunction == value)
                    return;
                this._iconFunction = value;
                this.iconFieldOrFunctionChanged = true;
                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 打开或关闭一个节点,注意，此操作不会抛出open或close事件。
        * @method egret.Tree#expandItem
        * @param item {any} 要打开或关闭的节点
        * @param open {boolean} true表示打开节点，反之关闭。
        */
        Tree.prototype.expandItem = function (item, open) {
            if (typeof open === "undefined") { open = true; }
            var dp = this._getDataProvider();
            if (!dp || !("hasChildren" in dp))
                return;
            (dp).expandItem(item, open);
        };

        /**
        * 指定的节点是否打开
        * @method egret.Tree#isItemOpen
        * @param item {any}
        * @returns {boolean}
        */
        Tree.prototype.isItemOpen = function (item) {
            var dp = this._getDataProvider();
            if (!dp || !("hasChildren" in dp))
                return false;
            return (dp).isItemOpen(item);
        };

        /**
        * @method egret.Tree#dataProvider_collectionChangeHandler
        * @param event {CollectionEvent}
        */
        Tree.prototype.dataProvider_collectionChangeHandler = function (event) {
            _super.prototype.dataProvider_collectionChangeHandler.call(this, event);
            if (event.kind == egret.CollectionEventKind.OPEN || event.kind == egret.CollectionEventKind.CLOSE) {
                var renderer = this.dataGroup ? (this.dataGroup.getElementAt(event.location)) : null;
                if (renderer) {
                    this.updateRenderer(renderer, event.location, event.items[0]);
                    if (event.kind == egret.CollectionEventKind.CLOSE && this.layout && this.layout.useVirtualLayout) {
                        this.layout.clearVirtualLayoutCache();
                        this.invalidateSize();
                    }
                }
            }
        };

        /**
        * @method egret.Tree#commitProperties
        */
        Tree.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);
            if (this.iconFieldOrFunctionChanged) {
                if (this.dataGroup != null) {
                    var itemIndex;
                    if (this.layout && this.layout.useVirtualLayout) {
                        var list = this.dataGroup.getElementIndicesInView();
                        var length = list.length;
                        for (var i = 0; i < length; i++) {
                            var itemIndex = list[i];
                            this.updateRendererIconProperty(itemIndex);
                        }
                    } else {
                        var n = this.dataGroup.numElements;
                        for (itemIndex = 0; itemIndex < n; itemIndex++) {
                            this.updateRendererIconProperty(itemIndex);
                        }
                    }
                }
                this.iconFieldOrFunctionChanged = false;
            }
        };

        /**
        * 更新指定索引项的图标
        */
        Tree.prototype.updateRendererIconProperty = function (itemIndex) {
            var renderer = (this.dataGroup.getElementAt(itemIndex));
            if (renderer)
                renderer.iconSkinName = this.itemToIcon(renderer.data);
        };
        Tree.defaultTreeRendererFactory = new egret.ClassFactory(egret.TreeItemRenderer);
        return Tree;
    })(egret.List);
    egret.Tree = Tree;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.DropDownList
    * @classdesc
    * 不可输入的下拉列表控件。带输入功能的下拉列表控件，请使用ComboBox。
    * @see org.flexlite.domUI.components.ComboBox
    * @extends egret.DropDownListBase
    */
    var DropDownList = (function (_super) {
        __extends(DropDownList, _super);
        /**
        * 构造函数
        * @method egret.DropDownList#constructor
        */
        function DropDownList() {
            _super.call(this);
            this._prompt = "";
            this.hostComponentKey = "egret.DropDownList";
        }
        Object.defineProperty(DropDownList.prototype, "prompt", {
            /**
            * 当没有选中项时在DropDownList上要显示的字符串。<p/>
            * 它通常是一个类似于“请选择一项...”的文本。当下拉列表中的某个项目被选中后，会被替换为该选定项目中的文本。
            * @member egret.DropDownList#prompt
            */
            get: function () {
                return this._prompt;
            },
            set: function (value) {
                if (this._prompt == value)
                    return;

                this._prompt = value;
                this._labelChanged = true;
                this.invalidateProperties();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.DropDownList#partAdded
        * @param partName {string}
        * @param instance {any}
        */
        DropDownList.prototype.partAdded = function (partName, instance) {
            _super.prototype.partAdded.call(this, partName, instance);

            if (instance == this.labelDisplay) {
                this._labelChanged = true;
                this.invalidateProperties();
            }
        };

        /**
        * @method egret.DropDownList#updateLabelDisplay
        * @param displayItem {any}
        */
        DropDownList.prototype.updateLabelDisplay = function (displayItem) {
            if (typeof displayItem === "undefined") { displayItem = undefined; }
            if (this.labelDisplay) {
                if (displayItem == undefined)
                    displayItem = this.selectedItem;
                if (displayItem != null && displayItem != undefined)
                    this.labelDisplay.text = this.itemToLabel(displayItem);
                else
                    this.labelDisplay.text = this._prompt;
            }
        };
        return DropDownList;
    })(egret.DropDownListBase);
    egret.DropDownList = DropDownList;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TabBarButton
    * @classdesc
    * 选项卡组件的按钮条目
    * @extends egret.ToggleButtonBase
    * @implements egret.IItemRenderer
    */
    var TabBarButton = (function (_super) {
        __extends(TabBarButton, _super);
        /**
        * @method egret.TabBarButton#constructor
        */
        function TabBarButton() {
            _super.call(this);
            this._allowDeselection = true;
            this.hostComponentKey = "egret.TabBarButton";
        }
        Object.defineProperty(TabBarButton.prototype, "allowDeselection", {
            /**
            * 如果为 true，用户单击当前选定的按钮时即会将其取消选择。
            * 如果为 false，用户必须选择不同的按钮才可取消选择当前选定的按钮。
            * @member egret.TabBarButton#allowDeselection
            */
            get: function () {
                return this._allowDeselection;
            },
            set: function (value) {
                this._allowDeselection = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TabBarButton.prototype, "data", {
            /**
            * @member egret.TabBarButton#data
            */
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value;
                this.dispatchEventWith("dataChange");
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TabBarButton.prototype, "itemIndex", {
            /**
            * @member egret.TabBarButton#itemIndex
            */
            get: function () {
                return this._itemIndex;
            },
            set: function (value) {
                this._itemIndex = value;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @inheritDoc
        */
        TabBarButton.prototype._setLabel = function (value) {
            if (value != this._getLabel()) {
                _super.prototype._setLabel.call(this, value);

                if (this.labelDisplay)
                    this.labelDisplay.text = this._getLabel();
            }
        };

        /**
        * @method egret.TabBarButton#buttonReleased
        */
        TabBarButton.prototype.buttonReleased = function () {
            if (this.selected && !this.allowDeselection)
                return;

            _super.prototype.buttonReleased.call(this);
        };
        return TabBarButton;
    })(egret.ToggleButtonBase);
    egret.TabBarButton = TabBarButton;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TabBar
    * @classdesc
    * 选项卡组件
    * @extends egret.ListBase
    */
    var TabBar = (function (_super) {
        __extends(TabBar, _super);
        /**
        * 构造函数
        * @method egret.TabBar#constructor
        */
        function TabBar() {
            _super.call(this);
            this.hostComponentKey = "egret.TabBar";
            this.requireSelection = true;
        }
        /**
        * @method egret.TabBar#c
        * @param value {boolea}
        */
        TabBar.prototype.c = function (value) {
            if (value == this._requireSelection)
                return;

            _super.prototype._setRequireSelection.call(this, value);
            this.requireSelectionChanged_tabBar = true;
            this.invalidateProperties();
        };

        /**
        * @inheritDoc
        */
        TabBar.prototype._setDataProvider = function (value) {
            if (this.dataProvider instanceof egret.ViewStack) {
                this.dataProvider.removeEventListener("IndexChanged", this.onViewStackIndexChange, this);
                this.removeEventListener(egret.IndexChangeEvent.CHANGE, this.onIndexChanged, this);
            }

            if (value instanceof egret.ViewStack) {
                value.addEventListener("IndexChanged", this.onViewStackIndexChange, this);
                this.addEventListener(egret.IndexChangeEvent.CHANGE, this.onIndexChanged, this);
            }
            _super.prototype._setDataProvider.call(this, value);
        };

        /**
        * 鼠标点击的选中项改变
        */
        TabBar.prototype.onIndexChanged = function (event) {
            (this.dataProvider)._setSelectedIndex(event.newIndex, false);
        };

        /**
        * ViewStack选中项发生改变
        */
        TabBar.prototype.onViewStackIndexChange = function (event) {
            this._setSelectedIndex((this.dataProvider).selectedIndex, false);
        };

        /**
        * @method egret.TabBar#commitProperties
        */
        TabBar.prototype.commitProperties = function () {
            _super.prototype.commitProperties.call(this);

            if (this.requireSelectionChanged_tabBar && this.dataGroup) {
                this.requireSelectionChanged_tabBar = false;
                var n = this.dataGroup.numElements;
                for (var i = 0; i < n; i++) {
                    var renderer = (this.dataGroup.getElementAt(i));
                    if (renderer)
                        renderer.allowDeselection = !this.requireSelection;
                }
            }
        };

        /**
        * @method egret.TabBar#dataGroup_rendererAddHandler
        * @param event {RendererExistenceEvent}
        */
        TabBar.prototype.dataGroup_rendererAddHandler = function (event) {
            _super.prototype.dataGroup_rendererAddHandler.call(this, event);

            var renderer = event.renderer;
            if (renderer) {
                renderer.addEventListener(egret.TouchEvent.TOUCH_TAP, this.item_clickHandler, this);
                if (renderer instanceof egret.TabBarButton)
                    renderer.allowDeselection = !this.requireSelection;
            }
        };

        /**
        * @method egret.TabBar#dataGroup_rendererRemoveHandler
        * @param event {RendererExistenceEvent}
        */
        TabBar.prototype.dataGroup_rendererRemoveHandler = function (event) {
            _super.prototype.dataGroup_rendererRemoveHandler.call(this, event);

            var renderer = event.renderer;
            if (renderer)
                renderer.removeEventListener(egret.TouchEvent.TOUCH_TAP, this.item_clickHandler, this);
        };

        /**
        * 鼠标在条目上按下
        */
        TabBar.prototype.item_clickHandler = function (event) {
            var itemRenderer = (event.currentTarget);
            var newIndex;
            if (itemRenderer)
                newIndex = itemRenderer.itemIndex;
            else
                newIndex = this.dataGroup.getElementIndex((event.currentTarget));

            if (newIndex == this.selectedIndex) {
                if (!this.requireSelection)
                    this._setSelectedIndex(egret.ListBase.NO_SELECTION, true);
            } else
                this._setSelectedIndex(newIndex, true);
            this._dispatchListEvent(event, egret.ListEvent.ITEM_CLICK, itemRenderer);
        };
        return TabBar;
    })(egret.ListBase);
    egret.TabBar = TabBar;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.Scroller
    * @classdesc
    * 滚动条组件
    * @extends egret.UIComponent
    * @implements egret.IVisualElementContainer
    */
    var Scroller = (function (_super) {
        __extends(Scroller, _super);
        /**
        * 构造函数
        * @method egret.Scroller#constructor
        */
        function Scroller() {
            _super.call(this);
            this._verticalScrollPolicy = "auto";
            this._horizontalScrollPolicy = "auto";
            this.ignoreTouchBegin = false;
            this._velocityX = 0;
            this._velocityY = 0;
            this._previousVelocityX = [];
            this._previousVelocityY = [];
        }
        /**
        * @method egret.Scroller#measure
        */
        Scroller.prototype.measure = function () {
            if (!this._viewport)
                return;
            this.measuredWidth = this._viewport.preferredWidth;
            this.measuredHeight = this._viewport.preferredHeight;
        };

        /**
        * @method egret.Scroller#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        Scroller.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            this._viewport.setLayoutBoundsSize(unscaledWidth, unscaledHeight);
        };

        Object.defineProperty(Scroller.prototype, "verticalScrollPolicy", {
            /**
            * 垂直滚动条显示策略，参见ScrollPolicy类定义的常量。
            * @member egret.Scroller#verticalScrollPolicy
            */
            get: function () {
                return this._verticalScrollPolicy;
            },
            set: function (value) {
                this._verticalScrollPolicy = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Scroller.prototype, "horizontalScrollPolicy", {
            /**
            * 水平滚动条显示策略，参见ScrollPolicy类定义的常量。
            * @member egret.Scroller#horizontalScrollPolicy
            */
            get: function () {
                return this._horizontalScrollPolicy;
            },
            set: function (value) {
                this._horizontalScrollPolicy = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Scroller.prototype, "viewport", {
            /**
            * 要滚动的视域组件。
            * @member egret.Scroller#viewport
            */
            get: function () {
                return this._viewport;
            },
            set: function (value) {
                if (value == this._viewport)
                    return;

                this.uninstallViewport();
                this._viewport = value;
                this.installViewport();
                this.dispatchEventWith("viewportChanged");
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 安装并初始化视域组件
        */
        Scroller.prototype.installViewport = function () {
            if (this.viewport) {
                this.viewport.clipAndEnableScrolling = true;
                this.viewport.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onTouchBegin, this);
                this.viewport.addEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onTouchBeginCapture, this, true);
                this.viewport.addEventListener(egret.TouchEvent.TOUCH_END, this.onTouchEndCapture, this, true);
                this._addToDisplayListAt(this.viewport, 0);
            }
        };

        /**
        * 卸载视域组件
        */
        Scroller.prototype.uninstallViewport = function () {
            if (this.viewport) {
                this.viewport.clipAndEnableScrolling = false;
                this.viewport.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onTouchBegin, this);
                this.viewport.removeEventListener(egret.TouchEvent.TOUCH_BEGIN, this.onTouchBeginCapture, this, true);
                this.viewport.removeEventListener(egret.TouchEvent.TOUCH_END, this.onTouchEndCapture, this, true);
                this._removeFromDisplayList(this.viewport);
            }
        };

        Scroller.prototype.onTouchEndCapture = function (event) {
            if (!this.delayTouchBeginEvent) {
                return;
            }
            event.stopPropagation();
            var evt = this.cloneTouchEvent(event);
            this.delayTouchEndEvent = evt;
            this.onTouchBeginTimer();
            if (!this.touchEndTimer) {
                this.touchEndTimer = new egret.Timer(100, 1);
                this.touchEndTimer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, this.onTouchEndTimer, this);
            }
            this.touchEndTimer.start();
        };

        Scroller.prototype.onTouchEndTimer = function (e) {
            this.touchEndTimer.stop();
            var event = this.delayTouchEndEvent;
            this.delayTouchEndEvent = null;
            this.dispatchPropagationEvent(event);
        };

        Scroller.prototype.dispatchPropagationEvent = function (event) {
            var list = [];

            var target = event._target;
            while (target) {
                list.push(target);
                target = target.parent;
            }

            var viewport = this._viewport;
            for (var i = 1; ; i += 2) {
                target = list[i];
                if (!target || target === viewport) {
                    break;
                }
                list.unshift(target);
            }
            var targetIndex = list.indexOf(event._target);
            this._dispatchPropagationEvent(event, list, targetIndex);
        };

        /**
        * 若这个Scroller可以滚动，阻止当前事件，延迟100ms再抛出。
        */
        Scroller.prototype.onTouchBeginCapture = function (event) {
            var canScroll = this.checkScrollPolicy();
            if (!canScroll) {
                return;
            }

            var target = event.target;
            while (target != this) {
                if (target instanceof Scroller) {
                    canScroll = target.checkScrollPolicy();
                    if (canScroll) {
                        return;
                    }
                }
                target = target.parent;
            }
            if (this.delayTouchEndEvent) {
                this.delayTouchEndEvent = null;
                this.touchEndTimer.stop();
            }
            event.stopPropagation();
            var evt = this.cloneTouchEvent(event);
            this.delayTouchBeginEvent = evt;
            if (!this.touchBeginTimer) {
                this.touchBeginTimer = new egret.Timer(100, 1);
                this.touchBeginTimer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, this.onTouchBeginTimer, this);
            }
            this.touchBeginTimer.start();
            this.onTouchBegin(event);
        };

        Scroller.prototype.cloneTouchEvent = function (event) {
            var evt = new egret.TouchEvent(event._type, event._bubbles, event.cancelable);
            evt.touchPointID = event.touchPointID;
            evt._stageX = event._stageX;
            evt._stageY = event._stageY;
            evt.ctrlKey = event.ctrlKey;
            evt.altKey = event.altKey;
            evt.shiftKey = event.shiftKey;
            evt.touchDown = event.touchDown;
            evt._isDefaultPrevented = false;
            evt._target = event._target;
            return evt;
        };

        Scroller.prototype.onTouchBeginTimer = function (e) {
            this.touchBeginTimer.stop();
            var event = this.delayTouchBeginEvent;
            this.delayTouchBeginEvent = null;
            this.dispatchPropagationEvent(event);
        };

        /**
        * 检查当前滚动策略，若有一个方向可以滚动，返回true。
        */
        Scroller.prototype.checkScrollPolicy = function () {
            var viewport = this._viewport;
            var hCanScroll;
            switch (this._horizontalScrollPolicy) {
                case "auto":
                    if (viewport.contentWidth > viewport.width) {
                        hCanScroll = true;
                    } else {
                        hCanScroll = false;
                    }
                    break;
                case "on":
                    hCanScroll = true;
                    break;
                case "off":
                    hCanScroll = false;
                    break;
            }
            this._horizontalCanScroll = hCanScroll;

            var vCanScroll;
            switch (this._verticalScrollPolicy) {
                case "auto":
                    if (viewport.contentHeight > viewport.height) {
                        vCanScroll = true;
                    } else {
                        vCanScroll = false;
                    }
                    break;
                case "on":
                    vCanScroll = true;
                    break;
                case "off":
                    vCanScroll = false;
                    break;
            }
            this._verticalCanScroll = vCanScroll;
            return hCanScroll || vCanScroll;
        };

        Scroller.prototype.onTouchBegin = function (event) {
            if (event.isDefaultPrevented()) {
                return;
            }
            var canScroll = this.checkScrollPolicy();
            if (!canScroll) {
                return;
            }
            if (this.verticalAnimator && this.verticalAnimator.isPlaying)
                this.verticalAnimator.stop();
            if (this.horizontalAnimator && this.horizontalAnimator.isPlaying)
                this.horizontalAnimator.stop();
            var viewport = this._viewport;
            var hsp = viewport.horizontalScrollPosition;
            var vsp = viewport.verticalScrollPosition;
            this._offsetPointX = hsp + event.stageX;
            this._offsetPointY = vsp + event.stageY;

            this._velocityX = 0;
            this._velocityY = 0;
            this._previousVelocityX.length = 0;
            this._previousVelocityY.length = 0;
            this._previousTouchTime = egret.getTimer();
            this._previousTouchX = this._startTouchX = this._currentTouchX = event.stageX;
            this._previousTouchY = this._startTouchY = this._currentTouchY = event.stageY;
            this._startHorizontalScrollPosition = hsp;
            this._startVerticalScrollPosition = vsp;

            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE, this.onTouchMove, this);
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END, this.onTouchEnd, this);
            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE, this.onTouchEnd, this);
            this.addEventListener(egret.Event.ENTER_FRAME, this.enterFrameHandler, this);
            event.preventDefault();
        };

        Scroller.prototype.onTouchMove = function (event) {
            this._currentTouchX = event.stageX;
            this._currentTouchY = event.stageY;
            if (this.delayTouchBeginEvent) {
                this.delayTouchBeginEvent = null;
                this.touchBeginTimer.stop();
            }
            var viewport = this._viewport;
            if (this._horizontalCanScroll) {
                var hsp = this._offsetPointX - event.stageX;
                if (hsp < 0) {
                    hsp *= 0.5;
                }
                if (hsp > viewport.contentWidth - viewport.width) {
                    hsp = (hsp + viewport.contentWidth - viewport.width) * 0.5;
                }
                viewport.horizontalScrollPosition = hsp;
            }

            if (this._verticalCanScroll) {
                var vsp = this._offsetPointY - event.stageY;
                if (vsp < 0) {
                    vsp *= 0.5;
                }
                if (vsp > viewport.contentHeight - viewport.height) {
                    vsp = (vsp + viewport.contentHeight - viewport.height) * 0.5;
                }
                viewport.verticalScrollPosition = vsp;
            }
        };

        Scroller.prototype.onTouchEnd = function (event) {
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE, this.onTouchMove, this);
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END, this.onTouchEnd, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.LEAVE_STAGE, this.onTouchEnd, this);
            this.removeEventListener(egret.Event.ENTER_FRAME, this.enterFrameHandler, this);

            if (this._horizontalCanScroll) {
                this.checkHorizontalScrollPosition();
            }
            if (this._verticalCanScroll) {
                this.checkVerticalScrollPosition();
            }
        };

        Scroller.easeOut = function (ratio) {
            var invRatio = ratio - 1.0;
            return invRatio * invRatio * invRatio + 1;
        };

        Scroller.prototype.enterFrameHandler = function (event) {
            var now = egret.getTimer();
            var maxVelocityCount = 4;
            var timeOffset = now - this._previousTouchTime;
            if (timeOffset > 0) {
                this._previousVelocityX[this._previousVelocityX.length] = this._velocityX;
                if (this._previousVelocityX.length > maxVelocityCount) {
                    this._previousVelocityX.shift();
                }
                this._previousVelocityY[this._previousVelocityY.length] = this._velocityY;
                if (this._previousVelocityY.length > maxVelocityCount) {
                    this._previousVelocityY.shift();
                }
                this._velocityX = (this._currentTouchX - this._previousTouchX) / timeOffset;
                this._velocityY = (this._currentTouchY - this._previousTouchY) / timeOffset;
                this._previousTouchTime = now;
                this._previousTouchX = this._currentTouchX;
                this._previousTouchY = this._currentTouchY;
            }
            var horizontalInchesMoved = Math.abs(this._currentTouchX - this._startTouchX);
            var verticalInchesMoved = Math.abs(this._currentTouchY - this._startTouchY);
            var minimumDragDistance = 0.04;
            if (this._horizontalCanScroll && horizontalInchesMoved >= minimumDragDistance) {
                this._startTouchX = this._currentTouchX;
                this._startHorizontalScrollPosition = this._viewport.horizontalScrollPosition;
            }
            if (this._verticalCanScroll && verticalInchesMoved >= minimumDragDistance) {
                this._startTouchY = this._currentTouchY;
                this._startVerticalScrollPosition = this._viewport.verticalScrollPosition;
            }
        };

        Scroller.prototype.checkHorizontalScrollPosition = function () {
            var viewport = this._viewport;
            var hsp = viewport.horizontalScrollPosition;
            var maxHsp = viewport.contentWidth - viewport.width;
            maxHsp = Math.max(0, maxHsp);

            var sum = this._velocityX * 2.33;
            var velocityCount = this._previousVelocityX.length;
            var totalWeight = 2.33;
            for (var i = 0; i < velocityCount; i++) {
                var weight = Scroller.VELOCITY_WEIGHTS[i];
                sum += this._previousVelocityX.shift() * weight;
                totalWeight += weight;
            }

            var pixelsPerMS = sum / totalWeight;
            var absPixelsPerMS = Math.abs(pixelsPerMS);
            if (absPixelsPerMS <= 0.02) {
                this.finishScrollingHorizontally();
            } else {
                var result = this.getAnimationDatas(pixelsPerMS, hsp, maxHsp);
                this.throwHorizontally(result[0], result[1]);
            }
        };

        Scroller.prototype.checkVerticalScrollPosition = function () {
            var viewport = this._viewport;
            var vsp = viewport.verticalScrollPosition;
            var maxVsp = viewport.contentHeight - viewport.height;

            var sum = this._velocityY * 2.33;
            var velocityCount = this._previousVelocityY.length;
            var totalWeight = 2.33;
            for (var i = 0; i < velocityCount; i++) {
                var weight = Scroller.VELOCITY_WEIGHTS[i];
                sum += this._previousVelocityY.shift() * weight;
                totalWeight += weight;
            }

            var pixelsPerMS = sum / totalWeight;
            var absPixelsPerMS = Math.abs(pixelsPerMS);
            if (absPixelsPerMS <= 0.02) {
                this.finishScrollingVertically();
            } else {
                var result = this.getAnimationDatas(pixelsPerMS, vsp, maxVsp);
                this.throwVertically(result[0], result[1]);
            }
        };

        Scroller.prototype.getAnimationDatas = function (pixelsPerMS, curPos, maxPos) {
            var absPixelsPerMS = Math.abs(pixelsPerMS);
            var extraFricition = 0.95;
            var duration = 0;
            var friction = 0.998;
            var minVelocity = 0.02;
            var posTo = curPos + (pixelsPerMS - minVelocity) / Math.log(friction);
            if (posTo < 0 || posTo > maxPos) {
                posTo = curPos;
                while (Math.abs(pixelsPerMS) > minVelocity) {
                    posTo -= pixelsPerMS;
                    if (posTo < 0 || posTo > maxPos) {
                        pixelsPerMS *= friction * extraFricition;
                    } else {
                        pixelsPerMS *= friction;
                    }
                    duration++;
                }
            } else {
                duration = Math.log(minVelocity / absPixelsPerMS) / Math.log(friction);
            }
            if (!Scroller.animationData) {
                Scroller.animationData = [0, 0];
            }
            var result = Scroller.animationData;
            result[0] = posTo;
            result[1] = duration;
            return result;
        };

        Scroller.prototype.finishScrollingHorizontally = function (animation) {
            var viewport = this._viewport;
            var hsp = viewport.horizontalScrollPosition;
            var maxHsp = viewport.contentWidth - viewport.width;
            var hspTo = hsp;
            if (hsp < 0) {
                hspTo = 0;
            }
            if (hsp > maxHsp) {
                hspTo = maxHsp;
            }
            this.throwHorizontally(hspTo, 300);
        };

        /**
        * 缓动到水平滚动位置
        * @method egret.Scroller#throwHorizontally
        * @param hspTo {number}
        * @param duration {number}
        */
        Scroller.prototype.throwHorizontally = function (hspTo, duration) {
            if (typeof duration === "undefined") { duration = 500; }
            var hsp = this._viewport.horizontalScrollPosition;
            if (hsp == hspTo) {
                return;
            }
            if (!this.horizontalAnimator) {
                this.horizontalAnimator = new egret.Animation(this.horizontalUpdateHandler, this);
                this.horizontalAnimator.endFunction = this.finishScrollingHorizontally;
                this.horizontalAnimator.easerFunction = Scroller.easeOut;
            }
            if (this.horizontalAnimator.isPlaying)
                this.horizontalAnimator.stop();
            this.horizontalAnimator.duration = duration;
            this.horizontalAnimator.motionPaths = [{ prop: "hsp", from: hsp, to: hspTo }];
            this.horizontalAnimator.play();
        };

        /**
        * 更新水平滚动位置
        */
        Scroller.prototype.horizontalUpdateHandler = function (animation) {
            this._viewport.horizontalScrollPosition = animation.currentValue["hsp"];
        };

        Scroller.prototype.finishScrollingVertically = function (animation) {
            var viewport = this._viewport;
            var vsp = viewport.verticalScrollPosition;
            var maxVsp = viewport.contentHeight - viewport.height;
            maxVsp = Math.max(0, maxVsp);
            var vspTo = vsp;
            if (vsp < 0) {
                vspTo = 0;
            }
            if (vsp > maxVsp) {
                vspTo = maxVsp;
            }
            this.throwVertically(vspTo, 300);
        };

        /**
        * 缓动到垂直滚动位置
        * @method egret.Scroller#throwVertically
        * @param vspTo {number}
        * @param duration {number}
        */
        Scroller.prototype.throwVertically = function (vspTo, duration) {
            if (typeof duration === "undefined") { duration = 500; }
            var vsp = this._viewport.verticalScrollPosition;
            if (vsp == vspTo) {
                return;
            }
            if (!this.verticalAnimator) {
                this.verticalAnimator = new egret.Animation(this.verticalUpdateHandler, this);
                this.verticalAnimator.endFunction = this.finishScrollingVertically;
                this.verticalAnimator.easerFunction = Scroller.easeOut;
            }
            if (this.verticalAnimator.isPlaying)
                this.verticalAnimator.stop();
            this.verticalAnimator.duration = duration;
            this.verticalAnimator.motionPaths = [{ prop: "vsp", from: vsp, to: vspTo }];
            this.verticalAnimator.play();
        };

        /**
        * 更新垂直滚动位置
        */
        Scroller.prototype.verticalUpdateHandler = function (animation) {
            this._viewport.verticalScrollPosition = animation.currentValue["vsp"];
        };

        Object.defineProperty(Scroller.prototype, "numElements", {
            /**
            * @member egret.Scroller#numElements
            */
            get: function () {
                return this.viewport ? 1 : 0;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 抛出索引越界异常
        */
        Scroller.prototype.throwRangeError = function (index) {
            throw new RangeError("索引:\"" + index + "\"超出可视元素索引范围");
        };

        /**
        * @method egret.Scroller#getElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        Scroller.prototype.getElementAt = function (index) {
            if (this.viewport && index == 0)
                return this.viewport;
            else
                this.throwRangeError(index);
            return null;
        };

        /**
        * @method egret.Scroller#getElementIndex
        * @param element {IVisualElement}
        * @returns {number}
        */
        Scroller.prototype.getElementIndex = function (element) {
            if (element != null && element == this.viewport)
                return 0;
            else
                return -1;
        };

        /**
        * @method egret.Scroller#containsElement
        * @param element {IVisualElement}
        * @returns {boolean}
        */
        Scroller.prototype.containsElement = function (element) {
            if (element != null && element == this.viewport)
                return true;
            return false;
        };

        Scroller.prototype.throwNotSupportedError = function () {
            throw new Error("此方法在Scroller组件内不可用!");
        };

        /**
        * @method egret.Scroller#addElement
        * @deprecated
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        Scroller.prototype.addElement = function (element) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#addElementAt
        * @deprecated
        * @param element {IVisualElement}
        * @param index {number}
        * @returns {IVisualElement}
        */
        Scroller.prototype.addElementAt = function (element, index) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#removeElement
        * @deprecated
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        Scroller.prototype.removeElement = function (element) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#removeElementAt
        * @deprecated
        * @param index {number}
        * @returns {IVisualElement}
        */
        Scroller.prototype.removeElementAt = function (index) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#removeAllElements
        * @deprecated
        */
        Scroller.prototype.removeAllElements = function () {
            this.throwNotSupportedError();
        };

        /**
        * @method egret.Scroller#setElementIndex
        * @deprecated
        * @param element {IVisualElement}
        * @param index {number}
        */
        Scroller.prototype.setElementIndex = function (element, index) {
            this.throwNotSupportedError();
        };

        /**
        * @method egret.Scroller#swapElements
        * @deprecated
        * @param element1 {IVisualElement}
        * @param element2 {IVisualElement}
        */
        Scroller.prototype.swapElements = function (element1, element2) {
            this.throwNotSupportedError();
        };

        /**
        * @method egret.Scroller#swapElementsAt
        * @deprecated
        * @param index1 {number}
        * @param index2 {number}
        */
        Scroller.prototype.swapElementsAt = function (index1, index2) {
            this.throwNotSupportedError();
        };

        /**
        * @method egret.Scroller#addChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        Scroller.prototype.addChild = function (child) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#addChildAt
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        * @returns {DisplayObject}
        */
        Scroller.prototype.addChildAt = function (child, index) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#removeChild
        * @deprecated
        * @param child {DisplayObject}
        * @returns {DisplayObject}
        */
        Scroller.prototype.removeChild = function (child) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#removeChildAt
        * @deprecated
        * @param index {number}
        * @returns {DisplayObject}
        */
        Scroller.prototype.removeChildAt = function (index) {
            this.throwNotSupportedError();
            return null;
        };

        /**
        * @method egret.Scroller#setChildIndex
        * @deprecated
        * @param child {DisplayObject}
        * @param index {number}
        */
        Scroller.prototype.setChildIndex = function (child, index) {
            this.throwNotSupportedError();
        };

        /**
        * @method egret.Scroller#swapChildren
        * @deprecated
        * @param child1 {DisplayObject}
        * @param child2 {DisplayObject}
        */
        Scroller.prototype.swapChildren = function (child1, child2) {
            this.throwNotSupportedError();
        };

        /**
        * @method egret.Scroller#swapChildrenAt
        * @deprecated
        * @param index1 {number}
        * @param index2 {number}
        */
        Scroller.prototype.swapChildrenAt = function (index1, index2) {
            this.throwNotSupportedError();
        };
        Scroller.VELOCITY_WEIGHTS = [1, 1.33, 1.66, 2];
        return Scroller;
    })(egret.UIComponent);
    egret.Scroller = Scroller;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.UIEvent
    * @classdesc
    * UI事件
    * @extends egret.Event
    */
    var UIEvent = (function (_super) {
        __extends(UIEvent, _super);
        /**
        * @method egret.UIEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        */
        function UIEvent(type, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.UIEvent.dispatchUIEvent
        */
        UIEvent.dispatchUIEvent = function (target, type) {
            var eventClass = UIEvent;
            egret.Event._dispatchByTarget(eventClass, target, type);
        };
        UIEvent.INITIALIZE = "initialize";

        UIEvent.CREATION_COMPLETE = "creationComplete";

        UIEvent.UPDATE_COMPLETE = "updateComplete";

        UIEvent.BUTTON_DOWN = "buttonDown";

        UIEvent.CHANGE_END = "changeEnd";

        UIEvent.CHANGE_START = "changeStart";

        UIEvent.CHANGING = "changing";

        UIEvent.VALUE_COMMIT = "valueCommit";

        UIEvent.SKIN_CHANGED = "skinChanged";

        UIEvent.CONTENT_CHANGED = "contentChanged";

        UIEvent.OPEN = "open";

        UIEvent.CLOSE = "close";

        UIEvent.PLAY_COMPLETE = "playComplete";
        return UIEvent;
    })(egret.Event);
    egret.UIEvent = UIEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.PropertyChangeEvent
    * @classdesc
    * 对象的一个属性发生更改时传递到事件侦听器的事件
    * @extends egret.Event
    */
    var PropertyChangeEvent = (function (_super) {
        __extends(PropertyChangeEvent, _super);
        /**
        * 构造函数
        * @method egret.PropertyChangeEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param kind {string}
        * @param property {any}
        * @param oldValue {any}
        * @param newValue {any}
        * @param source {any}
        */
        function PropertyChangeEvent(type, bubbles, cancelable, kind, property, oldValue, newValue, source) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof kind === "undefined") { kind = null; }
            if (typeof property === "undefined") { property = null; }
            if (typeof oldValue === "undefined") { oldValue = null; }
            if (typeof newValue === "undefined") { newValue = null; }
            if (typeof source === "undefined") { source = null; }
            _super.call(this, type, bubbles, cancelable);

            this.kind = kind;
            this.property = property;
            this.oldValue = oldValue;
            this.newValue = newValue;
            this.source = source;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.PropertyChangeEvent.dispatchPropertyChangeEvent
        */
        PropertyChangeEvent.dispatchPropertyChangeEvent = function (target, kind, property, oldValue, newValue, source) {
            if (typeof kind === "undefined") { kind = null; }
            if (typeof property === "undefined") { property = null; }
            if (typeof oldValue === "undefined") { oldValue = null; }
            if (typeof newValue === "undefined") { newValue = null; }
            if (typeof source === "undefined") { source = null; }
            var eventClass = PropertyChangeEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.kind = kind;
            props.property = property;
            props.oldValue = oldValue;
            props.newValue = newValue;
            props.source = source;
            egret.Event._dispatchByTarget(eventClass, target, PropertyChangeEvent.PROPERTY_CHANGE, props);
        };
        PropertyChangeEvent.PROPERTY_CHANGE = "propertyChange";
        return PropertyChangeEvent;
    })(egret.Event);
    egret.PropertyChangeEvent = PropertyChangeEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.PropertyChangeEventKind
    * @classdesc
    * PropertyChangeEventKind 类定义 PropertyChangeEvent 类的 kind 属性的常量值。
    */
    var PropertyChangeEventKind = (function () {
        function PropertyChangeEventKind() {
        }
        PropertyChangeEventKind.UPDATE = "update";

        PropertyChangeEventKind.DELETE = "delete";
        return PropertyChangeEventKind;
    })();
    egret.PropertyChangeEventKind = PropertyChangeEventKind;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.MoveEvent
    * @classdesc
    * 移动事件
    * @extends egret.Event
    */
    var MoveEvent = (function (_super) {
        __extends(MoveEvent, _super);
        /**
        * @method egret.MoveEvent#constructor
        * @param type {string}
        * @param oldX {number}
        * @param oldY {number}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        */
        function MoveEvent(type, oldX, oldY, bubbles, cancelable) {
            if (typeof oldX === "undefined") { oldX = NaN; }
            if (typeof oldY === "undefined") { oldY = NaN; }
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);

            this.oldX = oldX;
            this.oldY = oldY;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.MoveEvent.dispatchMoveEvent
        */
        MoveEvent.dispatchMoveEvent = function (target, oldX, oldY) {
            if (typeof oldX === "undefined") { oldX = NaN; }
            if (typeof oldY === "undefined") { oldY = NaN; }
            var eventClass = MoveEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.oldX = oldX;
            props.oldY = oldY;
            egret.Event._dispatchByTarget(eventClass, target, MoveEvent.MOVE, props);
        };
        MoveEvent.MOVE = "move";
        return MoveEvent;
    })(egret.Event);
    egret.MoveEvent = MoveEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ResizeEvent
    * @classdesc
    * 尺寸改变事件
    * @extends egret.Event
    */
    var ResizeEvent = (function (_super) {
        __extends(ResizeEvent, _super);
        /**
        * @method egret.ResizeEvent#constructor
        * @param type {string}
        * @param oldWidth {number}
        * @param oldHeight {number}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        */
        function ResizeEvent(type, oldWidth, oldHeight, bubbles, cancelable) {
            if (typeof oldWidth === "undefined") { oldWidth = NaN; }
            if (typeof oldHeight === "undefined") { oldHeight = NaN; }
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);

            this.oldWidth = oldWidth;
            this.oldHeight = oldHeight;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.ResizeEvent.dispatchResizeEvent
        */
        ResizeEvent.dispatchResizeEvent = function (target, oldWidth, oldHeight) {
            if (typeof oldWidth === "undefined") { oldWidth = NaN; }
            if (typeof oldHeight === "undefined") { oldHeight = NaN; }
            var eventClass = ResizeEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.oldWidth = oldWidth;
            props.oldHeight = oldHeight;
            egret.Event._dispatchByTarget(eventClass, target, ResizeEvent.RESIZE, props);
        };
        ResizeEvent.RESIZE = "resize";
        return ResizeEvent;
    })(egret.Event);
    egret.ResizeEvent = ResizeEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.SkinPartEvent
    * @classdesc
    * 皮肤组件附加移除事件
    * @extends egret.Event
    */
    var SkinPartEvent = (function (_super) {
        __extends(SkinPartEvent, _super);
        /**
        * @method egret.SkinPartEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param partName {string}
        * @param instance {any}
        */
        function SkinPartEvent(type, bubbles, cancelable, partName, instance) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof partName === "undefined") { partName = null; }
            if (typeof instance === "undefined") { instance = null; }
            _super.call(this, type, bubbles, cancelable);

            this.partName = partName;
            this.instance = instance;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.SkinPartEvent.dispatchSkinPartEvent
        */
        SkinPartEvent.dispatchSkinPartEvent = function (target, type, partName, instance) {
            if (typeof partName === "undefined") { partName = null; }
            if (typeof instance === "undefined") { instance = null; }
            var eventClass = SkinPartEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.partName = partName;
            props.instance = instance;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        SkinPartEvent.PART_ADDED = "partAdded";

        SkinPartEvent.PART_REMOVED = "partRemoved";
        return SkinPartEvent;
    })(egret.Event);
    egret.SkinPartEvent = SkinPartEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.CloseEvent
    * @classdesc
    * 窗口关闭事件
    * @extends egret.Event
    */
    var CloseEvent = (function (_super) {
        __extends(CloseEvent, _super);
        /**
        * 构造函数
        * @method egret.CloseEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param detail {any}
        */
        function CloseEvent(type, bubbles, cancelable, detail) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof detail === "undefined") { detail = -1; }
            _super.call(this, type, bubbles, cancelable);

            this.detail = detail;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.CloseEvent.dispatchCloseEvent
        */
        CloseEvent.dispatchCloseEvent = function (target, type, detail) {
            if (typeof detail === "undefined") { detail = -1; }
            var eventClass = CloseEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.detail = detail;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        CloseEvent.CLOSE = "close";
        return CloseEvent;
    })(egret.Event);
    egret.CloseEvent = CloseEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.CollectionEvent
    * @classdesc
    * 集合类型数据改变事件
    * @extends egret.Event
    */
    var CollectionEvent = (function (_super) {
        __extends(CollectionEvent, _super);
        /**
        * @method egret.CollectionEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param kind {string}
        * @param location {number}
        * @param oldLocation {number}
        * @param items {Array<any>}
        * @param oldItems {Array<any>}
        */
        function CollectionEvent(type, bubbles, cancelable, kind, location, oldLocation, items, oldItems) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof kind === "undefined") { kind = null; }
            if (typeof location === "undefined") { location = -1; }
            if (typeof oldLocation === "undefined") { oldLocation = -1; }
            if (typeof items === "undefined") { items = null; }
            if (typeof oldItems === "undefined") { oldItems = null; }
            _super.call(this, type, bubbles, cancelable);

            this.kind = kind;
            this.location = location;
            this.oldLocation = oldLocation;
            this.items = items ? items : [];
            this.oldItems = oldItems ? oldItems : [];
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.CollectionEvent.dispatchCollectionEvent
        */
        CollectionEvent.dispatchCollectionEvent = function (target, type, kind, location, oldLocation, items, oldItems) {
            if (typeof kind === "undefined") { kind = null; }
            if (typeof location === "undefined") { location = -1; }
            if (typeof oldLocation === "undefined") { oldLocation = -1; }
            if (typeof items === "undefined") { items = null; }
            if (typeof oldItems === "undefined") { oldItems = null; }
            var eventClass = CollectionEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.kind = kind;
            props.location = location;
            props.oldLocation = oldLocation;
            props.items = items;
            props.oldItems = oldItems;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        CollectionEvent.COLLECTION_CHANGE = "collectionChange";
        return CollectionEvent;
    })(egret.Event);
    egret.CollectionEvent = CollectionEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.CollectionEventKind
    * @classdesc
    * 定义  CollectionEvent 类 kind 属性的有效值的常量。
    * 这些常量指示对集合进行的更改类型。
    */
    var CollectionEventKind = (function () {
        function CollectionEventKind() {
        }
        CollectionEventKind.ADD = "add";

        CollectionEventKind.MOVE = "move";

        CollectionEventKind.REFRESH = "refresh";

        CollectionEventKind.REMOVE = "remove";

        CollectionEventKind.REPLACE = "replace";

        CollectionEventKind.RESET = "reset";

        CollectionEventKind.UPDATE = "update";

        CollectionEventKind.OPEN = "open";

        CollectionEventKind.CLOSE = "close";
        return CollectionEventKind;
    })();
    egret.CollectionEventKind = CollectionEventKind;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ElementExistenceEvent
    * @classdesc
    * Group添加或移除元素时分派的事件。
    * @extends egret.Event
    */
    var ElementExistenceEvent = (function (_super) {
        __extends(ElementExistenceEvent, _super);
        /**
        * @member egret.ElementExistenceEvent#constructor
        */
        function ElementExistenceEvent(type, bubbles, cancelable, element, index) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof element === "undefined") { element = null; }
            if (typeof index === "undefined") { index = -1; }
            _super.call(this, type, bubbles, cancelable);

            this.element = element;
            this.index = index;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.ElementExistenceEvent.dispatchElementExistenceEvent
        */
        ElementExistenceEvent.dispatchElementExistenceEvent = function (target, type, element, index) {
            if (typeof element === "undefined") { element = null; }
            if (typeof index === "undefined") { index = -1; }
            var eventClass = ElementExistenceEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.element = element;
            props.index = index;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        ElementExistenceEvent.ELEMENT_ADD = "elementAdd";

        ElementExistenceEvent.ELEMENT_REMOVE = "elementRemove";
        return ElementExistenceEvent;
    })(egret.Event);
    egret.ElementExistenceEvent = ElementExistenceEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.IndexChangeEvent
    * @classdesc
    * 索引改变事件
    * @extends egret.Event
    */
    var IndexChangeEvent = (function (_super) {
        __extends(IndexChangeEvent, _super);
        /**
        * @method egret.IndexChangeEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param oldIndex {number}
        * @param newIndex {number}
        */
        function IndexChangeEvent(type, bubbles, cancelable, oldIndex, newIndex) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof oldIndex === "undefined") { oldIndex = -1; }
            if (typeof newIndex === "undefined") { newIndex = -1; }
            _super.call(this, type, bubbles, cancelable);

            this.oldIndex = oldIndex;
            this.newIndex = newIndex;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.IndexChangeEvent.dispatchIndexChangeEvent
        */
        IndexChangeEvent.dispatchIndexChangeEvent = function (target, type, oldIndex, newIndex, cancelable) {
            if (typeof oldIndex === "undefined") { oldIndex = -1; }
            if (typeof newIndex === "undefined") { newIndex = -1; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            var eventClass = IndexChangeEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.oldIndex = oldIndex;
            props.newIndex = newIndex;
            return egret.Event._dispatchByTarget(eventClass, target, type, props, false, cancelable);
        };
        IndexChangeEvent.CHANGE = "change";

        IndexChangeEvent.CHANGING = "changing";
        return IndexChangeEvent;
    })(egret.Event);
    egret.IndexChangeEvent = IndexChangeEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.ListEvent
    * @classdesc
    * 列表事件
    * @extends egret.TouchEvent
    */
    var ListEvent = (function (_super) {
        __extends(ListEvent, _super);
        /**
        * @method egret.ListEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param touchPointID {number}
        * @param stageX {number}
        * @param stageY {number}
        * @param ctrlKey {boolean}
        * @param altKey {boolean}
        * @param shiftKey {boolean}
        * @param buttonDown {boolean}
        * @param itemIndex {number}
        * @param item {any}
        * @param itemRenderer {IItemRenderer}
        */
        function ListEvent(type, bubbles, cancelable, touchPointID, stageX, stageY, ctrlKey, altKey, shiftKey, buttonDown, itemIndex, item, itemRenderer) {
            if (typeof bubbles === "undefined") { bubbles = true; }
            if (typeof cancelable === "undefined") { cancelable = true; }
            if (typeof touchPointID === "undefined") { touchPointID = 0; }
            if (typeof stageX === "undefined") { stageX = 0; }
            if (typeof stageY === "undefined") { stageY = 0; }
            if (typeof ctrlKey === "undefined") { ctrlKey = false; }
            if (typeof altKey === "undefined") { altKey = false; }
            if (typeof shiftKey === "undefined") { shiftKey = false; }
            if (typeof buttonDown === "undefined") { buttonDown = false; }
            if (typeof itemIndex === "undefined") { itemIndex = -1; }
            if (typeof item === "undefined") { item = null; }
            if (typeof itemRenderer === "undefined") { itemRenderer = null; }
            _super.call(this, type, bubbles, cancelable, touchPointID, stageX, stageY, ctrlKey, altKey, shiftKey, buttonDown);

            this.itemIndex = itemIndex;
            this.item = item;
            this.itemRenderer = itemRenderer;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.ListEvent.dispatchListEvent
        */
        ListEvent.dispatchListEvent = function (target, type, touchEvent, itemIndex, item, itemRenderer) {
            if (typeof touchEvent === "undefined") { touchEvent = null; }
            if (typeof itemIndex === "undefined") { itemIndex = -1; }
            if (typeof item === "undefined") { item = null; }
            if (typeof itemRenderer === "undefined") { itemRenderer = null; }
            var eventClass = ListEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.touchPointID = touchEvent.touchPointID;
            props._stageX = touchEvent.stageX;
            props._stageY = touchEvent.stageY;
            props.ctrlKey = touchEvent.ctrlKey;
            props.altKey = touchEvent.altKey;
            props.shiftKey = touchEvent.shiftKey;
            props.touchDown = touchEvent.touchDown;
            props.itemIndex = itemIndex;
            props.item = item;
            props.itemRenderer = itemRenderer;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        ListEvent.ITEM_ROLL_OUT = "itemRollOut";

        ListEvent.ITEM_ROLL_OVER = "itemRollOver";

        ListEvent.ITEM_CLICK = "itemClick";
        return ListEvent;
    })(egret.TouchEvent);
    egret.ListEvent = ListEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.PopUpEvent
    * @classdesc
    * 弹出管理器事件
    * @extends egret.Event
    */
    var PopUpEvent = (function (_super) {
        __extends(PopUpEvent, _super);
        /**
        * 构造函数
        * @method egret.PopUpEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param popUp {IVisualElement}
        * @param modal {boolean}
        */
        function PopUpEvent(type, bubbles, cancelable, popUp, modal) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof popUp === "undefined") { popUp = null; }
            if (typeof modal === "undefined") { modal = false; }
            _super.call(this, type, bubbles, cancelable);
            this.popUp = popUp;
            this.modal = modal;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.PopUpEvent.dispatchPopUpEvent
        */
        PopUpEvent.dispatchPopUpEvent = function (target, type, popUp, modal) {
            if (typeof popUp === "undefined") { popUp = null; }
            if (typeof modal === "undefined") { modal = false; }
            var eventClass = PopUpEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.popUp = popUp;
            props.modal = modal;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        PopUpEvent.ADD_POPUP = "addPopUp";

        PopUpEvent.REMOVE_POPUP = "removePopUp";

        PopUpEvent.BRING_TO_FRONT = "bringToFront";
        return PopUpEvent;
    })(egret.Event);
    egret.PopUpEvent = PopUpEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.RendererExistenceEvent
    * @classdesc
    * 在DataGroup添加或删除项呈示器时分派的事件。
    * @extends egret.Event
    */
    var RendererExistenceEvent = (function (_super) {
        __extends(RendererExistenceEvent, _super);
        /**
        * @method egret.RendererExistenceEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param renderer {IItemRenderer}
        * @param index {number}
        * @param data {any}
        */
        function RendererExistenceEvent(type, bubbles, cancelable, renderer, index, data) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof renderer === "undefined") { renderer = null; }
            if (typeof index === "undefined") { index = -1; }
            if (typeof data === "undefined") { data = null; }
            _super.call(this, type, bubbles, cancelable);

            this.renderer = renderer;
            this.index = index;
            this.data = data;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.RendererExistenceEvent.dispatchRendererExistenceEvent
        */
        RendererExistenceEvent.dispatchRendererExistenceEvent = function (target, type, renderer, index, data) {
            if (typeof renderer === "undefined") { renderer = null; }
            if (typeof index === "undefined") { index = -1; }
            if (typeof data === "undefined") { data = null; }
            var eventClass = RendererExistenceEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.renderer = renderer;
            props.index = index;
            props.data = data;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        RendererExistenceEvent.RENDERER_ADD = "rendererAdd";

        RendererExistenceEvent.RENDERER_REMOVE = "rendererRemove";
        return RendererExistenceEvent;
    })(egret.Event);
    egret.RendererExistenceEvent = RendererExistenceEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.StateChangeEvent
    * @classdesc
    * 视图状态改变事件
    * @extends egret.Event
    */
    var StateChangeEvent = (function (_super) {
        __extends(StateChangeEvent, _super);
        /**
        * @method egret.StateChangeEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param oldState {string}
        * @param newState {string}
        */
        function StateChangeEvent(type, bubbles, cancelable, oldState, newState) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            if (typeof oldState === "undefined") { oldState = null; }
            if (typeof newState === "undefined") { newState = null; }
            _super.call(this, type, bubbles, cancelable);

            this.oldState = oldState;
            this.newState = newState;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.StateChangeEvent.dispatchStateChangeEvent
        */
        StateChangeEvent.dispatchStateChangeEvent = function (target, type, oldState, newState) {
            if (typeof oldState === "undefined") { oldState = null; }
            if (typeof newState === "undefined") { newState = null; }
            var eventClass = StateChangeEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.oldState = oldState;
            props.newState = newState;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        StateChangeEvent.CURRENT_STATE_CHANGE = "currentStateChange";

        StateChangeEvent.CURRENT_STATE_CHANGING = "currentStateChanging";
        return StateChangeEvent;
    })(egret.Event);
    egret.StateChangeEvent = StateChangeEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TrackBaseEvent
    * @classdesc
    * 从TrackBase组件分派的事件。
    * @extends egret.Event
    */
    var TrackBaseEvent = (function (_super) {
        __extends(TrackBaseEvent, _super);
        /**
        * 构造函数
        * @method egret.TrackBaseEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        */
        function TrackBaseEvent(type, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.TrackBaseEvent.dispatchTrackBaseEvent
        */
        TrackBaseEvent.dispatchTrackBaseEvent = function (target, type) {
            var eventClass = TrackBaseEvent;
            egret.Event._dispatchByTarget(eventClass, target, type);
        };
        TrackBaseEvent.THUMB_DRAG = "thumbDrag";

        TrackBaseEvent.THUMB_PRESS = "thumbPress";

        TrackBaseEvent.THUMB_RELEASE = "thumbRelease";
        return TrackBaseEvent;
    })(egret.Event);
    egret.TrackBaseEvent = TrackBaseEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TreeEvent
    * @classdesc
    * Tree事件
    * @extends egret.Event
    */
    var TreeEvent = (function (_super) {
        __extends(TreeEvent, _super);
        /**
        * @method egret.TreeEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        * @param itemIndex {number}
        * @param item {any}
        * @param itemRenderer {ITreeItemRenderer}
        */
        function TreeEvent(type, bubbles, cancelable, itemIndex, item, itemRenderer) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = true; }
            if (typeof itemIndex === "undefined") { itemIndex = -1; }
            if (typeof item === "undefined") { item = null; }
            if (typeof itemRenderer === "undefined") { itemRenderer = null; }
            _super.call(this, type, bubbles, cancelable);
            this.item = item;
            this.itemRenderer = itemRenderer;
            this.itemIndex = itemIndex;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method egret.TreeEvent.dispatchTreeEvent
        */
        TreeEvent.dispatchTreeEvent = function (target, type, itemIndex, item, itemRenderer, opening) {
            if (typeof itemIndex === "undefined") { itemIndex = -1; }
            if (typeof item === "undefined") { item = null; }
            if (typeof itemRenderer === "undefined") { itemRenderer = null; }
            if (typeof opening === "undefined") { opening = false; }
            var eventClass = TreeEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.itemIndex = itemIndex;
            props.item = item;
            props.itemRenderer = itemRenderer;
            props.opening = opening;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        TreeEvent.ITEM_CLOSE = "itemClose";

        TreeEvent.ITEM_OPEN = "itemOpen";

        TreeEvent.ITEM_OPENING = "itemOpening";
        return TreeEvent;
    })(egret.Event);
    egret.TreeEvent = TreeEvent;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.LayoutBase
    * @classdesc
    * 容器布局基类
    * @extends egret.EventDispatcher
    */
    var LayoutBase = (function (_super) {
        __extends(LayoutBase, _super);
        /**
        * @method egret.LayoutBase#constructor
        */
        function LayoutBase() {
            _super.call(this);
            this._useVirtualLayout = false;
        }
        Object.defineProperty(LayoutBase.prototype, "target", {
            /**
            * 目标容器
            * @member egret.LayoutBase#target
            */
            get: function () {
                return this._target;
            },
            set: function (value) {
                if (this._target == value)
                    return;
                this._target = value;
                this.clearVirtualLayoutCache();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(LayoutBase.prototype, "useVirtualLayout", {
            /**
            * 若要配置容器使用虚拟布局，请为与容器关联的布局的 useVirtualLayout 属性设置为 true。
            * 只有布局设置为 VerticalLayout、HorizontalLayout
            * 或 TileLayout 的 DataGroup 或 SkinnableDataContainer
            * 才支持虚拟布局。不支持虚拟化的布局子类必须禁止更改此属性。
            * @member egret.LayoutBase#useVirtualLayout
            */
            get: function () {
                return this._useVirtualLayout;
            },
            set: function (value) {
                if (this._useVirtualLayout == value)
                    return;

                this._useVirtualLayout = value;
                this.dispatchEventWith("useVirtualLayoutChanged");

                if (this._useVirtualLayout && !value)
                    this.clearVirtualLayoutCache();
                if (this.target)
                    this.target.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(LayoutBase.prototype, "typicalLayoutRect", {
            /**
            * 由虚拟布局所使用，以估计尚未滚动到视图中的布局元素的大小。
            * @member egret.LayoutBase#typicalLayoutRect
            */
            get: function () {
                return this._typicalLayoutRect;
            },
            set: function (value) {
                if (this._typicalLayoutRect == value)
                    return;
                this._typicalLayoutRect = value;
                if (this.target)
                    this.target.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 滚动条位置改变
        * @method egret.LayoutBase#scrollPositionChanged
        */
        LayoutBase.prototype.scrollPositionChanged = function () {
        };

        /**
        * 清理虚拟布局缓存的数据
        * @method egret.LayoutBase#clearVirtualLayoutCache
        */
        LayoutBase.prototype.clearVirtualLayoutCache = function () {
        };

        /**
        * 在已添加布局元素之后且在验证目标的大小和显示列表之前，由目标调用。
        * 按元素状态缓存的布局（比如虚拟布局）可以覆盖此方法以更新其缓存。
        * @method egret.LayoutBase#elementAdded
        * @param index {number}
        */
        LayoutBase.prototype.elementAdded = function (index) {
        };

        /**
        * 必须在已删除布局元素之后且在验证目标的大小和显示列表之前，由目标调用此方法。
        * 按元素状态缓存的布局（比如虚拟布局）可以覆盖此方法以更新其缓存。
        * @method egret.LayoutBase#elementRemoved
        * @param index {number}
        */
        LayoutBase.prototype.elementRemoved = function (index) {
        };

        /**
        * 测量组件尺寸大小
        * @method egret.LayoutBase#measure
        */
        LayoutBase.prototype.measure = function () {
        };

        /**
        * 更新显示列表
        * @method egret.LayoutBase#updateDisplayList
        * @param width {number}
        * @param height {number}
        */
        LayoutBase.prototype.updateDisplayList = function (width, height) {
        };
        return LayoutBase;
    })(egret.EventDispatcher);
    egret.LayoutBase = LayoutBase;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.BasicLayout
    * @classdesc
    * 基本布局
    * @extends egret.LayoutBase
    */
    var BasicLayout = (function (_super) {
        __extends(BasicLayout, _super);
        /**
        * @method egret.BasicLayout#constructor
        */
        function BasicLayout() {
            _super.call(this);
            this._mouseWheelSpeed = 20;
        }
        Object.defineProperty(BasicLayout.prototype, "useVirtualLayout", {
            /**
            * 此布局不支持虚拟布局，设置这个属性无效
            */
            set: function (value) {
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(BasicLayout.prototype, "mouseWheelSpeed", {
            /**
            * 鼠标滚轮每次滚动时目标容器的verticalScrollPosition
            * 或horizontalScrollPosition改变的像素距离。必须大于0， 默认值20。
            * @member egret.BasicLayout#mouseWheelSpeed
            */
            get: function () {
                return this._mouseWheelSpeed;
            },
            set: function (value) {
                if (value == 0)
                    value = 1;
                this._mouseWheelSpeed = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.BasicLayout#getElementBoundsLeftOfScrollRect
        * @param scrollRect {Rectangle}
        * @returns {Rectangle}
        */
        BasicLayout.prototype.getElementBoundsLeftOfScrollRect = function (scrollRect) {
            var bounds = new egret.Rectangle();
            bounds.x = scrollRect.x - this._mouseWheelSpeed;
            bounds.right = scrollRect.x;
            return bounds;
        };

        /**
        * @method egret.BasicLayout#getElementBoundsRightOfScrollRect
        * @param scrollRect {Rectangle}
        * @returns {Rectangle}
        */
        BasicLayout.prototype.getElementBoundsRightOfScrollRect = function (scrollRect) {
            var bounds = new egret.Rectangle();
            bounds.x = scrollRect.right;
            bounds.right = scrollRect.right + this._mouseWheelSpeed;
            return bounds;
        };

        /**
        * @method egret.BasicLayout#getElementBoundsAboveScrollRect
        * @param scrollRect {Rectangle}
        * @returns {Rectangle}
        */
        BasicLayout.prototype.getElementBoundsAboveScrollRect = function (scrollRect) {
            var bounds = new egret.Rectangle();
            bounds.y = scrollRect.y - this._mouseWheelSpeed;
            bounds.bottom = scrollRect.y;
            return bounds;
        };

        /**
        * @method egret.BasicLayout#getElementBoundsBelowScrollRect
        * @param scrollRect {Rectangle}
        * @returns {Rectangle}
        */
        BasicLayout.prototype.getElementBoundsBelowScrollRect = function (scrollRect) {
            var bounds = new egret.Rectangle();
            bounds.y = scrollRect.bottom;
            bounds.bottom = scrollRect.bottom + this._mouseWheelSpeed;
            return bounds;
        };

        /**
        * @method egret.BasicLayout#measure
        */
        BasicLayout.prototype.measure = function () {
            _super.prototype.measure.call(this);

            if (this.target == null)
                return;

            var width = 0;
            var height = 0;

            var count = this.target.numElements;
            for (var i = 0; i < count; i++) {
                var layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout)
                    continue;

                var hCenter = layoutElement.horizontalCenter;
                var vCenter = layoutElement.verticalCenter;
                var left = layoutElement.left;
                var right = layoutElement.right;
                var top = layoutElement.top;
                var bottom = layoutElement.bottom;

                var extX;
                var extY;

                if (!isNaN(left) && !isNaN(right)) {
                    extX = left + right;
                } else if (!isNaN(hCenter)) {
                    extX = Math.abs(hCenter) * 2;
                } else if (!isNaN(left) || !isNaN(right)) {
                    extX = isNaN(left) ? 0 : left;
                    extX += isNaN(right) ? 0 : right;
                } else {
                    extX = layoutElement.preferredX;
                }

                if (!isNaN(top) && !isNaN(bottom)) {
                    extY = top + bottom;
                } else if (!isNaN(vCenter)) {
                    extY = Math.abs(vCenter) * 2;
                } else if (!isNaN(top) || !isNaN(bottom)) {
                    extY = isNaN(top) ? 0 : top;
                    extY += isNaN(bottom) ? 0 : bottom;
                } else {
                    extY = layoutElement.preferredY;
                }

                var preferredWidth = layoutElement.preferredWidth;
                var preferredHeight = layoutElement.preferredHeight;

                width = Math.ceil(Math.max(width, extX + preferredWidth));
                height = Math.ceil(Math.max(height, extY + preferredHeight));
            }

            this.target.measuredWidth = width;
            this.target.measuredHeight = height;
        };

        /**
        * @method egret.BasicLayout#updateDisplayList
        * @param unscaledWidth {number}
        * @param unscaledHeight {number}
        */
        BasicLayout.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);

            if (this.target == null)
                return;

            var count = this.target.numElements;

            var maxX = 0;
            var maxY = 0;
            for (var i = 0; i < count; i++) {
                var layoutElement = (this.target.getElementAt(i));
                if (layoutElement == null || !layoutElement.includeInLayout)
                    continue;

                var hCenter = layoutElement.horizontalCenter;
                var vCenter = layoutElement.verticalCenter;
                var left = layoutElement.left;
                var right = layoutElement.right;
                var top = layoutElement.top;
                var bottom = layoutElement.bottom;
                var percentWidth = layoutElement.percentWidth;
                var percentHeight = layoutElement.percentHeight;

                var childWidth = NaN;
                var childHeight = NaN;

                if (!isNaN(left) && !isNaN(right)) {
                    childWidth = unscaledWidth - right - left;
                } else if (!isNaN(percentWidth)) {
                    childWidth = Math.round(unscaledWidth * Math.min(percentWidth * 0.01, 1));
                }

                if (!isNaN(top) && !isNaN(bottom)) {
                    childHeight = unscaledHeight - bottom - top;
                } else if (!isNaN(percentHeight)) {
                    childHeight = Math.round(unscaledHeight * Math.min(percentHeight * 0.01, 1));
                }

                layoutElement.setLayoutBoundsSize(childWidth, childHeight);

                var elementWidth = layoutElement.layoutBoundsWidth;
                var elementHeight = layoutElement.layoutBoundsHeight;

                var childX = NaN;
                var childY = NaN;

                if (!isNaN(hCenter))
                    childX = Math.round((unscaledWidth - elementWidth) / 2 + hCenter);
                else if (!isNaN(left))
                    childX = left;
                else if (!isNaN(right))
                    childX = unscaledWidth - elementWidth - right;
                else
                    childX = layoutElement.layoutBoundsX;

                if (!isNaN(vCenter))
                    childY = Math.round((unscaledHeight - elementHeight) / 2 + vCenter);
                else if (!isNaN(top))
                    childY = top;
                else if (!isNaN(bottom))
                    childY = unscaledHeight - elementHeight - bottom;
                else
                    childY = layoutElement.layoutBoundsY;

                layoutElement.setLayoutBoundsPosition(childX, childY);

                maxX = Math.max(maxX, childX + elementWidth);
                maxY = Math.max(maxY, childY + elementHeight);
            }
            this.target.setContentSize(maxX, maxY);
        };
        return BasicLayout;
    })(egret.LayoutBase);
    egret.BasicLayout = BasicLayout;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.ColumnAlign
    * @classdesc
    * ColumnAlign 类为 TileLayout 类的 columnAlign 属性定义可能的值。
    */
    var ColumnAlign = (function () {
        function ColumnAlign() {
        }
        ColumnAlign.LEFT = "left";

        ColumnAlign.JUSTIFY_USING_GAP = "justifyUsingGap";

        ColumnAlign.JUSTIFY_USING_WIDTH = "justifyUsingWidth";
        return ColumnAlign;
    })();
    egret.ColumnAlign = ColumnAlign;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.RowAlign
    * @classdesc
    * RowAlign 类为 TileLayout 类的 rowAlign 属性定义可能的值。
    */
    var RowAlign = (function () {
        function RowAlign() {
        }
        RowAlign.TOP = "top";

        RowAlign.JUSTIFY_USING_GAP = "justifyUsingGap";

        RowAlign.JUSTIFY_USING_HEIGHT = "justifyUsingHeight";
        return RowAlign;
    })();
    egret.RowAlign = RowAlign;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.TileOrientation
    * @classdesc
    * TileOrientation 类为 TileLayout 类的 orientation 属性定义可能的值。
    */
    var TileOrientation = (function () {
        function TileOrientation() {
        }
        TileOrientation.ROWS = "rows";

        TileOrientation.COLUMNS = "columns";
        return TileOrientation;
    })();
    egret.TileOrientation = TileOrientation;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.VerticalLayout
    * @classdesc
    * 垂直布局
    * @extends egret.LayoutBase
    */
    var VerticalLayout = (function (_super) {
        __extends(VerticalLayout, _super);
        /**
        * @method egret.VerticalLayout#constructor
        */
        function VerticalLayout() {
            _super.call(this);
            this._horizontalAlign = egret.HorizontalAlign.LEFT;
            this._verticalAlign = egret.VerticalAlign.TOP;
            this._gap = 6;
            this._padding = 0;
            this._paddingLeft = NaN;
            this._paddingRight = NaN;
            this._paddingTop = NaN;
            this._paddingBottom = NaN;
            /**
            * 虚拟布局使用的子对象尺寸缓存
            */
            this.elementSizeTable = [];
            /**
            * 虚拟布局使用的当前视图中的第一个元素索引
            */
            this.startIndex = -1;
            /**
            * 虚拟布局使用的当前视图中的最后一个元素的索引
            */
            this.endIndex = -1;
            /**
            * 视图的第一个和最后一个元素的索引值已经计算好的标志
            */
            this.indexInViewCalculated = false;
            /**
            * 子对象最大宽度
            */
            this.maxElementWidth = 0;
        }
        Object.defineProperty(VerticalLayout.prototype, "horizontalAlign", {
            /**
            * 布局元素的水平对齐策略。参考HorizontalAlign定义的常量。
            * @member egret.VerticalLayout#horizontalAlign
            */
            get: function () {
                return this._horizontalAlign;
            },
            set: function (value) {
                if (this._horizontalAlign == value)
                    return;
                this._horizontalAlign = value;
                if (this.target)
                    this.target.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(VerticalLayout.prototype, "verticalAlign", {
            /**
            * 布局元素的竖直对齐策略。参考VerticalAlign定义的常量。
            * 注意：此属性设置为CONTENT_JUSTIFY始终无效。当useVirtualLayout为true时，设置JUSTIFY也无效。
            * @member egret.VerticalLayout#verticalAlign
            */
            get: function () {
                return this._verticalAlign;
            },
            set: function (value) {
                if (this._verticalAlign == value)
                    return;
                this._verticalAlign = value;
                if (this.target)
                    this.target.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(VerticalLayout.prototype, "gap", {
            /**
            * 布局元素之间的垂直空间（以像素为单位）
            * @member egret.VerticalLayout#gap
            */
            get: function () {
                return this._gap;
            },
            set: function (value) {
                if (this._gap == value)
                    return;
                this._gap = value;
                this.invalidateTargetSizeAndDisplayList();
                if (this.hasEventListener("gapChanged"))
                    this.dispatchEventWith("gapChanged");
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(VerticalLayout.prototype, "padding", {
            /**
            * 四个边缘的共同内边距。若单独设置了任一边缘的内边距，则该边缘的内边距以单独设置的值为准。
            * 此属性主要用于快速设置多个边缘的相同内边距。默认值：0。
            * @member egret.VerticalLayout#padding
            */
            get: function () {
                return this._padding;
            },
            set: function (value) {
                if (this._padding == value)
                    return;
                this._padding = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(VerticalLayout.prototype, "paddingLeft", {
            /**
            * 容器的左边缘与布局元素的左边缘之间的最少像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.VerticalLayout#paddingLeft
            */
            get: function () {
                return this._paddingLeft;
            },
            set: function (value) {
                if (this._paddingLeft == value)
                    return;

                this._paddingLeft = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(VerticalLayout.prototype, "paddingRight", {
            /**
            * 容器的右边缘与布局元素的右边缘之间的最少像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.VerticalLayout#paddingRight
            */
            get: function () {
                return this._paddingRight;
            },
            set: function (value) {
                if (this._paddingRight == value)
                    return;

                this._paddingRight = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(VerticalLayout.prototype, "paddingTop", {
            /**
            * 容器的顶边缘与第一个布局元素的顶边缘之间的像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.VerticalLayout#paddingTop
            */
            get: function () {
                return this._paddingTop;
            },
            set: function (value) {
                if (this._paddingTop == value)
                    return;

                this._paddingTop = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(VerticalLayout.prototype, "paddingBottom", {
            /**
            * 容器的底边缘与最后一个布局元素的底边缘之间的像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.VerticalLayout#paddingBottom
            */
            get: function () {
                return this._paddingBottom;
            },
            set: function (value) {
                if (this._paddingBottom == value)
                    return;

                this._paddingBottom = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 标记目标容器的尺寸和显示列表失效
        */
        VerticalLayout.prototype.invalidateTargetSizeAndDisplayList = function () {
            if (this.target) {
                this.target.invalidateSize();
                this.target.invalidateDisplayList();
            }
        };

        /**
        * @method egret.VerticalLayout#measure
        */
        VerticalLayout.prototype.measure = function () {
            _super.prototype.measure.call(this);
            if (!this.target)
                return;
            if (this.useVirtualLayout) {
                this.measureVirtual();
            } else {
                this.measureReal();
            }
        };

        /**
        * 测量使用虚拟布局的尺寸
        */
        VerticalLayout.prototype.measureVirtual = function () {
            var numElements = this.target.numElements;
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            var measuredWidth = Math.max(this.maxElementWidth, typicalWidth);
            var measuredHeight = this.getElementTotalSize();

            var visibleIndices = this.target.getElementIndicesInView();
            var length = visibleIndices.length;
            for (var i = 0; i < length; i++) {
                var index = visibleIndices[i];
                var layoutElement = (this.target.getElementAt(index));
                if (layoutElement == null || !layoutElement.includeInLayout)
                    continue;

                var preferredWidth = layoutElement.preferredWidth;
                var preferredHeight = layoutElement.preferredHeight;
                measuredHeight += preferredHeight;
                measuredHeight -= isNaN(this.elementSizeTable[index]) ? typicalHeight : this.elementSizeTable[index];
                measuredWidth = Math.max(measuredWidth, preferredWidth);
            }
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var hPadding = paddingL + paddingR;
            var vPadding = paddingT + paddingB;
            this.target.measuredWidth = Math.ceil(measuredWidth + hPadding);
            this.target.measuredHeight = Math.ceil(measuredHeight + vPadding);
        };

        /**
        * 测量使用真实布局的尺寸
        */
        VerticalLayout.prototype.measureReal = function () {
            var count = this.target.numElements;
            var numElements = count;
            var measuredWidth = 0;
            var measuredHeight = 0;
            for (var i = 0; i < count; i++) {
                var layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout) {
                    numElements--;
                    continue;
                }
                var preferredWidth = layoutElement.preferredWidth;
                var preferredHeight = layoutElement.preferredHeight;
                measuredHeight += preferredHeight;
                measuredWidth = Math.max(measuredWidth, preferredWidth);
            }
            var gap = isNaN(this._gap) ? 0 : this._gap;
            measuredHeight += (numElements - 1) * gap;
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var hPadding = paddingL + paddingR;
            var vPadding = paddingT + paddingB;
            this.target.measuredWidth = Math.ceil(measuredWidth + hPadding);
            this.target.measuredHeight = Math.ceil(measuredHeight + vPadding);
        };

        /**
        * @method egret.VerticalLayout#updateDisplayList
        * @param width {number}
        * @param height {number}
        */
        VerticalLayout.prototype.updateDisplayList = function (width, height) {
            _super.prototype.updateDisplayList.call(this, width, height);
            if (!this.target)
                return;
            if (this.useVirtualLayout) {
                this.updateDisplayListVirtual(width, height);
            } else {
                this.updateDisplayListReal(width, height);
            }
        };

        /**
        * 获取指定索引的起始位置
        */
        VerticalLayout.prototype.getStartPosition = function (index) {
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            if (!this.useVirtualLayout) {
                var element;
                if (this.target) {
                    element = this.target.getElementAt(index);
                }
                return element ? element.y : paddingT;
            }
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var startPos = paddingT;
            for (var i = 0; i < index; i++) {
                var eltHeight = this.elementSizeTable[i];
                if (isNaN(eltHeight)) {
                    eltHeight = typicalHeight;
                }
                startPos += eltHeight + gap;
            }
            return startPos;
        };

        /**
        * 获取指定索引的元素尺寸
        */
        VerticalLayout.prototype.getElementSize = function (index) {
            if (this.useVirtualLayout) {
                var size = this.elementSizeTable[index];
                if (isNaN(size)) {
                    size = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
                }
                return size;
            }
            if (this.target) {
                return this.target.getElementAt(index).height;
            }
            return 0;
        };

        /**
        * 获取缓存的子对象尺寸总和
        */
        VerticalLayout.prototype.getElementTotalSize = function () {
            var gap = isNaN(this._gap) ? 0 : this._gap;
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var totalSize = 0;
            var length = this.target.numElements;
            for (var i = 0; i < length; i++) {
                var eltHeight = this.elementSizeTable[i];
                if (isNaN(eltHeight)) {
                    eltHeight = typicalHeight;
                }
                totalSize += eltHeight + gap;
            }
            totalSize -= gap;
            return totalSize;
        };

        /**
        * @method egret.VerticalLayout#elementAdded
        * @param index {number}
        */
        VerticalLayout.prototype.elementAdded = function (index) {
            _super.prototype.elementAdded.call(this, index);
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            this.elementSizeTable.splice(index, 0, typicalHeight);
        };

        /**
        * @method egret.VerticalLayout#elementRemoved
        * @param index {number}
        */
        VerticalLayout.prototype.elementRemoved = function (index) {
            _super.prototype.elementRemoved.call(this, index);
            this.elementSizeTable.splice(index, 1);
        };

        /**
        * @method egret.VerticalLayout#clearVirtualLayoutCache
        */
        VerticalLayout.prototype.clearVirtualLayoutCache = function () {
            _super.prototype.clearVirtualLayoutCache.call(this);
            this.elementSizeTable = [];
            this.maxElementWidth = 0;
        };

        /**
        * 折半查找法寻找指定位置的显示对象索引
        */
        VerticalLayout.prototype.findIndexAt = function (y, i0, i1) {
            var index = Math.floor((i0 + i1) * 0.5);
            var elementY = this.getStartPosition(index);
            var elementHeight = this.getElementSize(index);
            var gap = isNaN(this._gap) ? 0 : this._gap;
            if ((y >= elementY) && (y < elementY + elementHeight + gap))
                return index;
            else if (i0 == i1)
                return -1;
            else if (y < elementY)
                return this.findIndexAt(y, i0, Math.max(i0, index - 1));
            else
                return this.findIndexAt(y, Math.min(index + 1, i1), i1);
        };

        /**
        * @method egret.VerticalLayout#scrollPositionChanged
        */
        VerticalLayout.prototype.scrollPositionChanged = function () {
            _super.prototype.scrollPositionChanged.call(this);
            if (this.useVirtualLayout) {
                var changed = this.getIndexInView();
                if (changed) {
                    this.indexInViewCalculated = true;
                    this.target.invalidateDisplayList();
                }
            }
        };

        /**
        * 获取视图中第一个和最后一个元素的索引,返回是否发生改变
        */
        VerticalLayout.prototype.getIndexInView = function () {
            if (!this.target || this.target.numElements == 0) {
                this.startIndex = this.endIndex = -1;
                return false;
            }

            if (isNaN(this.target.width) || this.target.width == 0 || isNaN(this.target.height) || this.target.height == 0) {
                this.startIndex = this.endIndex = -1;
                return false;
            }
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var numElements = this.target.numElements;
            var contentHeight = this.getStartPosition(numElements - 1) + this.elementSizeTable[numElements - 1] + paddingB;
            var minVisibleY = this.target.verticalScrollPosition;
            if (minVisibleY > contentHeight - paddingB) {
                this.startIndex = -1;
                this.endIndex = -1;
                return false;
            }
            var maxVisibleY = this.target.verticalScrollPosition + this.target.height;
            if (maxVisibleY < paddingT) {
                this.startIndex = -1;
                this.endIndex = -1;
                return false;
            }
            var oldStartIndex = this.startIndex;
            var oldEndIndex = this.endIndex;
            this.startIndex = this.findIndexAt(minVisibleY, 0, numElements - 1);
            if (this.startIndex == -1)
                this.startIndex = 0;
            this.endIndex = this.findIndexAt(maxVisibleY, 0, numElements - 1);
            if (this.endIndex == -1)
                this.endIndex = numElements - 1;
            return oldStartIndex != this.startIndex || oldEndIndex != this.endIndex;
        };

        /**
        * 更新使用虚拟布局的显示列表
        */
        VerticalLayout.prototype.updateDisplayListVirtual = function (width, height) {
            if (this.indexInViewCalculated)
                this.indexInViewCalculated = false;
            else
                this.getIndexInView();
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            var contentHeight;
            var numElements = this.target.numElements;
            if (this.startIndex == -1 || this.endIndex == -1) {
                contentHeight = this.getStartPosition(numElements) - gap + paddingB;
                this.target.setContentSize(this.target.contentWidth, Math.ceil(contentHeight));
                return;
            }
            this.target.setVirtualElementIndicesInView(this.startIndex, this.endIndex);

            //获取水平布局参数
            var justify = this._horizontalAlign == egret.HorizontalAlign.JUSTIFY || this._horizontalAlign == egret.HorizontalAlign.CONTENT_JUSTIFY;
            var contentJustify = this._horizontalAlign == egret.HorizontalAlign.CONTENT_JUSTIFY;
            var hAlign = 0;
            if (!justify) {
                if (this._horizontalAlign == egret.HorizontalAlign.CENTER) {
                    hAlign = 0.5;
                } else if (this._horizontalAlign == egret.HorizontalAlign.RIGHT) {
                    hAlign = 1;
                }
            }

            var targetWidth = Math.max(0, width - paddingL - paddingR);
            var justifyWidth = Math.ceil(targetWidth);
            var layoutElement;
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            var oldMaxW = Math.max(typicalWidth, this.maxElementWidth);
            if (contentJustify) {
                for (var index = this.startIndex; index <= this.endIndex; index++) {
                    layoutElement = (this.target.getVirtualElementAt(index));
                    if (!layoutElement || !layoutElement.includeInLayout)
                        continue;
                    this.maxElementWidth = Math.max(this.maxElementWidth, layoutElement.preferredWidth);
                }
                justifyWidth = Math.ceil(Math.max(targetWidth, this.maxElementWidth));
            }
            var x = 0;
            var y = 0;
            var contentWidth = 0;
            var oldElementSize;
            var needInvalidateSize = false;

            for (var i = this.startIndex; i <= this.endIndex; i++) {
                var exceesWidth = 0;
                layoutElement = (this.target.getVirtualElementAt(i));
                if (!layoutElement) {
                    continue;
                } else if (!layoutElement.includeInLayout) {
                    this.elementSizeTable[i] = 0;
                    continue;
                }
                if (justify) {
                    x = paddingL;
                    layoutElement.setLayoutBoundsSize(justifyWidth, NaN);
                } else {
                    exceesWidth = (targetWidth - layoutElement.layoutBoundsWidth) * hAlign;
                    exceesWidth = exceesWidth > 0 ? exceesWidth : 0;
                    x = paddingL + exceesWidth;
                }
                if (!contentJustify)
                    this.maxElementWidth = Math.max(this.maxElementWidth, layoutElement.preferredWidth);
                contentWidth = Math.max(contentWidth, layoutElement.layoutBoundsWidth);
                if (!needInvalidateSize) {
                    oldElementSize = isNaN(this.elementSizeTable[i]) ? typicalHeight : this.elementSizeTable[i];
                    if (oldElementSize != layoutElement.layoutBoundsHeight)
                        needInvalidateSize = true;
                }
                if (i == 0 && this.elementSizeTable.length > 0 && this.elementSizeTable[i] != layoutElement.layoutBoundsHeight)
                    this.typicalLayoutRect = null;
                this.elementSizeTable[i] = layoutElement.layoutBoundsHeight;
                y = this.getStartPosition(i);
                layoutElement.setLayoutBoundsPosition(Math.round(x), Math.round(y));
            }
            contentWidth += paddingL + paddingR;
            contentHeight = this.getStartPosition(numElements) - gap + paddingB;
            this.target.setContentSize(Math.ceil(contentWidth), Math.ceil(contentHeight));
            if (needInvalidateSize || oldMaxW < this.maxElementWidth) {
                this.target.invalidateSize();
            }
        };

        /**
        * 更新使用真实布局的显示列表
        */
        VerticalLayout.prototype.updateDisplayListReal = function (width, height) {
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            var targetWidth = Math.max(0, width - paddingL - paddingR);
            var targetHeight = Math.max(0, height - paddingT - paddingB);

            // 获取水平布局参数
            var vJustify = this._verticalAlign == egret.VerticalAlign.JUSTIFY;
            var hJustify = this._horizontalAlign == egret.HorizontalAlign.JUSTIFY || this._horizontalAlign == egret.HorizontalAlign.CONTENT_JUSTIFY;
            var hAlign = 0;
            if (!hJustify) {
                if (this._horizontalAlign == egret.HorizontalAlign.CENTER) {
                    hAlign = 0.5;
                } else if (this._horizontalAlign == egret.HorizontalAlign.RIGHT) {
                    hAlign = 1;
                }
            }

            var count = this.target.numElements;
            var numElements = count;
            var x = paddingL;
            var y = paddingT;
            var i;
            var layoutElement;

            var totalPreferredHeight = 0;
            var totalPercentHeight = 0;
            var childInfoArray = [];
            var childInfo;
            var heightToDistribute = targetHeight;
            for (i = 0; i < count; i++) {
                layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout) {
                    numElements--;
                    continue;
                }
                this.maxElementWidth = Math.max(this.maxElementWidth, layoutElement.preferredWidth);
                if (vJustify) {
                    totalPreferredHeight += layoutElement.preferredHeight;
                } else {
                    if (!isNaN(layoutElement.percentHeight)) {
                        totalPercentHeight += layoutElement.percentHeight;

                        childInfo = new ChildInfo();
                        childInfo.layoutElement = layoutElement;
                        childInfo.percent = layoutElement.percentHeight;
                        childInfo.min = layoutElement.minHeight;
                        childInfo.max = layoutElement.maxHeight;
                        childInfoArray.push(childInfo);
                    } else {
                        heightToDistribute -= layoutElement.preferredHeight;
                    }
                }
            }

            heightToDistribute -= (numElements - 1) * gap;
            heightToDistribute = heightToDistribute > 0 ? heightToDistribute : 0;
            var excessSpace = targetHeight - totalPreferredHeight - gap * (numElements - 1);

            var averageHeight;
            var largeChildrenCount = numElements;
            var heightDic = [];
            if (vJustify) {
                if (excessSpace < 0) {
                    averageHeight = heightToDistribute / numElements;
                    for (i = 0; i < count; i++) {
                        layoutElement = this.target.getElementAt(i);
                        if (!layoutElement || !layoutElement.includeInLayout)
                            continue;

                        var preferredHeight = layoutElement.preferredHeight;
                        if (preferredHeight <= averageHeight) {
                            heightToDistribute -= preferredHeight;
                            largeChildrenCount--;
                            continue;
                        }
                    }
                    heightToDistribute = heightToDistribute > 0 ? heightToDistribute : 0;
                }
            } else {
                if (totalPercentHeight > 0) {
                    VerticalLayout.flexChildrenProportionally(targetHeight, heightToDistribute, totalPercentHeight, childInfoArray);
                    var roundOff = 0;
                    var length = childInfoArray.length;
                    for (i = 0; i < length; i++) {
                        childInfo = childInfoArray[i];
                        var childSize = Math.round(childInfo.size + roundOff);
                        roundOff += childInfo.size - childSize;

                        heightDic[childInfo.layoutElement.hashCode] = childSize;
                        heightToDistribute -= childSize;
                    }
                    heightToDistribute = heightToDistribute > 0 ? heightToDistribute : 0;
                }
            }

            if (this._verticalAlign == egret.VerticalAlign.MIDDLE) {
                y = paddingT + heightToDistribute * 0.5;
            } else if (this._verticalAlign == egret.VerticalAlign.BOTTOM) {
                y = paddingT + heightToDistribute;
            }

            //开始对所有元素布局
            var maxX = paddingL;
            var maxY = paddingT;
            var dx = 0;
            var dy = 0;
            var justifyWidth = Math.ceil(targetWidth);
            if (this._horizontalAlign == egret.HorizontalAlign.CONTENT_JUSTIFY)
                justifyWidth = Math.ceil(Math.max(targetWidth, this.maxElementWidth));
            roundOff = 0;
            var layoutElementHeight = NaN;
            var childHeight;
            for (i = 0; i < count; i++) {
                var exceesWidth = 0;
                layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout)
                    continue;
                layoutElementHeight = NaN;
                if (vJustify) {
                    childHeight = NaN;
                    if (excessSpace > 0) {
                        childHeight = heightToDistribute * layoutElement.preferredHeight / totalPreferredHeight;
                    } else if (excessSpace < 0 && layoutElement.preferredHeight > averageHeight) {
                        childHeight = heightToDistribute / largeChildrenCount;
                    }
                    if (!isNaN(childHeight)) {
                        layoutElementHeight = Math.round(childHeight + roundOff);
                        roundOff += childHeight - layoutElementHeight;
                    }
                } else {
                    layoutElementHeight = heightDic[layoutElement.hashCode];
                }
                if (hJustify) {
                    x = paddingL;
                    layoutElement.setLayoutBoundsSize(justifyWidth, layoutElementHeight);
                } else {
                    var layoutElementWidth = NaN;
                    if (!isNaN(layoutElement.percentWidth)) {
                        var percent = Math.min(100, layoutElement.percentWidth);
                        layoutElementWidth = Math.round(targetWidth * percent * 0.01);
                    }
                    layoutElement.setLayoutBoundsSize(layoutElementWidth, layoutElementHeight);
                    exceesWidth = (targetWidth - layoutElement.layoutBoundsWidth) * hAlign;
                    exceesWidth = exceesWidth > 0 ? exceesWidth : 0;
                    x = paddingL + exceesWidth;
                }
                layoutElement.setLayoutBoundsPosition(Math.round(x), Math.round(y));
                dx = Math.ceil(layoutElement.layoutBoundsWidth);
                dy = Math.ceil(layoutElement.layoutBoundsHeight);
                maxX = Math.max(maxX, x + dx);
                maxY = Math.max(maxY, y + dy);
                y += dy + gap;
            }
            this.target.setContentSize(Math.ceil(maxX + paddingR), Math.ceil(maxY + paddingB));
        };

        /**
        * 为每个可变尺寸的子项分配空白区域
        * @method egret.VerticalLayout.flexChildrenProportionally
        * @param spaceForChildren {number}
        * @param spaceToDistribute {number}
        * @param totalPercent {number}
        * @param childInfoArray {Array<any>}
        */
        VerticalLayout.flexChildrenProportionally = function (spaceForChildren, spaceToDistribute, totalPercent, childInfoArray) {
            var numChildren = childInfoArray.length;
            var done;

            do {
                done = true;

                var unused = spaceToDistribute - (spaceForChildren * totalPercent / 100);
                if (unused > 0)
                    spaceToDistribute -= unused;
                else
                    unused = 0;

                var spacePerPercent = spaceToDistribute / totalPercent;

                for (var i = 0; i < numChildren; i++) {
                    var childInfo = childInfoArray[i];

                    var size = childInfo.percent * spacePerPercent;

                    if (size < childInfo.min) {
                        var min = childInfo.min;
                        childInfo.size = min;

                        childInfoArray[i] = childInfoArray[--numChildren];
                        childInfoArray[numChildren] = childInfo;

                        totalPercent -= childInfo.percent;
                        if (unused >= min) {
                            unused -= min;
                        } else {
                            spaceToDistribute -= min - unused;
                            unused = 0;
                        }
                        done = false;
                        break;
                    } else if (size > childInfo.max) {
                        var max = childInfo.max;
                        childInfo.size = max;

                        childInfoArray[i] = childInfoArray[--numChildren];
                        childInfoArray[numChildren] = childInfo;

                        totalPercent -= childInfo.percent;
                        if (unused >= max) {
                            unused -= max;
                        } else {
                            spaceToDistribute -= max - unused;
                            unused = 0;
                        }
                        done = false;
                        break;
                    } else {
                        childInfo.size = size;
                    }
                }
            } while(!done);
        };
        return VerticalLayout;
    })(egret.LayoutBase);
    egret.VerticalLayout = VerticalLayout;

    var ChildInfo = (function () {
        function ChildInfo() {
            /**
            * @member egret.ChildInfo#size
            */
            this.size = 0;
        }
        return ChildInfo;
    })();
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.HorizontalLayout
    * @classdesc
    * 水平布局
    * @extends egret.LayoutBase
    */
    var HorizontalLayout = (function (_super) {
        __extends(HorizontalLayout, _super);
        /**
        * @method egret.HorizontalLayout#constructor
        */
        function HorizontalLayout() {
            _super.call(this);
            this._horizontalAlign = egret.HorizontalAlign.LEFT;
            this._verticalAlign = egret.VerticalAlign.TOP;
            this._gap = 6;
            this._padding = 0;
            this._paddingLeft = NaN;
            this._paddingRight = NaN;
            this._paddingTop = NaN;
            this._paddingBottom = NaN;
            /**
            * 虚拟布局使用的子对象尺寸缓存
            */
            this.elementSizeTable = [];
            /**
            * 虚拟布局使用的当前视图中的第一个元素索引
            */
            this.startIndex = -1;
            /**
            * 虚拟布局使用的当前视图中的最后一个元素的索引
            */
            this.endIndex = -1;
            /**
            * 视图的第一个和最后一个元素的索引值已经计算好的标志
            */
            this.indexInViewCalculated = false;
            /**
            * 子对象最大宽度
            */
            this.maxElementHeight = 0;
        }
        Object.defineProperty(HorizontalLayout.prototype, "horizontalAlign", {
            /**
            * 布局元素的水平对齐策略。参考HorizontalAlign定义的常量。
            * 注意：此属性设置为CONTENT_JUSTIFY始终无效。当useVirtualLayout为true时，设置JUSTIFY也无效。
            * @member egret.HorizontalLayout#horizontalAlign
            */
            get: function () {
                return this._horizontalAlign;
            },
            set: function (value) {
                if (this._horizontalAlign == value)
                    return;
                this._horizontalAlign = value;
                if (this.target)
                    this.target.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(HorizontalLayout.prototype, "verticalAlign", {
            /**
            * 布局元素的竖直对齐策略。参考VerticalAlign定义的常量。
            * @member egret.HorizontalLayout#verticalAlign
            */
            get: function () {
                return this._verticalAlign;
            },
            set: function (value) {
                if (this._verticalAlign == value)
                    return;
                this._verticalAlign = value;
                if (this.target)
                    this.target.invalidateDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(HorizontalLayout.prototype, "gap", {
            /**
            * 布局元素之间的水平空间（以像素为单位）
            * @member egret.HorizontalLayout#gap
            */
            get: function () {
                return this._gap;
            },
            set: function (value) {
                if (this._gap == value)
                    return;
                this._gap = value;
                this.invalidateTargetSizeAndDisplayList();
                if (this.hasEventListener("gapChanged"))
                    this.dispatchEventWith("gapChanged");
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(HorizontalLayout.prototype, "padding", {
            /**
            * 四个边缘的共同内边距。若单独设置了任一边缘的内边距，则该边缘的内边距以单独设置的值为准。
            * 此属性主要用于快速设置多个边缘的相同内边距。默认值：0。
            * @member egret.HorizontalLayout#padding
            */
            get: function () {
                return this._padding;
            },
            set: function (value) {
                if (this._padding == value)
                    return;
                this._padding = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(HorizontalLayout.prototype, "paddingLeft", {
            /**
            * 容器的左边缘与布局元素的左边缘之间的最少像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.HorizontalLayout#paddingLeft
            */
            get: function () {
                return this._paddingLeft;
            },
            set: function (value) {
                if (this._paddingLeft == value)
                    return;

                this._paddingLeft = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(HorizontalLayout.prototype, "paddingRight", {
            /**
            * 容器的右边缘与布局元素的右边缘之间的最少像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.HorizontalLayout#paddingRight
            */
            get: function () {
                return this._paddingRight;
            },
            set: function (value) {
                if (this._paddingRight == value)
                    return;

                this._paddingRight = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(HorizontalLayout.prototype, "paddingTop", {
            /**
            * 容器的顶边缘与第一个布局元素的顶边缘之间的像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.HorizontalLayout#paddingTop
            */
            get: function () {
                return this._paddingTop;
            },
            set: function (value) {
                if (this._paddingTop == value)
                    return;

                this._paddingTop = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(HorizontalLayout.prototype, "paddingBottom", {
            /**
            * 容器的底边缘与最后一个布局元素的底边缘之间的像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.HorizontalLayout#paddingBottom
            */
            get: function () {
                return this._paddingBottom;
            },
            set: function (value) {
                if (this._paddingBottom == value)
                    return;

                this._paddingBottom = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 标记目标容器的尺寸和显示列表失效
        */
        HorizontalLayout.prototype.invalidateTargetSizeAndDisplayList = function () {
            if (this.target) {
                this.target.invalidateSize();
                this.target.invalidateDisplayList();
            }
        };

        /**
        * @method egret.HorizontalLayout#measure
        */
        HorizontalLayout.prototype.measure = function () {
            _super.prototype.measure.call(this);
            if (!this.target)
                return;
            if (this.useVirtualLayout) {
                this.measureVirtual();
            } else {
                this.measureReal();
            }
        };

        /**
        * 测量使用虚拟布局的尺寸
        */
        HorizontalLayout.prototype.measureVirtual = function () {
            var numElements = this.target.numElements;
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            var measuredWidth = this.getElementTotalSize();
            var measuredHeight = Math.max(this.maxElementHeight, typicalHeight);

            var visibleIndices = this.target.getElementIndicesInView();
            var length = visibleIndices.length;
            for (var i = 0; i < length; i++) {
                var index = visibleIndices[i];
                var layoutElement = (this.target.getElementAt(index));
                if (layoutElement == null || !layoutElement.includeInLayout)
                    continue;

                var preferredWidth = layoutElement.preferredWidth;
                var preferredHeight = layoutElement.preferredHeight;
                measuredWidth += preferredWidth;
                measuredWidth -= isNaN(this.elementSizeTable[index]) ? typicalWidth : this.elementSizeTable[index];
                measuredHeight = Math.max(measuredHeight, preferredHeight);
            }
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            var hPadding = paddingL + paddingR;
            var vPadding = paddingT + paddingB;
            this.target.measuredWidth = Math.ceil(measuredWidth + hPadding);
            this.target.measuredHeight = Math.ceil(measuredHeight + vPadding);
        };

        /**
        * 测量使用真实布局的尺寸
        */
        HorizontalLayout.prototype.measureReal = function () {
            var count = this.target.numElements;
            var numElements = count;
            var measuredWidth = 0;
            var measuredHeight = 0;
            for (var i = 0; i < count; i++) {
                var layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout) {
                    numElements--;
                    continue;
                }
                var preferredWidth = layoutElement.preferredWidth;
                var preferredHeight = layoutElement.preferredHeight;
                measuredWidth += preferredWidth;
                measuredHeight = Math.max(measuredHeight, preferredHeight);
            }
            var gap = isNaN(this._gap) ? 0 : this._gap;
            measuredWidth += (numElements - 1) * gap;
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var hPadding = paddingL + paddingR;
            var vPadding = paddingT + paddingB;
            this.target.measuredWidth = Math.ceil(measuredWidth + hPadding);
            this.target.measuredHeight = Math.ceil(measuredHeight + vPadding);
        };

        /**
        * @method egret.HorizontalLayout#updateDisplayList
        * @param width {number}
        * @param height {number}
        */
        HorizontalLayout.prototype.updateDisplayList = function (width, height) {
            _super.prototype.updateDisplayList.call(this, width, height);
            if (!this.target)
                return;
            if (this.useVirtualLayout) {
                this.updateDisplayListVirtual(width, height);
            } else {
                this.updateDisplayListReal(width, height);
            }
        };

        /**
        * 获取指定索引的起始位置
        */
        HorizontalLayout.prototype.getStartPosition = function (index) {
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            if (!this.useVirtualLayout) {
                var element;
                if (this.target) {
                    element = this.target.getElementAt(index);
                }
                return element ? element.x : paddingL;
            }
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            var startPos = paddingL;
            for (var i = 0; i < index; i++) {
                var eltWidth = this.elementSizeTable[i];
                if (isNaN(eltWidth)) {
                    eltWidth = typicalWidth;
                }
                startPos += eltWidth + gap;
            }
            return startPos;
        };

        /**
        * 获取指定索引的元素尺寸
        */
        HorizontalLayout.prototype.getElementSize = function (index) {
            if (this.useVirtualLayout) {
                var size = this.elementSizeTable[index];
                if (isNaN(size)) {
                    size = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
                }
                return size;
            }
            if (this.target) {
                return this.target.getElementAt(index).width;
            }
            return 0;
        };

        /**
        * 获取缓存的子对象尺寸总和
        */
        HorizontalLayout.prototype.getElementTotalSize = function () {
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            var totalSize = 0;
            var length = this.target.numElements;
            for (var i = 0; i < length; i++) {
                var eltWidth = this.elementSizeTable[i];
                if (isNaN(eltWidth)) {
                    eltWidth = typicalWidth;
                }
                totalSize += eltWidth + gap;
            }
            totalSize -= gap;
            return totalSize;
        };

        /**
        * @method egret.HorizontalLayout#elementAdded
        * @param index {number}
        */
        HorizontalLayout.prototype.elementAdded = function (index) {
            if (!this.useVirtualLayout)
                return;
            _super.prototype.elementAdded.call(this, index);
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            this.elementSizeTable.splice(index, 0, typicalWidth);
        };

        /**
        * @method egret.HorizontalLayout#elementRemoved
        * @param index {number}
        */
        HorizontalLayout.prototype.elementRemoved = function (index) {
            if (!this.useVirtualLayout)
                return;
            _super.prototype.elementRemoved.call(this, index);
            this.elementSizeTable.splice(index, 1);
        };

        /**
        * @method egret.HorizontalLayout#clearVirtualLayoutCache
        */
        HorizontalLayout.prototype.clearVirtualLayoutCache = function () {
            if (!this.useVirtualLayout)
                return;
            _super.prototype.clearVirtualLayoutCache.call(this);
            this.elementSizeTable = [];
            this.maxElementHeight = 0;
        };

        /**
        * 折半查找法寻找指定位置的显示对象索引
        */
        HorizontalLayout.prototype.findIndexAt = function (x, i0, i1) {
            var index = Math.floor((i0 + i1) * 0.5);
            var elementX = this.getStartPosition(index);
            var elementWidth = this.getElementSize(index);
            var gap = isNaN(this._gap) ? 0 : this._gap;
            if ((x >= elementX) && (x < elementX + elementWidth + gap))
                return index;
            else if (i0 == i1)
                return -1;
            else if (x < elementX)
                return this.findIndexAt(x, i0, Math.max(i0, index - 1));
            else
                return this.findIndexAt(x, Math.min(index + 1, i1), i1);
        };

        /**
        * @method egret.HorizontalLayout#scrollPositionChanged
        */
        HorizontalLayout.prototype.scrollPositionChanged = function () {
            _super.prototype.scrollPositionChanged.call(this);
            if (this.useVirtualLayout) {
                var changed = this.getIndexInView();
                if (changed) {
                    this.indexInViewCalculated = true;
                    this.target.invalidateDisplayList();
                }
            }
        };

        /**
        * 获取视图中第一个和最后一个元素的索引,返回是否发生改变
        */
        HorizontalLayout.prototype.getIndexInView = function () {
            if (!this.target || this.target.numElements == 0) {
                this.startIndex = this.endIndex = -1;
                return false;
            }

            if (isNaN(this.target.width) || this.target.width == 0 || isNaN(this.target.height) || this.target.height == 0) {
                this.startIndex = this.endIndex = -1;
                return false;
            }

            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            var numElements = this.target.numElements;
            var contentWidth = this.getStartPosition(numElements - 1) + this.elementSizeTable[numElements - 1] + paddingR;
            var minVisibleX = this.target.horizontalScrollPosition;
            if (minVisibleX > contentWidth - paddingR) {
                this.startIndex = -1;
                this.endIndex = -1;
                return false;
            }
            var maxVisibleX = this.target.horizontalScrollPosition + this.target.width;
            if (maxVisibleX < paddingL) {
                this.startIndex = -1;
                this.endIndex = -1;
                return false;
            }
            var oldStartIndex = this.startIndex;
            var oldEndIndex = this.endIndex;
            this.startIndex = this.findIndexAt(minVisibleX, 0, numElements - 1);
            if (this.startIndex == -1)
                this.startIndex = 0;
            this.endIndex = this.findIndexAt(maxVisibleX, 0, numElements - 1);
            if (this.endIndex == -1)
                this.endIndex = numElements - 1;
            return oldStartIndex != this.startIndex || oldEndIndex != this.endIndex;
        };

        /**
        * 更新使用虚拟布局的显示列表
        */
        HorizontalLayout.prototype.updateDisplayListVirtual = function (width, height) {
            if (this.indexInViewCalculated)
                this.indexInViewCalculated = false;
            else
                this.getIndexInView();
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            var contentWidth;
            var numElements = this.target.numElements;
            if (this.startIndex == -1 || this.endIndex == -1) {
                contentWidth = this.getStartPosition(numElements) - gap + paddingR;
                this.target.setContentSize(Math.ceil(contentWidth), this.target.contentHeight);
                return;
            }
            this.target.setVirtualElementIndicesInView(this.startIndex, this.endIndex);

            //获取垂直布局参数
            var justify = this._verticalAlign == egret.VerticalAlign.JUSTIFY || this._verticalAlign == egret.VerticalAlign.CONTENT_JUSTIFY;
            var contentJustify = this._verticalAlign == egret.VerticalAlign.CONTENT_JUSTIFY;
            var vAlign = 0;
            if (!justify) {
                if (this._verticalAlign == egret.VerticalAlign.MIDDLE) {
                    vAlign = 0.5;
                } else if (this._verticalAlign == egret.VerticalAlign.BOTTOM) {
                    vAlign = 1;
                }
            }

            var targetHeight = Math.max(0, height - paddingT - paddingB);
            var justifyHeight = Math.ceil(targetHeight);
            var layoutElement;
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 71;
            var oldMaxH = Math.max(typicalHeight, this.maxElementHeight);
            if (contentJustify) {
                for (var index = this.startIndex; index <= this.endIndex; index++) {
                    layoutElement = (this.target.getVirtualElementAt(index));
                    if (!layoutElement || !layoutElement.includeInLayout)
                        continue;
                    this.maxElementHeight = Math.max(this.maxElementHeight, layoutElement.preferredHeight);
                }
                justifyHeight = Math.ceil(Math.max(targetHeight, this.maxElementHeight));
            }
            var x = 0;
            var y = 0;
            var contentHeight = 0;
            var oldElementSize;
            var needInvalidateSize = false;

            for (var i = this.startIndex; i <= this.endIndex; i++) {
                var exceesHeight = 0;
                layoutElement = (this.target.getVirtualElementAt(i));
                if (!layoutElement) {
                    continue;
                } else if (!layoutElement.includeInLayout) {
                    this.elementSizeTable[i] = 0;
                    continue;
                }
                if (justify) {
                    y = paddingT;
                    layoutElement.setLayoutBoundsSize(NaN, justifyHeight);
                } else {
                    exceesHeight = (targetHeight - layoutElement.layoutBoundsHeight) * vAlign;
                    exceesHeight = exceesHeight > 0 ? exceesHeight : 0;
                    y = paddingT + exceesHeight;
                }
                if (!contentJustify)
                    this.maxElementHeight = Math.max(this.maxElementHeight, layoutElement.preferredHeight);
                contentHeight = Math.max(contentHeight, layoutElement.layoutBoundsHeight);
                if (!needInvalidateSize) {
                    oldElementSize = isNaN(this.elementSizeTable[i]) ? typicalWidth : this.elementSizeTable[i];
                    if (oldElementSize != layoutElement.layoutBoundsWidth)
                        needInvalidateSize = true;
                }
                if (i == 0 && this.elementSizeTable.length > 0 && this.elementSizeTable[i] != layoutElement.layoutBoundsWidth)
                    this.typicalLayoutRect = null;
                this.elementSizeTable[i] = layoutElement.layoutBoundsWidth;
                x = this.getStartPosition(i);
                layoutElement.setLayoutBoundsPosition(Math.round(x), Math.round(y));
            }

            contentHeight += paddingT + paddingB;
            contentWidth = this.getStartPosition(numElements) - gap + paddingR;
            this.target.setContentSize(Math.ceil(contentWidth), Math.ceil(contentHeight));
            if (needInvalidateSize || oldMaxH < this.maxElementHeight) {
                this.target.invalidateSize();
            }
        };

        /**
        * 更新使用真实布局的显示列表
        */
        HorizontalLayout.prototype.updateDisplayListReal = function (width, height) {
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var gap = isNaN(this._gap) ? 0 : this._gap;
            var targetWidth = Math.max(0, width - paddingL - paddingR);
            var targetHeight = Math.max(0, height - paddingT - paddingB);

            var hJustify = this._horizontalAlign == egret.HorizontalAlign.JUSTIFY;
            var vJustify = this._verticalAlign == egret.VerticalAlign.JUSTIFY || this._verticalAlign == egret.VerticalAlign.CONTENT_JUSTIFY;
            var vAlign = 0;
            if (!vJustify) {
                if (this._verticalAlign == egret.VerticalAlign.MIDDLE) {
                    vAlign = 0.5;
                } else if (this._verticalAlign == egret.VerticalAlign.BOTTOM) {
                    vAlign = 1;
                }
            }

            var count = this.target.numElements;
            var numElements = count;
            var x = paddingL;
            var y = paddingT;
            var i;
            var layoutElement;

            var totalPreferredWidth = 0;
            var totalPercentWidth = 0;
            var childInfoArray = [];
            var childInfo;
            var widthToDistribute = targetWidth;
            for (i = 0; i < count; i++) {
                layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout) {
                    numElements--;
                    continue;
                }
                this.maxElementHeight = Math.max(this.maxElementHeight, layoutElement.preferredHeight);
                if (hJustify) {
                    totalPreferredWidth += layoutElement.preferredWidth;
                } else {
                    if (!isNaN(layoutElement.percentWidth)) {
                        totalPercentWidth += layoutElement.percentWidth;

                        childInfo = new ChildInfo();
                        childInfo.layoutElement = layoutElement;
                        childInfo.percent = layoutElement.percentWidth;
                        childInfo.min = layoutElement.minWidth;
                        childInfo.max = layoutElement.maxWidth;
                        childInfoArray.push(childInfo);
                    } else {
                        widthToDistribute -= layoutElement.preferredWidth;
                    }
                }
            }
            widthToDistribute -= gap * (numElements - 1);
            widthToDistribute = widthToDistribute > 0 ? widthToDistribute : 0;
            var excessSpace = targetWidth - totalPreferredWidth - gap * (numElements - 1);

            var averageWidth;
            var largeChildrenCount = numElements;
            var widthDic = [];
            if (hJustify) {
                if (excessSpace < 0) {
                    averageWidth = widthToDistribute / numElements;
                    for (i = 0; i < count; i++) {
                        layoutElement = this.target.getElementAt(i);
                        if (!layoutElement || !layoutElement.includeInLayout)
                            continue;

                        var preferredWidth = layoutElement.preferredWidth;
                        if (preferredWidth <= averageWidth) {
                            widthToDistribute -= preferredWidth;
                            largeChildrenCount--;
                            continue;
                        }
                    }
                    widthToDistribute = widthToDistribute > 0 ? widthToDistribute : 0;
                }
            } else {
                if (totalPercentWidth > 0) {
                    HorizontalLayout.flexChildrenProportionally(targetWidth, widthToDistribute, totalPercentWidth, childInfoArray);
                    var roundOff = 0;
                    var length = childInfoArray.length;
                    for (i = 0; i < length; i++) {
                        childInfo = childInfoArray[i];
                        var childSize = Math.round(childInfo.size + roundOff);
                        roundOff += childInfo.size - childSize;

                        widthDic[childInfo.layoutElement.hashCode] = childSize;
                        widthToDistribute -= childSize;
                    }
                    widthToDistribute = widthToDistribute > 0 ? widthToDistribute : 0;
                }
            }

            if (this._horizontalAlign == egret.HorizontalAlign.CENTER) {
                x = paddingL + widthToDistribute * 0.5;
            } else if (this._horizontalAlign == egret.HorizontalAlign.RIGHT) {
                x = paddingL + widthToDistribute;
            }

            var maxX = paddingL;
            var maxY = paddingT;
            var dx = 0;
            var dy = 0;
            var justifyHeight = Math.ceil(targetHeight);
            if (this._verticalAlign == egret.VerticalAlign.CONTENT_JUSTIFY)
                justifyHeight = Math.ceil(Math.max(targetHeight, this.maxElementHeight));
            roundOff = 0;
            var layoutElementWidth;
            var childWidth;
            for (i = 0; i < count; i++) {
                var exceesHeight = 0;
                layoutElement = (this.target.getElementAt(i));
                if (!layoutElement || !layoutElement.includeInLayout)
                    continue;
                layoutElementWidth = NaN;
                if (hJustify) {
                    childWidth = NaN;
                    if (excessSpace > 0) {
                        childWidth = widthToDistribute * layoutElement.preferredWidth / totalPreferredWidth;
                    } else if (excessSpace < 0 && layoutElement.preferredWidth > averageWidth) {
                        childWidth = widthToDistribute / largeChildrenCount;
                    }
                    if (!isNaN(childWidth)) {
                        layoutElementWidth = Math.round(childWidth + roundOff);
                        roundOff += childWidth - layoutElementWidth;
                    }
                } else {
                    layoutElementWidth = widthDic[layoutElement.hashCode];
                }
                if (vJustify) {
                    y = paddingT;
                    layoutElement.setLayoutBoundsSize(layoutElementWidth, justifyHeight);
                } else {
                    var layoutElementHeight = NaN;
                    if (!isNaN(layoutElement.percentHeight)) {
                        var percent = Math.min(100, layoutElement.percentHeight);
                        layoutElementHeight = Math.round(targetHeight * percent * 0.01);
                    }
                    layoutElement.setLayoutBoundsSize(layoutElementWidth, layoutElementHeight);
                    exceesHeight = (targetHeight - layoutElement.layoutBoundsHeight) * vAlign;
                    exceesHeight = exceesHeight > 0 ? exceesHeight : 0;
                    y = paddingT + exceesHeight;
                }
                layoutElement.setLayoutBoundsPosition(Math.round(x), Math.round(y));
                dx = Math.ceil(layoutElement.layoutBoundsWidth);
                dy = Math.ceil(layoutElement.layoutBoundsHeight);
                maxX = Math.max(maxX, x + dx);
                maxY = Math.max(maxY, y + dy);
                x += dx + gap;
            }
            this.target.setContentSize(Math.ceil(maxX + paddingR), Math.ceil(maxY + paddingB));
        };

        /**
        * 为每个可变尺寸的子项分配空白区域
        * @method egret.HorizontalLayout.flexChildrenProportionally
        * @param spaceForChildren {number}
        * @param spaceToDistribute {number}
        * @param totalPercent {number}
        * @param childInfoArray {Array<any>}
        */
        HorizontalLayout.flexChildrenProportionally = function (spaceForChildren, spaceToDistribute, totalPercent, childInfoArray) {
            var numChildren = childInfoArray.length;
            var done;

            do {
                done = true;

                var unused = spaceToDistribute - (spaceForChildren * totalPercent / 100);
                if (unused > 0)
                    spaceToDistribute -= unused;
                else
                    unused = 0;

                var spacePerPercent = spaceToDistribute / totalPercent;

                for (var i = 0; i < numChildren; i++) {
                    var childInfo = childInfoArray[i];

                    var size = childInfo.percent * spacePerPercent;

                    if (size < childInfo.min) {
                        var min = childInfo.min;
                        childInfo.size = min;

                        childInfoArray[i] = childInfoArray[--numChildren];
                        childInfoArray[numChildren] = childInfo;

                        totalPercent -= childInfo.percent;
                        if (unused >= min) {
                            unused -= min;
                        } else {
                            spaceToDistribute -= min - unused;
                            unused = 0;
                        }
                        done = false;
                        break;
                    } else if (size > childInfo.max) {
                        var max = childInfo.max;
                        childInfo.size = max;

                        childInfoArray[i] = childInfoArray[--numChildren];
                        childInfoArray[numChildren] = childInfo;

                        totalPercent -= childInfo.percent;
                        if (unused >= max) {
                            unused -= max;
                        } else {
                            spaceToDistribute -= max - unused;
                            unused = 0;
                        }
                        done = false;
                        break;
                    } else {
                        childInfo.size = size;
                    }
                }
            } while(!done);
        };
        return HorizontalLayout;
    })(egret.LayoutBase);
    egret.HorizontalLayout = HorizontalLayout;

    var ChildInfo = (function () {
        function ChildInfo() {
            /**
            * @member egret.ChildInfo#size
            */
            this.size = 0;
        }
        return ChildInfo;
    })();
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.TileLayout
    * @classdesc
    * 格子布局
    * @extends egret.LayoutBase
    */
    var TileLayout = (function (_super) {
        __extends(TileLayout, _super);
        /**
        * 构造函数
        * @method egret.TileLayout#constructor
        */
        function TileLayout() {
            _super.call(this);
            /**
            * 标记horizontalGap被显式指定过
            */
            this.explicitHorizontalGap = NaN;
            this._horizontalGap = 6;
            /**
            * 标记verticalGap被显式指定过
            */
            this.explicitVerticalGap = NaN;
            this._verticalGap = 6;
            this._columnCount = -1;
            this._requestedColumnCount = 0;
            this._rowCount = -1;
            this._requestedRowCount = 0;
            /**
            * 外部显式指定的列宽
            */
            this.explicitColumnWidth = NaN;
            this._columnWidth = NaN;
            /**
            * 外部显式指定的行高
            */
            this.explicitRowHeight = NaN;
            this._rowHeight = NaN;
            this._padding = 0;
            this._paddingLeft = NaN;
            this._paddingRight = NaN;
            this._paddingTop = NaN;
            this._paddingBottom = NaN;
            this._horizontalAlign = egret.HorizontalAlign.JUSTIFY;
            this._verticalAlign = egret.VerticalAlign.JUSTIFY;
            this._columnAlign = egret.ColumnAlign.LEFT;
            this._rowAlign = egret.RowAlign.TOP;
            this._orientation = egret.TileOrientation.ROWS;
            /**
            * 缓存的最大子对象宽度
            */
            this.maxElementWidth = 0;
            /**
            * 缓存的最大子对象高度
            */
            this.maxElementHeight = 0;
            /**
            * 当前视图中的第一个元素索引
            */
            this.startIndex = -1;
            /**
            * 当前视图中的最后一个元素的索引
            */
            this.endIndex = -1;
            /**
            * 视图的第一个和最后一个元素的索引值已经计算好的标志
            */
            this.indexInViewCalculated = false;
        }
        Object.defineProperty(TileLayout.prototype, "horizontalGap", {
            /**
            * 列之间的水平空间（以像素为单位）。
            * @member egret.TileLayout#horizontalGap
            */
            get: function () {
                return this._horizontalGap;
            },
            set: function (value) {
                if (value == this._horizontalGap)
                    return;
                this.explicitHorizontalGap = value;

                this._horizontalGap = value;
                this.invalidateTargetSizeAndDisplayList();
                if (this.hasEventListener("gapChanged"))
                    this.dispatchEventWith("gapChanged");
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "verticalGap", {
            /**
            * 行之间的垂直空间（以像素为单位）。
            * @member egret.TileLayout#verticalGap
            */
            get: function () {
                return this._verticalGap;
            },
            set: function (value) {
                if (value == this._verticalGap)
                    return;
                this.explicitVerticalGap = value;

                this._verticalGap = value;
                this.invalidateTargetSizeAndDisplayList();
                if (this.hasEventListener("gapChanged"))
                    this.dispatchEventWith("gapChanged");
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "columnCount", {
            /**
            * 实际列计数。
            * @member egret.TileLayout#columnCount
            */
            get: function () {
                return this._columnCount;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TileLayout.prototype, "requestedColumnCount", {
            /**
            * 要显示的列数。设置为0表示自动确定列计数,默认值0。<br/>
            * 注意:当orientation为TileOrientation.COLUMNS(逐列排列元素)且taget被显式设置宽度时，此属性无效。
            * @member egret.TileLayout#requestedColumnCount
            */
            get: function () {
                return this._requestedColumnCount;
            },
            set: function (value) {
                if (this._requestedColumnCount == value)
                    return;
                this._requestedColumnCount = value;
                this._columnCount = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "rowCount", {
            /**
            * 实际行计数。
            * @member egret.TileLayout#rowCount
            */
            get: function () {
                return this._rowCount;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TileLayout.prototype, "requestedRowCount", {
            /**
            * 要显示的行数。设置为0表示自动确定行计数,默认值0。<br/>
            * 注意:当orientation为TileOrientation.ROWS(即逐行排列元素,此为默认值)且target被显式设置高度时，此属性无效。
            * @member egret.TileLayout#requestedRowCount
            */
            get: function () {
                return this._requestedRowCount;
            },
            set: function (value) {
                if (this._requestedRowCount == value)
                    return;
                this._requestedRowCount = value;
                this._rowCount = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "columnWidth", {
            /**
            * 实际列宽（以像素为单位）。 若未显式设置，则从根据最宽的元素的宽度确定列宽度。
            * @member egret.TileLayout#columnWidth
            */
            get: function () {
                return this._columnWidth;
            },
            /**
            *  @private
            */
            set: function (value) {
                if (value == this._columnWidth)
                    return;
                this.explicitColumnWidth = value;
                this._columnWidth = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "rowHeight", {
            /**
            * 行高（以像素为单位）。 如果未显式设置，则从元素的高度的最大值确定行高度。
            * @member egret.TileLayout#rowHeight
            */
            get: function () {
                return this._rowHeight;
            },
            /**
            *  @private
            */
            set: function (value) {
                if (value == this._rowHeight)
                    return;
                this.explicitRowHeight = value;
                this._rowHeight = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "padding", {
            /**
            * 四个边缘的共同内边距。若单独设置了任一边缘的内边距，则该边缘的内边距以单独设置的值为准。
            * 此属性主要用于快速设置多个边缘的相同内边距。默认值：0。
            * @member egret.TileLayout#padding
            */
            get: function () {
                return this._padding;
            },
            set: function (value) {
                if (this._padding == value)
                    return;
                this._padding = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(TileLayout.prototype, "paddingLeft", {
            /**
            * 容器的左边缘与布局元素的左边缘之间的最少像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.TileLayout#paddingLeft
            */
            get: function () {
                return this._paddingLeft;
            },
            set: function (value) {
                if (this._paddingLeft == value)
                    return;

                this._paddingLeft = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "paddingRight", {
            /**
            * 容器的右边缘与布局元素的右边缘之间的最少像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.TileLayout#paddingRight
            */
            get: function () {
                return this._paddingRight;
            },
            set: function (value) {
                if (this._paddingRight == value)
                    return;

                this._paddingRight = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "paddingTop", {
            /**
            * 容器的顶边缘与第一个布局元素的顶边缘之间的像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.TileLayout#paddingTop
            */
            get: function () {
                return this._paddingTop;
            },
            set: function (value) {
                if (this._paddingTop == value)
                    return;

                this._paddingTop = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "paddingBottom", {
            /**
            * 容器的底边缘与最后一个布局元素的底边缘之间的像素数,若为NaN将使用padding的值，默认值：NaN。
            * @member egret.TileLayout#paddingBottom
            */
            get: function () {
                return this._paddingBottom;
            },
            set: function (value) {
                if (this._paddingBottom == value)
                    return;

                this._paddingBottom = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "horizontalAlign", {
            /**
            * 指定如何在水平方向上对齐单元格内的元素。
            * 支持的值有 HorizontalAlign.LEFT、HorizontalAlign.CENTER、
            * HorizontalAlign.RIGHT、HorizontalAlign.JUSTIFY。
            * 默认值：HorizontalAlign.JUSTIFY
            * @member egret.TileLayout#horizontalAlign
            */
            get: function () {
                return this._horizontalAlign;
            },
            set: function (value) {
                if (this._horizontalAlign == value)
                    return;

                this._horizontalAlign = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "verticalAlign", {
            /**
            * 指定如何在垂直方向上对齐单元格内的元素。
            * 支持的值有 VerticalAlign.TOP、VerticalAlign.MIDDLE、
            * VerticalAlign.BOTTOM、VerticalAlign.JUSTIFY。
            * 默认值：VerticalAlign.JUSTIFY。
            * @member egret.TileLayout#verticalAlign
            */
            get: function () {
                return this._verticalAlign;
            },
            set: function (value) {
                if (this._verticalAlign == value)
                    return;

                this._verticalAlign = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "columnAlign", {
            /**
            * 指定如何将完全可见列与容器宽度对齐。
            * 设置为 ColumnAlign.LEFT 时，它会关闭列两端对齐。在容器的最后一列和右边缘之间可能存在部分可见的列或空白。这是默认值。
            * 设置为 ColumnAlign.JUSTIFY_USING_GAP 时，horizontalGap 的实际值将增大，
            * 这样最后一个完全可见列右边缘会与容器的右边缘对齐。仅存在一个完全可见列时，
            * horizontalGap 的实际值将增大，这样它会将任何部分可见列推到容器的右边缘之外。
            * 请注意显式设置 horizontalGap 属性不会关闭两端对齐。它仅确定初始间隙值。两端对齐可能会增大它。
            * 设置为 ColumnAlign.JUSTIFY_USING_WIDTH 时，columnWidth 的实际值将增大，
            * 这样最后一个完全可见列右边缘会与容器的右边缘对齐。请注意显式设置 columnWidth 属性不会关闭两端对齐。
            * 它仅确定初始列宽度值。两端对齐可能会增大它。
            * @member egret.TileLayout#columnAlign
            */
            get: function () {
                return this._columnAlign;
            },
            set: function (value) {
                if (this._columnAlign == value)
                    return;

                this._columnAlign = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "rowAlign", {
            /**
            * @member egret.TileLayout#rowAlign
            */
            get: function () {
                return this._rowAlign;
            },
            /**
            * 指定如何将完全可见行与容器高度对齐。
            * 设置为 RowAlign.TOP 时，它会关闭列两端对齐。在容器的最后一行和底边缘之间可能存在部分可见的行或空白。这是默认值。
            *
            * 设置为 RowAlign.JUSTIFY_USING_GAP 时，verticalGap 的实际值会增大，
            * 这样最后一个完全可见行底边缘会与容器的底边缘对齐。仅存在一个完全可见行时，verticalGap 的值会增大，
            * 这样它会将任何部分可见行推到容器的底边缘之外。请注意，显式设置 verticalGap
            * 不会关闭两端对齐，而只是确定初始间隙值。两端对齐接着可以增大它。
            *
            * 设置为 RowAlign.JUSTIFY_USING_HEIGHT 时，rowHeight 的实际值会增大，
            * 这样最后一个完全可见行底边缘会与容器的底边缘对齐。请注意，显式设置 rowHeight
            * 不会关闭两端对齐，而只是确定初始行高度值。两端对齐接着可以增大它。
            */
            set: function (value) {
                if (this._rowAlign == value)
                    return;

                this._rowAlign = value;
                this.invalidateTargetSizeAndDisplayList();
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(TileLayout.prototype, "orientation", {
            /**
            * 指定是逐行还是逐列排列元素。
            * @member egret.TileLayout#orientation
            */
            get: function () {
                return this._orientation;
            },
            set: function (value) {
                if (this._orientation == value)
                    return;

                this._orientation = value;
                this.invalidateTargetSizeAndDisplayList();
                if (this.hasEventListener("orientationChanged"))
                    this.dispatchEventWith("orientationChanged");
            },
            enumerable: true,
            configurable: true
        });


        /**
        * 标记目标容器的尺寸和显示列表失效
        */
        TileLayout.prototype.invalidateTargetSizeAndDisplayList = function () {
            if (this.target) {
                this.target.invalidateSize();
                this.target.invalidateDisplayList();
            }
        };

        /**
        * @method egret.TileLayout#measure
        */
        TileLayout.prototype.measure = function () {
            if (!this.target)
                return;

            var savedColumnCount = this._columnCount;
            var savedRowCount = this._rowCount;
            var savedColumnWidth = this._columnWidth;
            var savedRowHeight = this._rowHeight;

            var measuredWidth = 0;
            var measuredHeight = 0;

            this.calculateRowAndColumn(this.target.explicitWidth, this.target.explicitHeight);
            var columnCount = this._requestedColumnCount > 0 ? this._requestedColumnCount : this._columnCount;
            var rowCount = this._requestedRowCount > 0 ? this._requestedRowCount : this._rowCount;
            var horizontalGap = isNaN(this._horizontalGap) ? 0 : this._horizontalGap;
            var verticalGap = isNaN(this._verticalGap) ? 0 : this._verticalGap;
            if (columnCount > 0) {
                measuredWidth = columnCount * (this._columnWidth + horizontalGap) - horizontalGap;
            }

            if (rowCount > 0) {
                measuredHeight = rowCount * (this._rowHeight + verticalGap) - verticalGap;
            }

            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            var hPadding = paddingL + paddingR;
            var vPadding = paddingT + paddingB;

            this.target.measuredWidth = Math.ceil(measuredWidth + hPadding);
            this.target.measuredHeight = Math.ceil(measuredHeight + vPadding);

            this._columnCount = savedColumnCount;
            this._rowCount = savedRowCount;
            this._columnWidth = savedColumnWidth;
            this._rowHeight = savedRowHeight;
        };

        /**
        * 计算行和列的尺寸及数量
        */
        TileLayout.prototype.calculateRowAndColumn = function (explicitWidth, explicitHeight) {
            var horizontalGap = isNaN(this._horizontalGap) ? 0 : this._horizontalGap;
            var verticalGap = isNaN(this._verticalGap) ? 0 : this._verticalGap;
            this._rowCount = this._columnCount = -1;
            var numElements = this.target.numElements;
            var count = numElements;
            for (var index = 0; index < count; index++) {
                var elt = (this.target.getElementAt(index));
                if (elt && !elt.includeInLayout) {
                    numElements--;
                }
            }
            if (numElements == 0) {
                this._rowCount = this._columnCount = 0;
                return;
            }

            if (isNaN(this.explicitColumnWidth) || isNaN(this.explicitRowHeight))
                this.updateMaxElementSize();

            if (isNaN(this.explicitColumnWidth)) {
                this._columnWidth = this.maxElementWidth;
            } else {
                this._columnWidth = this.explicitColumnWidth;
            }
            if (isNaN(this.explicitRowHeight)) {
                this._rowHeight = this.maxElementHeight;
            } else {
                this._rowHeight = this.explicitRowHeight;
            }

            var itemWidth = this._columnWidth + horizontalGap;

            //防止出现除数为零的情况
            if (itemWidth <= 0)
                itemWidth = 1;
            var itemHeight = this._rowHeight + verticalGap;
            if (itemHeight <= 0)
                itemHeight = 1;

            var orientedByColumns = (this.orientation == egret.TileOrientation.COLUMNS);
            var widthHasSet = !isNaN(explicitWidth);
            var heightHasSet = !isNaN(explicitHeight);

            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            if (this._requestedColumnCount > 0 || this._requestedRowCount > 0) {
                if (this._requestedRowCount > 0)
                    this._rowCount = Math.min(this._requestedRowCount, numElements);

                if (this._requestedColumnCount > 0)
                    this._columnCount = Math.min(this._requestedColumnCount, numElements);
            } else if (!widthHasSet && !heightHasSet) {
                var side = Math.sqrt(numElements * itemWidth * itemHeight);
                if (orientedByColumns) {
                    this._rowCount = Math.max(1, Math.round(side / itemHeight));
                } else {
                    this._columnCount = Math.max(1, Math.round(side / itemWidth));
                }
            } else if (widthHasSet && (!heightHasSet || !orientedByColumns)) {
                var targetWidth = Math.max(0, explicitWidth - paddingL - paddingR);
                this._columnCount = Math.floor((targetWidth + horizontalGap) / itemWidth);
                this._columnCount = Math.max(1, Math.min(this._columnCount, numElements));
            } else {
                var targetHeight = Math.max(0, explicitHeight - paddingT - paddingB);
                this._rowCount = Math.floor((targetHeight + verticalGap) / itemHeight);
                this._rowCount = Math.max(1, Math.min(this._rowCount, numElements));
            }
            if (this._rowCount == -1)
                this._rowCount = Math.max(1, Math.ceil(numElements / this._columnCount));
            if (this._columnCount == -1)
                this._columnCount = Math.max(1, Math.ceil(numElements / this._rowCount));
            if (this._requestedColumnCount > 0 && this._requestedRowCount > 0) {
                if (this.orientation == egret.TileOrientation.ROWS)
                    this._rowCount = Math.max(1, Math.ceil(numElements / this._requestedColumnCount));
                else
                    this._columnCount = Math.max(1, Math.ceil(numElements / this._requestedRowCount));
            }
        };

        /**
        * 更新最大子对象尺寸
        */
        TileLayout.prototype.updateMaxElementSize = function () {
            if (!this.target)
                return;
            if (this.useVirtualLayout)
                this.updateMaxElementSizeVirtual();
            else
                this.updateMaxElementSizeReal();
        };

        /**
        * 更新虚拟布局的最大子对象尺寸
        */
        TileLayout.prototype.updateMaxElementSizeVirtual = function () {
            var typicalHeight = this.typicalLayoutRect ? this.typicalLayoutRect.height : 22;
            var typicalWidth = this.typicalLayoutRect ? this.typicalLayoutRect.width : 22;
            this.maxElementWidth = Math.max(this.maxElementWidth, typicalWidth);
            this.maxElementHeight = Math.max(this.maxElementHeight, typicalHeight);

            if ((this.startIndex != -1) && (this.endIndex != -1)) {
                for (var index = this.startIndex; index <= this.endIndex; index++) {
                    var elt = (this.target.getVirtualElementAt(index));
                    if (!elt || !elt.includeInLayout)
                        continue;
                    this.maxElementWidth = Math.max(this.maxElementWidth, elt.preferredWidth);
                    this.maxElementHeight = Math.max(this.maxElementHeight, elt.preferredHeight);
                }
            }
        };

        /**
        * 更新真实布局的最大子对象尺寸
        */
        TileLayout.prototype.updateMaxElementSizeReal = function () {
            var numElements = this.target.numElements;
            for (var index = 0; index < numElements; index++) {
                var elt = (this.target.getElementAt(index));
                if (!elt || !elt.includeInLayout)
                    continue;
                this.maxElementWidth = Math.max(this.maxElementWidth, elt.preferredWidth);
                this.maxElementHeight = Math.max(this.maxElementHeight, elt.preferredHeight);
            }
        };

        /**
        * @method egret.TileLayout#clearVirtualLayoutCache
        */
        TileLayout.prototype.clearVirtualLayoutCache = function () {
            _super.prototype.clearVirtualLayoutCache.call(this);
            this.maxElementWidth = 0;
            this.maxElementHeight = 0;
        };

        /**
        * @method egret.TileLayout#scrollPositionChanged
        */
        TileLayout.prototype.scrollPositionChanged = function () {
            _super.prototype.scrollPositionChanged.call(this);
            if (this.useVirtualLayout) {
                var changed = this.getIndexInView();
                if (changed) {
                    this.indexInViewCalculated = true;
                    this.target.invalidateDisplayList();
                }
            }
        };

        /**
        * 获取视图中第一个和最后一个元素的索引,返回是否发生改变
        */
        TileLayout.prototype.getIndexInView = function () {
            if (!this.target || this.target.numElements == 0) {
                this.startIndex = this.endIndex = -1;
                return false;
            }

            var numElements = this.target.numElements;
            if (!this.useVirtualLayout) {
                this.startIndex = 0;
                this.endIndex = numElements - 1;
                return false;
            }

            if (isNaN(this.target.width) || this.target.width == 0 || isNaN(this.target.height) || this.target.height == 0) {
                this.startIndex = this.endIndex = -1;
                return false;
            }
            var oldStartIndex = this.startIndex;
            var oldEndIndex = this.endIndex;
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var horizontalGap = isNaN(this._horizontalGap) ? 0 : this._horizontalGap;
            var verticalGap = isNaN(this._verticalGap) ? 0 : this._verticalGap;
            if (this.orientation == egret.TileOrientation.COLUMNS) {
                var itemWidth = this._columnWidth + horizontalGap;
                if (itemWidth <= 0) {
                    this.startIndex = 0;
                    this.endIndex = numElements - 1;
                    return false;
                }
                var minVisibleX = this.target.horizontalScrollPosition;
                var maxVisibleX = this.target.horizontalScrollPosition + this.target.width;
                var startColumn = Math.floor((minVisibleX - paddingL) / itemWidth);
                if (startColumn < 0)
                    startColumn = 0;
                var endColumn = Math.ceil((maxVisibleX - paddingL) / itemWidth);
                if (endColumn < 0)
                    endColumn = 0;
                this.startIndex = Math.min(numElements - 1, Math.max(0, startColumn * this._rowCount));
                this.endIndex = Math.min(numElements - 1, Math.max(0, endColumn * this._rowCount - 1));
            } else {
                var itemHeight = this._rowHeight + verticalGap;
                if (itemHeight <= 0) {
                    this.startIndex = 0;
                    this.endIndex = numElements - 1;
                    return false;
                }
                var minVisibleY = this.target.verticalScrollPosition;
                var maxVisibleY = this.target.verticalScrollPosition + this.target.height;
                var startRow = Math.floor((minVisibleY - paddingT) / itemHeight);
                if (startRow < 0)
                    startRow = 0;
                var endRow = Math.ceil((maxVisibleY - paddingT) / itemHeight);
                if (endRow < 0)
                    endRow = 0;
                this.startIndex = Math.min(numElements - 1, Math.max(0, startRow * this._columnCount));
                this.endIndex = Math.min(numElements - 1, Math.max(0, endRow * this._columnCount - 1));
            }

            return this.startIndex != oldStartIndex || this.endIndex != oldEndIndex;
        };

        /**
        * @method egret.TileLayout#updateDisplayList
        * @param width {number}
        * @param height {number}
        */
        TileLayout.prototype.updateDisplayList = function (width, height) {
            _super.prototype.updateDisplayList.call(this, width, height);
            if (!this.target)
                return;
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;
            var horizontalGap = isNaN(this._horizontalGap) ? 0 : this._horizontalGap;
            var verticalGap = isNaN(this._verticalGap) ? 0 : this._verticalGap;
            if (this.indexInViewCalculated) {
                this.indexInViewCalculated = false;
            } else {
                this.calculateRowAndColumn(width, height);
                if (this._rowCount == 0 || this._columnCount == 0) {
                    this.target.setContentSize(paddingL + paddingR, paddingT + paddingB);
                    return;
                }
                this.adjustForJustify(width, height);
                this.getIndexInView();
            }
            if (this.useVirtualLayout) {
                this.calculateRowAndColumn(width, height);
                this.adjustForJustify(width, height);
            }

            if (this.startIndex == -1 || this.endIndex == -1) {
                this.target.setContentSize(0, 0);
                return;
            }
            this.target.setVirtualElementIndicesInView(this.startIndex, this.endIndex);
            var elt;
            var x;
            var y;
            var columnIndex;
            var rowIndex;
            var orientedByColumns = (this.orientation == egret.TileOrientation.COLUMNS);
            var index = this.startIndex;
            for (var i = this.startIndex; i <= this.endIndex; i++) {
                if (this.useVirtualLayout)
                    elt = (this.target.getVirtualElementAt(i));
                else
                    elt = (this.target.getElementAt(i));
                if (elt == null || !elt.includeInLayout)
                    continue;

                if (orientedByColumns) {
                    columnIndex = Math.ceil((index + 1) / this._rowCount) - 1;
                    rowIndex = Math.ceil((index + 1) % this._rowCount) - 1;
                    if (rowIndex == -1)
                        rowIndex = this._rowCount - 1;
                } else {
                    columnIndex = Math.ceil((index + 1) % this._columnCount) - 1;
                    if (columnIndex == -1)
                        columnIndex = this._columnCount - 1;
                    rowIndex = Math.ceil((index + 1) / this._columnCount) - 1;
                }
                x = columnIndex * (this._columnWidth + horizontalGap) + paddingL;
                y = rowIndex * (this._rowHeight + verticalGap) + paddingT;
                this.sizeAndPositionElement(elt, x, y, this._columnWidth, this.rowHeight);
                index++;
            }

            var hPadding = paddingL + paddingR;
            var vPadding = paddingT + paddingB;
            var contentWidth = (this._columnWidth + horizontalGap) * this._columnCount - horizontalGap;
            var contentHeight = (this._rowHeight + verticalGap) * this._rowCount - verticalGap;
            this.target.setContentSize(Math.ceil(contentWidth + hPadding), Math.ceil(contentHeight + vPadding));
        };

        /**
        * 为单个元素布局
        */
        TileLayout.prototype.sizeAndPositionElement = function (element, cellX, cellY, cellWidth, cellHeight) {
            var elementWidth = NaN;
            var elementHeight = NaN;

            if (this.horizontalAlign == egret.HorizontalAlign.JUSTIFY)
                elementWidth = cellWidth;
            else if (!isNaN(element.percentWidth))
                elementWidth = cellWidth * element.percentWidth * 0.01;

            if (this.verticalAlign == egret.VerticalAlign.JUSTIFY)
                elementHeight = cellHeight;
            else if (!isNaN(element.percentHeight))
                elementHeight = cellHeight * element.percentHeight * 0.01;

            element.setLayoutBoundsSize(Math.round(elementWidth), Math.round(elementHeight));

            var x = cellX;
            switch (this.horizontalAlign) {
                case egret.HorizontalAlign.RIGHT:
                    x += cellWidth - element.layoutBoundsWidth;
                    break;
                case egret.HorizontalAlign.CENTER:
                    x = cellX + (cellWidth - element.layoutBoundsWidth) / 2;
                    break;
            }

            var y = cellY;
            switch (this.verticalAlign) {
                case egret.VerticalAlign.BOTTOM:
                    y += cellHeight - element.layoutBoundsHeight;
                    break;
                case egret.VerticalAlign.MIDDLE:
                    y += (cellHeight - element.layoutBoundsHeight) / 2;
                    break;
            }
            element.setLayoutBoundsPosition(Math.round(x), Math.round(y));
        };

        /**
        * 为两端对齐调整间隔或格子尺寸
        */
        TileLayout.prototype.adjustForJustify = function (width, height) {
            var padding = isNaN(this._padding) ? 0 : this._padding;
            var paddingL = isNaN(this._paddingLeft) ? padding : this._paddingLeft;
            var paddingR = isNaN(this._paddingRight) ? padding : this._paddingRight;
            var paddingT = isNaN(this._paddingTop) ? padding : this._paddingTop;
            var paddingB = isNaN(this._paddingBottom) ? padding : this._paddingBottom;

            var targetWidth = Math.max(0, width - paddingL - paddingR);
            var targetHeight = Math.max(0, height - paddingT - paddingB);
            if (!isNaN(this.explicitVerticalGap))
                this._verticalGap = this.explicitVerticalGap;
            if (!isNaN(this.explicitHorizontalGap))
                this._horizontalGap = this.explicitHorizontalGap;
            this._verticalGap = isNaN(this._verticalGap) ? 0 : this._verticalGap;
            this._horizontalGap = isNaN(this._horizontalGap) ? 0 : this._horizontalGap;

            var itemWidth = this._columnWidth + this._horizontalGap;
            if (itemWidth <= 0)
                itemWidth = 1;
            var itemHeight = this._rowHeight + this._verticalGap;
            if (itemHeight <= 0)
                itemHeight = 1;

            var offsetY = targetHeight - this._rowHeight * this._rowCount;
            var offsetX = targetWidth - this._columnWidth * this._columnCount;
            var gapCount;
            if (offsetY > 0) {
                if (this.rowAlign == egret.RowAlign.JUSTIFY_USING_GAP) {
                    gapCount = Math.max(1, this._rowCount - 1);
                    this._verticalGap = offsetY / gapCount;
                } else if (this.rowAlign == egret.RowAlign.JUSTIFY_USING_HEIGHT) {
                    if (this._rowCount > 0) {
                        this._rowHeight += (offsetY - (this._rowCount - 1) * this._verticalGap) / this._rowCount;
                    }
                }
            }
            if (offsetX > 0) {
                if (this.columnAlign == egret.ColumnAlign.JUSTIFY_USING_GAP) {
                    gapCount = Math.max(1, this._columnCount - 1);
                    this._horizontalGap = offsetX / gapCount;
                } else if (this.columnAlign == egret.ColumnAlign.JUSTIFY_USING_WIDTH) {
                    if (this._columnCount > 0) {
                        this._columnWidth += (offsetX - (this._columnCount - 1) * this._horizontalGap) / this._columnCount;
                    }
                }
            }
        };
        return TileLayout;
    })(egret.LayoutBase);
    egret.TileLayout = TileLayout;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.UILayer
    * @classdesc
    * UIStage的虚拟子容器
    * @implements egret.IContainer
    */
    var UILayer = (function () {
        /**
        * 构造函数
        * @method egret.UILayer#constructor
        * @param owner {IUIStage}
        * @param lowerBoundReference {string}
        * @param upperBoundReference {strin}
        */
        function UILayer(owner, lowerBoundReference, upperBoundReference) {
            this.raw_getElementAt = "raw_getElementAt";
            this.raw_addElementAt = "raw_addElementAt";
            this.raw_getElementIndex = "raw_getElementIndex";
            this.raw_removeElement = "raw_removeElement";
            this.raw_removeElementAt = "raw_removeElementAt";
            this.raw_setElementIndex = "raw_setElementIndex";
            this.owner = owner;
            this.lowerBoundReference = lowerBoundReference;
            this.upperBoundReference = upperBoundReference;
        }
        Object.defineProperty(UILayer.prototype, "numElements", {
            /**
            * @member egret.UILayer#numElements
            */
            get: function () {
                return this.owner[this.upperBoundReference] - this.owner[this.lowerBoundReference];
            },
            enumerable: true,
            configurable: true
        });

        /**
        * @method egret.UILayer#getElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        UILayer.prototype.getElementAt = function (index) {
            var retval = this.owner[this.raw_getElementAt](this.owner[this.lowerBoundReference] + index);
            return retval;
        };

        /**
        * @method egret.UILayer#addElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        UILayer.prototype.addElement = function (element) {
            var index = this.owner[this.upperBoundReference];
            if (element.parent === this.owner)
                index--;
            this.owner[this.upperBoundReference]++;
            this.owner[this.raw_addElementAt](element, index);
            element.ownerChanged(this);
            return element;
        };

        /**
        * @method egret.UILayer#addElementAt
        * @param element {IVisualElement}
        * @param index {number}
        * @returns {IVisualElement}
        */
        UILayer.prototype.addElementAt = function (element, index) {
            this.owner[this.upperBoundReference]++;
            this.owner[this.raw_addElementAt](element, this.owner[this.lowerBoundReference] + index);
            element.ownerChanged(this);
            return element;
        };

        /**
        * @method egret.UILayer#removeElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        UILayer.prototype.removeElement = function (element) {
            var index = this.owner[this.raw_getElementIndex](element);
            if (this.owner[this.lowerBoundReference] <= index && index < this.owner[this.upperBoundReference]) {
                this.owner[this.raw_removeElement](element);
                this.owner[this.upperBoundReference]--;
            }
            element.ownerChanged(null);
            return element;
        };

        /**
        * @method egret.UILayer#removeElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        UILayer.prototype.removeElementAt = function (index) {
            index += this.owner[this.lowerBoundReference];
            var element;
            if (this.owner[this.lowerBoundReference] <= index && index < this.owner[this.upperBoundReference]) {
                element = this.owner[this.raw_removeElementAt](index);
                this.owner[this.upperBoundReference]--;
            }
            element.ownerChanged(null);
            return element;
        };

        /**
        * @method egret.UILayer#getElementIndex
        * @param element {IVisualElement}
        * @returns {number}
        */
        UILayer.prototype.getElementIndex = function (element) {
            var retval = this.owner[this.raw_getElementIndex](element);
            retval -= this.owner[this.lowerBoundReference];
            return retval;
        };

        /**
        * @method egret.UILayer#setElementIndex
        * @param element {IVisualElement}
        * @param index {number}
        */
        UILayer.prototype.setElementIndex = function (element, index) {
            this.owner[this.raw_setElementIndex](element, this.owner[this.lowerBoundReference] + index);
        };
        return UILayer;
    })();
    egret.UILayer = UILayer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.UIStage
    * @classdesc
    * 系统管理器，应用程序顶级容器。
    * 通常情况下，一个程序应该只含有唯一的系统管理器,并且所有的组件都包含在它内部。
    * 它负责管理弹窗，鼠标样式，工具提示的显示层级，以及过滤鼠标和键盘事件为可以取消的。
    * @extends egret.Group
    * @implements egret.IUIStage
    */
    var UIStage = (function (_super) {
        __extends(UIStage, _super);
        /**
        * 构造函数
        * @method egret.UIStage#constructor
        */
        function UIStage() {
            _super.call(this);
            this._autoResize = true;
            this._noTopMostIndex = 0;
            this._topMostIndex = 0;
            this._toolTipIndex = 0;
            this._cursorIndex = 0;
            this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddToStage, this);
            this.addEventListener(egret.Event.REMOVED_FROM_STAGE, this.onRemoveFromStage, this);
        }
        /**
        * 添加到舞台
        */
        UIStage.prototype.onAddToStage = function (event) {
            if (typeof event === "undefined") { event = null; }
            if (egret.UIGlobals._uiStage) {
                throw new Error("UIStage是GUI根容器，只能有一个此实例在显示列表中！");
            }
            egret.UIGlobals._uiStage = this;
            if (this._autoResize) {
                this.stage.addEventListener(egret.Event.RESIZE, this.onResize, this);
                this.onResize();
            }
        };

        /**
        * 从舞台移除
        */
        UIStage.prototype.onRemoveFromStage = function (event) {
            egret.UIGlobals._uiStage = null;
            if (this._autoResize) {
                this.stage.removeEventListener(egret.Event.RESIZE, this.onResize, this);
            }
        };

        /**
        * 舞台尺寸改变
        */
        UIStage.prototype.onResize = function (event) {
            if (typeof event === "undefined") { event = null; }
            this._setWidth(this.stage.stageWidth);
            this._setHeight(this.stage.stageHeight);
        };

        Object.defineProperty(UIStage.prototype, "autoResize", {
            /**
            * 是否自动跟随舞台缩放。当此属性为true时，将强制让UIState始终与舞台保持相同大小。
            * 反之需要外部手动同步大小。默认值为true。
            * @member egret.UIStage#autoResize
            */
            get: function () {
                return this._autoResize;
            },
            set: function (value) {
                if (this._autoResize == value)
                    return;
                this._autoResize = value;
                if (!this.stage)
                    return;
                if (this._autoResize) {
                    this.stage.addEventListener(egret.Event.RESIZE, this.onResize, this);
                    this.onResize();
                } else {
                    this.stage.removeEventListener(egret.Event.RESIZE, this.onResize, this);
                }
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "x", {
            //==========================================================================
            //                            禁止外部布局顶级容器
            //==========================================================================
            /**
            * @constant egret.UIStage#x
            */
            get: function () {
                return this._x;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._autoResize)
                    return;
                this._x = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "y", {
            /**
            * @constant egret.UIStage#y
            */
            get: function () {
                return this._y;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._autoResize)
                    return;
                this._y = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "width", {
            /**
            * @member egret.UIStage#width
            */
            get: function () {
                return this._width;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._autoResize)
                    return;
                this._setWidth(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "height", {
            /**
            * @member egret.UIStage#height
            */
            get: function () {
                return this._height;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._autoResize)
                    return;
                this._setHeight(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "scaleX", {
            /**
            * @member egret.UIStage#scaleX
            */
            get: function () {
                return this._scaleX;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._autoResize)
                    return;
                this._setScaleX(value);
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "scaleY", {
            /**
            * @member egret.UIStage#scaleY
            */
            get: function () {
                return this._scaleY;
            },
            /**
            * @inheritDoc
            */
            set: function (value) {
                if (this._autoResize)
                    return;
                this._setScaleY(value);
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method egret.UIStage#setActualSize
        * @param w {number}
        * @param h {number}
        */
        UIStage.prototype.setActualSize = function (w, h) {
            if (this._autoResize)
                return;
            _super.prototype.setActualSize.call(this, w, h);
        };

        /**
        * @method egret.UIStage#setLayoutBoundsPosition
        * @param x {number}
        * @param y {number}
        */
        UIStage.prototype.setLayoutBoundsPosition = function (x, y) {
            if (this._autoResize)
                return;
            _super.prototype.setLayoutBoundsPosition.call(this, x, y);
        };

        /**
        * @method egret.UIStage#setLayoutBoundsSize
        * @param layoutWidth {number}
        * @param layoutHeight {number}
        */
        UIStage.prototype.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
            if (this._autoResize)
                return;
            _super.prototype.setLayoutBoundsSize.call(this, layoutWidth, layoutHeight);
        };

        Object.defineProperty(UIStage.prototype, "layout", {
            /**
            * 布局对象,UIStage只接受BasicLayout
            * @member egret.UIStage#layout
            */
            get: function () {
                return this._layout;
            },
            set: function (value) {
                if (value instanceof egret.BasicLayout)
                    this._setLayout(value);
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIStage.prototype, "popUpContainer", {
            /**
            * 弹出窗口层容器。
            * @member egret.UIStage#popUpContainer
            */
            get: function () {
                if (!this._popUpContainer) {
                    this._popUpContainer = new egret.UILayer(this, "noTopMostIndex", "topMostIndex");
                }

                return this._popUpContainer;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIStage.prototype, "toolTipContainer", {
            /**
            * 工具提示层容器。
            * @member egret.UIStage#toolTipContainer
            */
            get: function () {
                if (!this._toolTipContainer) {
                    this._toolTipContainer = new egret.UILayer(this, "topMostIndex", "toolTipIndex");
                }

                return this._toolTipContainer;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIStage.prototype, "cursorContainer", {
            /**
            * 鼠标样式层容器。
            * @member egret.UIStage#cursorContainer
            */
            get: function () {
                if (!this._cursorContainer) {
                    this._cursorContainer = new egret.UILayer(this, "toolTipIndex", "cursorIndex");
                }

                return this._cursorContainer;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(UIStage.prototype, "noTopMostIndex", {
            /**
            * 弹出窗口层的起始索引(包括)
            */
            get: function () {
                return this._noTopMostIndex;
            },
            set: function (value) {
                var delta = value - this._noTopMostIndex;
                this._noTopMostIndex = value;
                this.topMostIndex += delta;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "topMostIndex", {
            /**
            * 弹出窗口层结束索引(不包括)
            */
            get: function () {
                return this._topMostIndex;
            },
            set: function (value) {
                var delta = value - this._topMostIndex;
                this._topMostIndex = value;
                this.toolTipIndex += delta;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "toolTipIndex", {
            /**
            * 工具提示层结束索引(不包括)
            */
            get: function () {
                return this._toolTipIndex;
            },
            set: function (value) {
                var delta = value - this._toolTipIndex;
                this._toolTipIndex = value;
                this.cursorIndex += delta;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(UIStage.prototype, "cursorIndex", {
            /**
            * 鼠标样式层结束索引(不包括)
            */
            get: function () {
                return this._cursorIndex;
            },
            set: function (value) {
                var delta = value - this._cursorIndex;
                this._cursorIndex = value;
            },
            enumerable: true,
            configurable: true
        });


        //==========================================================================
        //                                复写容器操作方法
        //==========================================================================
        /**
        * @method egret.UIStage#addElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        UIStage.prototype.addElement = function (element) {
            var addIndex = this._noTopMostIndex;
            if (element.parent == this)
                addIndex--;
            return this.addElementAt(element, addIndex);
        };

        /**
        * @method egret.UIStage#addElementAt
        * @param element {IVisualElement}
        * @param index {number}
        * @returns {IVisualElement}
        */
        UIStage.prototype.addElementAt = function (element, index) {
            if (element.parent == this) {
                var oldIndex = this.getElementIndex(element);
                if (oldIndex < this._noTopMostIndex)
                    this.noTopMostIndex--;
                else if (oldIndex >= this._noTopMostIndex && oldIndex < this._topMostIndex)
                    this.topMostIndex--;
                else if (oldIndex >= this._topMostIndex && oldIndex < this._toolTipIndex)
                    this.toolTipIndex--;
                else
                    this.cursorIndex--;
            }

            if (index <= this._noTopMostIndex)
                this.noTopMostIndex++;
            else if (index > this._noTopMostIndex && index <= this._topMostIndex)
                this.topMostIndex++;
            else if (index > this._topMostIndex && index <= this._toolTipIndex)
                this.toolTipIndex++;
            else
                this.cursorIndex++;

            return _super.prototype.addElementAt.call(this, element, index);
        };

        /**
        * @method egret.UIStage#removeElement
        * @param element {IVisualElement}
        * @returns {IVisualElement}
        */
        UIStage.prototype.removeElement = function (element) {
            return this.removeElementAt(_super.prototype.getElementIndex.call(this, element));
        };

        /**
        * @method egret.UIStage#removeElementAt
        * @param index {number}
        * @returns {IVisualElement}
        */
        UIStage.prototype.removeElementAt = function (index) {
            var element = _super.prototype.removeElementAt.call(this, index);
            if (index < this._noTopMostIndex)
                this.noTopMostIndex--;
            else if (index >= this._noTopMostIndex && index < this._topMostIndex)
                this.topMostIndex--;
            else if (index >= this._topMostIndex && index < this._toolTipIndex)
                this.toolTipIndex--;
            else
                this.cursorIndex--;
            return element;
        };

        /**
        * @method egret.UIStage#removeAllElements
        */
        UIStage.prototype.removeAllElements = function () {
            while (this._noTopMostIndex > 0) {
                _super.prototype.removeElementAt.call(this, 0);
                this.noTopMostIndex--;
            }
        };

        /**
        * @method egret.UIStage#_elementRemoved
        * @param element {IVisualElement}
        * @param index {number}
        * @param notifyListeners {boolean}
        */
        UIStage.prototype._elementRemoved = function (element, index, notifyListeners) {
            if (typeof notifyListeners === "undefined") { notifyListeners = true; }
            if (notifyListeners) {
                //PopUpManager需要监听这个事件
                egret.Event.dispatchEvent(element, "removeFromUIStage");
            }
            _super.prototype._elementRemoved.call(this, element, index, notifyListeners);
        };

        //==========================================================================
        //                                保留容器原始操作方法
        //==========================================================================
        UIStage.prototype.raw_getElementAt = function (index) {
            return _super.prototype.getElementAt.call(this, index);
        };
        UIStage.prototype.raw_addElement = function (element) {
            var index = this.numElements;
            if (element.parent == this)
                index--;
            return this.raw_addElementAt(element, index);
        };
        UIStage.prototype.raw_addElementAt = function (element, index) {
            if (element.parent == this) {
                var oldIndex = this.getElementIndex(element);
                if (oldIndex < this._noTopMostIndex)
                    this.noTopMostIndex--;
                else if (oldIndex >= this._noTopMostIndex && oldIndex < this._topMostIndex)
                    this.topMostIndex--;
                else if (oldIndex >= this._topMostIndex && oldIndex < this._toolTipIndex)
                    this.toolTipIndex--;
                else
                    this.cursorIndex--;
            }
            return _super.prototype.addElementAt.call(this, element, index);
        };
        UIStage.prototype.raw_removeElement = function (element) {
            return _super.prototype.removeElementAt.call(this, _super.prototype.getElementIndex.call(this, element));
        };
        UIStage.prototype.raw_removeElementAt = function (index) {
            return _super.prototype.removeElementAt.call(this, index);
        };
        UIStage.prototype.raw_removeAllElements = function () {
            while (this.numElements > 0) {
                _super.prototype.removeElementAt.call(this, 0);
            }
        };
        UIStage.prototype.raw_getElementIndex = function (element) {
            return _super.prototype.getElementIndex.call(this, element);
        };
        UIStage.prototype.raw_setElementIndex = function (element, index) {
            _super.prototype.setElementIndex.call(this, element, index);
        };
        UIStage.prototype.raw_swapElements = function (element1, element2) {
            _super.prototype.swapElementsAt.call(this, _super.prototype.getElementIndex.call(this, element1), _super.prototype.getElementIndex.call(this, element2));
        };
        UIStage.prototype.raw_swapElementsAt = function (index1, index2) {
            _super.prototype.swapElementsAt.call(this, index1, index2);
        };
        return UIStage;
    })(egret.Group);
    egret.UIStage = UIStage;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.PopUpManagerImpl
    * @classdesc
    * 窗口弹出管理器实现类
    * @extends egret.EventDispatcher
    * @implements egret.IPopUpManager
    */
    var PopUpManagerImpl = (function (_super) {
        __extends(PopUpManagerImpl, _super);
        /**
        * 构造函数
        * @method egret.PopUpManagerImpl#constructor
        */
        function PopUpManagerImpl() {
            _super.call(this);
            this._popUpList = [];
            /**
            * 模态窗口列表
            */
            this.popUpDataList = [];
            this._modalColor = 0x000000;
            this._modalAlpha = 0.5;
            this.invalidateModalFlag = false;
        }
        Object.defineProperty(PopUpManagerImpl.prototype, "popUpList", {
            /**
            * 已经弹出的窗口列表
            * @member egret.PopUpManagerImpl#popUpList
            */
            get: function () {
                return this._popUpList.concat();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 根据popUp获取对应的popUpData
        */
        PopUpManagerImpl.prototype.findPopUpData = function (popUp) {
            var list = this.popUpDataList;
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var data = list[i];
                if (data.popUp == popUp)
                    return data;
            }
            return null;
        };

        /**
        * 弹出一个窗口。<br/>
        * @method egret.PopUpManagerImpl#addPopUp
        * @param popUp {IVisualElement} 要弹出的窗口
        * @param modal {boolean} 是否启用模态。即禁用弹出窗口所在层以下的鼠标事件。默认false。
        * @param center {boolean} 是否居中窗口。等效于在外部调用centerPopUp()来居中。默认true。
        */
        PopUpManagerImpl.prototype.addPopUp = function (popUp, modal, center) {
            if (typeof modal === "undefined") { modal = false; }
            if (typeof center === "undefined") { center = true; }
            var uiStage = egret.UIGlobals.uiStage;
            var data = this.findPopUpData(popUp);
            if (data) {
                data.modal = modal;
                popUp.removeEventListener(PopUpManagerImpl.REMOVE_FROM_UISTAGE, this.onRemoved, this);
            } else {
                data = new PopUpData(popUp, modal);
                this.popUpDataList.push(data);
                this._popUpList.push(popUp);
            }
            uiStage.popUpContainer.addElement(popUp);
            if (center)
                this.centerPopUp(popUp);
            if ("isPopUp" in popUp)
                popUp.isPopUp = true;
            if (modal) {
                this.invalidateModal();
            }
            popUp.addEventListener(PopUpManagerImpl.REMOVE_FROM_UISTAGE, this.onRemoved, this);
        };

        /**
        * 从舞台移除
        */
        PopUpManagerImpl.prototype.onRemoved = function (event) {
            var index = 0;
            var list = this.popUpDataList;
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var data = list[i];
                if (data.popUp == event.target) {
                    if ("isPopUp" in data.popUp)
                        (data.popUp).isPopUp = false;
                    data.popUp.removeEventListener(PopUpManagerImpl.REMOVE_FROM_UISTAGE, this.onRemoved, this);
                    this.popUpDataList.splice(index, 1);
                    this._popUpList.splice(index, 1);
                    this.invalidateModal();
                    break;
                }
                index++;
            }
        };

        Object.defineProperty(PopUpManagerImpl.prototype, "modalColor", {
            /**
            * 模态遮罩的填充颜色
            * @member egret.PopUpManagerImpl#modalColor
            */
            get: function () {
                return this._modalColor;
            },
            set: function (value) {
                if (this._modalColor == value)
                    return;
                this._modalColor = value;
                this.invalidateModal();
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(PopUpManagerImpl.prototype, "modalAlpha", {
            /**
            * 模态遮罩的透明度
            * @member egret.PopUpManagerImpl#modalAlpha
            */
            get: function () {
                return this._modalAlpha;
            },
            set: function (value) {
                if (this._modalAlpha == value)
                    return;
                this._modalAlpha = value;
                this.invalidateModal();
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 标记一个UIStage的模态层失效
        */
        PopUpManagerImpl.prototype.invalidateModal = function () {
            if (!this.invalidateModalFlag) {
                this.invalidateModalFlag = true;
                egret.UIGlobals.stage.addEventListener(egret.Event.ENTER_FRAME, this.validateModal, this);
                egret.UIGlobals.stage.addEventListener(egret.Event.RENDER, this.validateModal, this);
                egret.UIGlobals.stage.invalidate();
            }
        };

        PopUpManagerImpl.prototype.validateModal = function (event) {
            this.invalidateModalFlag = false;
            egret.UIGlobals.stage.removeEventListener(egret.Event.ENTER_FRAME, this.validateModal, this);
            egret.UIGlobals.stage.removeEventListener(egret.Event.RENDER, this.validateModal, this);
            this.updateModal(egret.UIGlobals.uiStage);
        };

        /**
        * 更新窗口模态效果
        */
        PopUpManagerImpl.prototype.updateModal = function (uiStage) {
            var popUpContainer = uiStage.popUpContainer;
            var found = false;
            for (var i = popUpContainer.numElements - 1; i >= 0; i--) {
                var element = popUpContainer.getElementAt(i);
                var data = this.findPopUpData(element);
                if (data && data.modal) {
                    found = true;
                    break;
                }
            }
            if (found) {
                if (!this.modalMask) {
                    this.modalMask = new egret.Rect();
                    this.modalMask.touchEnabled = true;
                    this.modalMask.top = this.modalMask.left = this.modalMask.right = this.modalMask.bottom = 0;
                }
                this.modalMask.fillColor = this._modalColor;
                this.modalMask.alpha = this._modalAlpha;
                if (this.modalMask.parent == uiStage) {
                    if (popUpContainer.getElementIndex(this.modalMask) < i)
                        i--;
                    popUpContainer.setElementIndex(this.modalMask, i);
                } else {
                    popUpContainer.addElementAt(this.modalMask, i);
                }
            } else if (this.modalMask && this.modalMask.parent == uiStage) {
                popUpContainer.removeElement(this.modalMask);
            }
        };

        /**
        * 移除由addPopUp()方法弹出的窗口。
        * @method egret.PopUpManagerImpl#removePopUp
        * @param popUp {IVisualElement} 要移除的窗口
        */
        PopUpManagerImpl.prototype.removePopUp = function (popUp) {
            if (popUp && popUp.parent && this.findPopUpData(popUp)) {
                if ("removeElement" in popUp.parent)
                    (popUp.parent).removeElement(popUp);
                else if (popUp.parent instanceof egret.UIComponent)
                    (popUp.parent)._removeFromDisplayList(popUp);
                else if (popUp instanceof egret.DisplayObject)
                    popUp.parent.removeChild(popUp);
            }
        };

        /**
        * 将指定窗口居中显示
        * @method egret.PopUpManagerImpl#centerPopUp
        * @param popUp {IVisualElement} 要居中显示的窗口
        */
        PopUpManagerImpl.prototype.centerPopUp = function (popUp) {
            popUp.top = popUp.bottom = popUp.left = popUp.right = NaN;
            popUp.verticalCenter = popUp.horizontalCenter = 0;
            var parent = popUp.parent;
            if (parent) {
                if ("validateNow" in popUp)
                    popUp.validateNow();
                popUp.x = (parent.width - popUp.layoutBoundsWidth) * 0.5;
                popUp.y = (parent.height - popUp.layoutBoundsHeight) * 0.5;
            }
        };

        /**
        * 将指定窗口的层级调至最前
        * @method egret.PopUpManagerImpl#bringToFront
        * @param popUp {IVisualElement} 要最前显示的窗口
        */
        PopUpManagerImpl.prototype.bringToFront = function (popUp) {
            var data = this.findPopUpData(popUp);
            if (data && popUp.parent && "popUpContainer" in popUp.parent) {
                var uiStage = (popUp.parent);
                uiStage.popUpContainer.setElementIndex(popUp, uiStage.popUpContainer.numElements - 1);
                this.invalidateModal();
            }
        };
        PopUpManagerImpl.REMOVE_FROM_UISTAGE = "removeFromUIStage";
        return PopUpManagerImpl;
    })(egret.EventDispatcher);
    egret.PopUpManagerImpl = PopUpManagerImpl;

    var PopUpData = (function () {
        /**
        * @method egret.PopUpData#constructor
        * @param popUp {IVisualElement}
        * @param modal {boolea}
        */
        function PopUpData(popUp, modal) {
            this.popUp = popUp;
            this.modal = modal;
        }
        return PopUpData;
    })();
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    /**
    * @class egret.PopUpManager
    * @classdesc
    * 窗口弹出管理器<p/>
    * 若项目需要自定义弹出框管理器，请实现IPopUpManager接口，
    * 并在项目初始化前调用Injector.mapClass("egret.IPopUpManager",YourPopUpManager)，
    * 注入自定义的弹出框管理器类。
    */
    var PopUpManager = (function () {
        /**
        * 构造函数
        * @method egret.PopUpManager#constructor
        */
        function PopUpManager() {
        }
        /**
        * 获取单例
        */
        PopUpManager.getImpl = function () {
            if (!PopUpManager._impl) {
                try  {
                    PopUpManager._impl = egret.Injector.getInstance("egret.IPopUpManager");
                } catch (e) {
                    PopUpManager._impl = new egret.PopUpManagerImpl();
                }
            }
            return PopUpManager._impl;
        };

        Object.defineProperty(PopUpManager.prototype, "modalColor", {
            /**
            * 模态遮罩的填充颜色
            * @member egret.PopUpManager#modalColor
            */
            get: function () {
                return PopUpManager.getImpl().modalColor;
            },
            set: function (value) {
                PopUpManager.getImpl().modalColor = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(PopUpManager.prototype, "modalAlpha", {
            /**
            * 模态遮罩的透明度
            * @member egret.PopUpManager#modalAlpha
            */
            get: function () {
                return PopUpManager.getImpl().modalAlpha;
            },
            set: function (value) {
                PopUpManager.getImpl().modalAlpha = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 弹出一个窗口。<br/>
        * @method egret.PopUpManager.addPopUp
        * @param popUp {IVisualElement} 要弹出的窗口
        * @param modal {boolean} 是否启用模态。即禁用弹出窗口所在层以下的鼠标事件。默认false。
        * @param center {boolean} 是否居中窗口。等效于在外部调用centerPopUp()来居中。默认true。
        */
        PopUpManager.addPopUp = function (popUp, modal, center) {
            if (typeof modal === "undefined") { modal = false; }
            if (typeof center === "undefined") { center = true; }
            PopUpManager.getImpl().addPopUp(popUp, modal, center);
            egret.PopUpEvent.dispatchPopUpEvent(PopUpManager.getImpl(), egret.PopUpEvent.ADD_POPUP, popUp, modal);
        };

        /**
        * 移除由addPopUp()方法弹出的窗口。
        * @method egret.PopUpManager.removePopUp
        * @param popUp {IVisualElement} 要移除的窗口
        */
        PopUpManager.removePopUp = function (popUp) {
            PopUpManager.getImpl().removePopUp(popUp);
            egret.PopUpEvent.dispatchPopUpEvent(PopUpManager.getImpl(), egret.PopUpEvent.REMOVE_POPUP, popUp);
        };

        /**
        * 将指定窗口居中显示
        * @method egret.PopUpManager.centerPopUp
        * @param popUp {IVisualElement} 要居中显示的窗口
        */
        PopUpManager.centerPopUp = function (popUp) {
            PopUpManager.getImpl().centerPopUp(popUp);
        };

        /**
        * 将指定窗口的层级调至最前
        * @method egret.PopUpManager.bringToFront
        * @param popUp {IVisualElement} 要最前显示的窗口
        */
        PopUpManager.bringToFront = function (popUp) {
            PopUpManager.getImpl().bringToFront(popUp);
            egret.PopUpEvent.dispatchPopUpEvent(PopUpManager.getImpl(), egret.PopUpEvent.BRING_TO_FRONT, popUp);
        };

        Object.defineProperty(PopUpManager, "popUpList", {
            /**
            * 已经弹出的窗口列表
            * @member egret.PopUpManager.popUpList
            */
            get: function () {
                return PopUpManager.getImpl().popUpList;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * 添加事件监听,参考PopUpEvent定义的常量。
        * @method egret.PopUpManager.addEventListener
        * @see org.flexlite.domUI.events.PopUpEvent
        * @param type {string}
        * @param listener {Function}
        * @param thisObject {any}
        * @param useCapture {boolean}
        * @param priority {number}
        */
        PopUpManager.addEventListener = function (type, listener, thisObject, useCapture, priority) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            if (typeof priority === "undefined") { priority = 0; }
            PopUpManager.getImpl().addEventListener(type, listener, this, useCapture, priority);
        };

        /**
        * 移除事件监听,参考PopUpEvent定义的常量。
        * @method egret.PopUpManager.removeEventListener
        * @see org.flexlite.domUI.events.PopUpEvent
        * @param type {string}
        * @param listener {Function}
        * @param thisObject {any}
        * @param useCapture {boolean}
        */
        PopUpManager.removeEventListener = function (type, listener, thisObject, useCapture) {
            if (typeof useCapture === "undefined") { useCapture = false; }
            PopUpManager.getImpl().removeEventListener(type, listener, thisObject, useCapture);
        };
        return PopUpManager;
    })();
    egret.PopUpManager = PopUpManager;
})(egret || (egret = {}));

var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var dragonBones;
(function (dragonBones) {
    (function (geom) {
        var Point = (function () {
            function Point(x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                this.x = x;
                this.y = y;
            }
            Point.prototype.toString = function () {
                return "[Point (x=" + this.x + " y=" + this.y + ")]";
            };
            return Point;
        })();
        geom.Point = Point;

        var Rectangle = (function () {
            function Rectangle(x, y, width, height) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof width === "undefined") { width = 0; }
                if (typeof height === "undefined") { height = 0; }
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            return Rectangle;
        })();
        geom.Rectangle = Rectangle;

        var Matrix = (function () {
            function Matrix() {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.tx = 0;
                this.ty = 0;
            }
            Matrix.prototype.invert = function () {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                var tx1 = this.tx;
                var n = a1 * d1 - b1 * c1;

                this.a = d1 / n;
                this.b = -b1 / n;
                this.c = -c1 / n;
                this.d = a1 / n;
                this.tx = (c1 * this.ty - d1 * tx1) / n;
                this.ty = -(a1 * this.ty - b1 * tx1) / n;
            };
            return Matrix;
        })();
        geom.Matrix = Matrix;

        var ColorTransform = (function () {
            function ColorTransform() {
                this.alphaMultiplier = 0;
                this.alphaOffset = 0;
                this.blueMultiplier = 0;
                this.blueOffset = 0;
                this.greenMultiplier = 0;
                this.greenOffset = 0;
                this.redMultiplier = 0;
                this.redOffset = 0;
            }
            return ColorTransform;
        })();
        geom.ColorTransform = ColorTransform;
    })(dragonBones.geom || (dragonBones.geom = {}));
    var geom = dragonBones.geom;

    (function (events) {
        var Event = (function () {
            function Event(type) {
                this.type = type;
            }
            return Event;
        })();
        events.Event = Event;

        var AnimationEvent = (function (_super) {
            __extends(AnimationEvent, _super);
            function AnimationEvent(type) {
                _super.call(this, type);
            }
            AnimationEvent.FADE_IN = "fadeIn";
            AnimationEvent.FADE_OUT = "fadeOut";
            AnimationEvent.START = "start";
            AnimationEvent.COMPLETE = "complete";
            AnimationEvent.LOOP_COMPLETE = "loopComplete";
            AnimationEvent.FADE_IN_COMPLETE = "fadeInComplete";
            AnimationEvent.FADE_OUT_COMPLETE = "fadeOutComplete";
            return AnimationEvent;
        })(Event);
        events.AnimationEvent = AnimationEvent;

        var ArmatureEvent = (function (_super) {
            __extends(ArmatureEvent, _super);
            function ArmatureEvent(type) {
                _super.call(this, type);
            }
            ArmatureEvent.Z_ORDER_UPDATED = "zOrderUpdated";
            return ArmatureEvent;
        })(Event);
        events.ArmatureEvent = ArmatureEvent;

        var FrameEvent = (function (_super) {
            __extends(FrameEvent, _super);
            function FrameEvent(type) {
                _super.call(this, type);
            }
            FrameEvent.ANIMATION_FRAME_EVENT = "animationFrameEvent";
            FrameEvent.BONE_FRAME_EVENT = "boneFrameEvent";
            return FrameEvent;
        })(Event);
        events.FrameEvent = FrameEvent;

        var SoundEvent = (function (_super) {
            __extends(SoundEvent, _super);
            function SoundEvent(type) {
                _super.call(this, type);
            }
            SoundEvent.SOUND = "sound";
            SoundEvent.BONE_FRAME_EVENT = "boneFrameEvent";
            return SoundEvent;
        })(Event);
        events.SoundEvent = SoundEvent;

        var EventDispatcher = (function () {
            function EventDispatcher() {
            }
            EventDispatcher.prototype.hasEventListener = function (type) {
                if (this._listenersMap && this._listenersMap[type]) {
                    return true;
                }
                return false;
            };

            EventDispatcher.prototype.addEventListener = function (type, listener) {
                if (type && listener) {
                    if (!this._listenersMap) {
                        this._listenersMap = {};
                    }
                    var listeners = this._listenersMap[type];
                    if (listeners) {
                        this.removeEventListener(type, listener);
                    }
                    if (listeners) {
                        listeners.push(listener);
                    } else {
                        this._listenersMap[type] = [listener];
                    }
                }
            };

            EventDispatcher.prototype.removeEventListener = function (type, listener) {
                if (!this._listenersMap || !type || !listener) {
                    return;
                }
                var listeners = this._listenersMap[type];
                if (listeners) {
                    var length = listeners.length;
                    for (var i = 0; i < length; i++) {
                        if (listeners[i] == listener) {
                            if (length == 1) {
                                listeners.length = 0;
                                delete this._listenersMap[type];
                            } else {
                                listeners.splice(i, 1);
                            }
                        }
                    }
                }
            };

            EventDispatcher.prototype.removeAllEventListeners = function (type) {
                if (type) {
                    delete this._listenersMap[type];
                } else {
                    this._listenersMap = null;
                }
            };

            EventDispatcher.prototype.dispatchEvent = function (event) {
                if (event) {
                    var listeners = this._listenersMap[event.type];
                    if (listeners) {
                        event.target = this;
                        var listenersCopy = listeners.concat();
                        var length = listeners.length;
                        for (var i = 0; i < length; i++) {
                            listenersCopy[i](event);
                        }
                    }
                }
            };
            return EventDispatcher;
        })();
        events.EventDispatcher = EventDispatcher;

        var SoundEventManager = (function (_super) {
            __extends(SoundEventManager, _super);
            function SoundEventManager() {
                _super.call(this);
                if (SoundEventManager._instance) {
                    throw new Error("Singleton already constructed!");
                }
            }
            SoundEventManager.getInstance = function () {
                if (!SoundEventManager._instance) {
                    SoundEventManager._instance = new SoundEventManager();
                }
                return SoundEventManager._instance;
            };
            return SoundEventManager;
        })(EventDispatcher);
        events.SoundEventManager = SoundEventManager;
    })(dragonBones.events || (dragonBones.events = {}));
    var events = dragonBones.events;

    (function (animation) {
        var WorldClock = (function () {
            function WorldClock() {
                this.timeScale = 1;
                this.time = new Date().getTime() * 0.001;
                this._animatableList = [];
            }
            WorldClock.prototype.contains = function (animatable) {
                return this._animatableList.indexOf(animatable) >= 0;
            };

            WorldClock.prototype.add = function (animatable) {
                if (animatable && this._animatableList.indexOf(animatable) == -1) {
                    this._animatableList.push(animatable);
                }
            };

            WorldClock.prototype.remove = function (animatable) {
                var index = this._animatableList.indexOf(animatable);
                if (index >= 0) {
                    this._animatableList[index] = null;
                }
            };

            WorldClock.prototype.clear = function () {
                this._animatableList.length = 0;
            };

            WorldClock.prototype.advanceTime = function (passedTime) {
                if (passedTime < 0) {
                    var currentTime = new Date().getTime() * 0.001;
                    passedTime = currentTime - this.time;
                    this.time = currentTime;
                }

                passedTime *= this.timeScale;

                var length = this._animatableList.length;
                if (length == 0) {
                    return;
                }
                var currentIndex = 0;

                for (var i = 0; i < length; i++) {
                    var animatable = this._animatableList[i];
                    if (animatable) {
                        if (currentIndex != i) {
                            this._animatableList[currentIndex] = animatable;
                            this._animatableList[i] = null;
                        }
                        animatable.advanceTime(passedTime);
                        currentIndex++;
                    }
                }

                if (currentIndex != i) {
                    length = this._animatableList.length;
                    while (i < length) {
                        this._animatableList[currentIndex++] = this._animatableList[i++];
                    }
                    this._animatableList.length = currentIndex;
                }
            };
            WorldClock.clock = new WorldClock();
            return WorldClock;
        })();
        animation.WorldClock = WorldClock;

        var TimelineState = (function () {
            function TimelineState() {
                this.transform = new objects.DBTransform();
                this.pivot = new geom.Point();

                this._durationTransform = new objects.DBTransform();
                this._durationPivot = new geom.Point();
                this._durationColor = new geom.ColorTransform();
            }
            TimelineState._borrowObject = function () {
                if (TimelineState._pool.length == 0) {
                    return new TimelineState();
                }
                return TimelineState._pool.pop();
            };

            /** @private */
            TimelineState._returnObject = function (timeline) {
                if (TimelineState._pool.indexOf(timeline) < 0) {
                    TimelineState._pool[TimelineState._pool.length] = timeline;
                }

                timeline.clear();
            };

            /** @private */
            TimelineState._clear = function () {
                var i = TimelineState._pool.length;
                while (i--) {
                    TimelineState._pool[i].clear();
                }
                TimelineState._pool.length = 0;
            };

            TimelineState.getEaseValue = function (value, easing) {
                if (easing > 1) {
                    var valueEase = 0.5 * (1 - Math.cos(value * Math.PI)) - value;
                    easing -= 1;
                } else if (easing > 0) {
                    valueEase = Math.sin(value * TimelineState.HALF_PI) - value;
                } else if (easing < 0) {
                    valueEase = 1 - Math.cos(value * TimelineState.HALF_PI) - value;
                    easing *= -1;
                }
                return valueEase * easing + value;
            };

            TimelineState.prototype.fadeIn = function (bone, animationState, timeline) {
                this._bone = bone;
                this._animationState = animationState;
                this._timeline = timeline;

                this._originTransform = this._timeline.originTransform;
                this._originPivot = this._timeline.originPivot;

                this._tweenTransform = false;
                this._tweenColor = false;

                this._totalTime = this._animationState.totalTime;

                this.transform.x = 0;
                this.transform.y = 0;
                this.transform.scaleX = 0;
                this.transform.scaleY = 0;
                this.transform.skewX = 0;
                this.transform.skewY = 0;
                this.pivot.x = 0;
                this.pivot.y = 0;

                this._durationTransform.x = 0;
                this._durationTransform.y = 0;
                this._durationTransform.scaleX = 0;
                this._durationTransform.scaleY = 0;
                this._durationTransform.skewX = 0;
                this._durationTransform.skewY = 0;
                this._durationPivot.x = 0;
                this._durationPivot.y = 0;

                this._currentFrame = null;

                switch (this._timeline.getFrameList().length) {
                    case 0:
                        this._bone._arriveAtFrame(null, this, this._animationState, false);
                        this._updateState = 0;
                        break;
                    case 1:
                        this._updateState = -1;
                        break;
                    default:
                        this._updateState = 1;
                        break;
                }
            };

            TimelineState.prototype.fadeOut = function () {
                this.transform.skewX = utils.TransformUtil.formatRadian(this.transform.skewX);
                this.transform.skewY = utils.TransformUtil.formatRadian(this.transform.skewY);
            };

            TimelineState.prototype.update = function (progress) {
                if (this._updateState) {
                    if (this._updateState > 0) {
                        if (this._timeline.scale == 0) {
                            progress = 1;
                        } else {
                            progress /= this._timeline.scale;
                        }

                        if (progress == 1) {
                            progress = 0.99999999;
                        }

                        progress += this._timeline.offset;
                        var loopCount = Math.floor(progress);
                        progress -= loopCount;

                        //
                        var playedTime = this._totalTime * progress;
                        var isArrivedFrame = false;
                        var frameIndex;
                        while (!this._currentFrame || playedTime > this._currentFramePosition + this._currentFrameDuration || playedTime < this._currentFramePosition) {
                            if (isArrivedFrame) {
                                this._bone._arriveAtFrame(this._currentFrame, this, this._animationState, true);
                            }
                            isArrivedFrame = true;
                            if (this._currentFrame) {
                                frameIndex = this._timeline.getFrameList().indexOf(this._currentFrame) + 1;
                                if (frameIndex >= this._timeline.getFrameList().length) {
                                    frameIndex = 0;
                                }
                                this._currentFrame = this._timeline.getFrameList()[frameIndex];
                            } else {
                                frameIndex = 0;
                                this._currentFrame = this._timeline.getFrameList()[0];
                            }
                            this._currentFrameDuration = this._currentFrame.duration;
                            this._currentFramePosition = this._currentFrame.position;
                        }

                        if (isArrivedFrame) {
                            this.tweenActive = this._currentFrame.displayIndex >= 0;
                            frameIndex++;
                            if (frameIndex >= this._timeline.getFrameList().length) {
                                frameIndex = 0;
                            }
                            var nextFrame = this._timeline.getFrameList()[frameIndex];

                            if (frameIndex == 0 && this._animationState.loop && this._animationState.loopCount >= Math.abs(this._animationState.loop) - 1 && ((this._currentFramePosition + this._currentFrameDuration) / this._totalTime + loopCount - this._timeline.offset) * this._timeline.scale > 0.99999999) {
                                this._updateState = 0;
                                this._tweenEasing = NaN;
                            } else if (this._currentFrame.displayIndex < 0 || nextFrame.displayIndex < 0 || !this._animationState.tweenEnabled) {
                                this._tweenEasing = NaN;
                            } else if (isNaN(this._animationState.clip.tweenEasing)) {
                                this._tweenEasing = this._currentFrame.tweenEasing;
                            } else {
                                this._tweenEasing = this._animationState.clip.tweenEasing;
                            }

                            if (isNaN(this._tweenEasing)) {
                                this._tweenTransform = false;
                                this._tweenColor = false;
                            } else {
                                this._durationTransform.x = nextFrame.transform.x - this._currentFrame.transform.x;
                                this._durationTransform.y = nextFrame.transform.y - this._currentFrame.transform.y;
                                this._durationTransform.skewX = nextFrame.transform.skewX - this._currentFrame.transform.skewX;
                                this._durationTransform.skewY = nextFrame.transform.skewY - this._currentFrame.transform.skewY;
                                this._durationTransform.scaleX = nextFrame.transform.scaleX - this._currentFrame.transform.scaleX;
                                this._durationTransform.scaleY = nextFrame.transform.scaleY - this._currentFrame.transform.scaleY;

                                if (frameIndex == 0) {
                                    this._durationTransform.skewX = utils.TransformUtil.formatRadian(this._durationTransform.skewX);
                                    this._durationTransform.skewY = utils.TransformUtil.formatRadian(this._durationTransform.skewY);
                                }

                                this._durationPivot.x = nextFrame.pivot.x - this._currentFrame.pivot.x;
                                this._durationPivot.y = nextFrame.pivot.y - this._currentFrame.pivot.y;

                                if (this._durationTransform.x != 0 || this._durationTransform.y != 0 || this._durationTransform.skewX != 0 || this._durationTransform.skewY != 0 || this._durationTransform.scaleX != 0 || this._durationTransform.scaleY != 0 || this._durationPivot.x != 0 || this._durationPivot.y != 0) {
                                    this._tweenTransform = true;
                                } else {
                                    this._tweenTransform = false;
                                }

                                if (this._currentFrame.color && nextFrame.color) {
                                    this._durationColor.alphaOffset = nextFrame.color.alphaOffset - this._currentFrame.color.alphaOffset;
                                    this._durationColor.redOffset = nextFrame.color.redOffset - this._currentFrame.color.redOffset;
                                    this._durationColor.greenOffset = nextFrame.color.greenOffset - this._currentFrame.color.greenOffset;
                                    this._durationColor.blueOffset = nextFrame.color.blueOffset - this._currentFrame.color.blueOffset;

                                    this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - this._currentFrame.color.alphaMultiplier;
                                    this._durationColor.redMultiplier = nextFrame.color.redMultiplier - this._currentFrame.color.redMultiplier;
                                    this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - this._currentFrame.color.greenMultiplier;
                                    this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - this._currentFrame.color.blueMultiplier;

                                    if (this._durationColor.alphaOffset != 0 || this._durationColor.redOffset != 0 || this._durationColor.greenOffset != 0 || this._durationColor.blueOffset != 0 || this._durationColor.alphaMultiplier != 0 || this._durationColor.redMultiplier != 0 || this._durationColor.greenMultiplier != 0 || this._durationColor.blueMultiplier != 0) {
                                        this._tweenColor = true;
                                    } else {
                                        this._tweenColor = false;
                                    }
                                } else if (this._currentFrame.color) {
                                    this._tweenColor = true;
                                    this._durationColor.alphaOffset = -this._currentFrame.color.alphaOffset;
                                    this._durationColor.redOffset = -this._currentFrame.color.redOffset;
                                    this._durationColor.greenOffset = -this._currentFrame.color.greenOffset;
                                    this._durationColor.blueOffset = -this._currentFrame.color.blueOffset;

                                    this._durationColor.alphaMultiplier = 1 - this._currentFrame.color.alphaMultiplier;
                                    this._durationColor.redMultiplier = 1 - this._currentFrame.color.redMultiplier;
                                    this._durationColor.greenMultiplier = 1 - this._currentFrame.color.greenMultiplier;
                                    this._durationColor.blueMultiplier = 1 - this._currentFrame.color.blueMultiplier;
                                } else if (nextFrame.color) {
                                    this._tweenColor = true;
                                    this._durationColor.alphaOffset = nextFrame.color.alphaOffset;
                                    this._durationColor.redOffset = nextFrame.color.redOffset;
                                    this._durationColor.greenOffset = nextFrame.color.greenOffset;
                                    this._durationColor.blueOffset = nextFrame.color.blueOffset;

                                    this._durationColor.alphaMultiplier = nextFrame.color.alphaMultiplier - 1;
                                    this._durationColor.redMultiplier = nextFrame.color.redMultiplier - 1;
                                    this._durationColor.greenMultiplier = nextFrame.color.greenMultiplier - 1;
                                    this._durationColor.blueMultiplier = nextFrame.color.blueMultiplier - 1;
                                } else {
                                    this._tweenColor = false;
                                }
                            }

                            if (!this._tweenTransform) {
                                if (this._animationState.blend) {
                                    this.transform.x = this._originTransform.x + this._currentFrame.transform.x;
                                    this.transform.y = this._originTransform.y + this._currentFrame.transform.y;
                                    this.transform.skewX = this._originTransform.skewX + this._currentFrame.transform.skewX;
                                    this.transform.skewY = this._originTransform.skewY + this._currentFrame.transform.skewY;
                                    this.transform.scaleX = this._originTransform.scaleX + this._currentFrame.transform.scaleX;
                                    this.transform.scaleY = this._originTransform.scaleY + this._currentFrame.transform.scaleY;

                                    this.pivot.x = this._originPivot.x + this._currentFrame.pivot.x;
                                    this.pivot.y = this._originPivot.y + this._currentFrame.pivot.y;
                                } else {
                                    this.transform.x = this._currentFrame.transform.x;
                                    this.transform.y = this._currentFrame.transform.y;
                                    this.transform.skewX = this._currentFrame.transform.skewX;
                                    this.transform.skewY = this._currentFrame.transform.skewY;
                                    this.transform.scaleX = this._currentFrame.transform.scaleX;
                                    this.transform.scaleY = this._currentFrame.transform.scaleY;

                                    this.pivot.x = this._currentFrame.pivot.x;
                                    this.pivot.y = this._currentFrame.pivot.y;
                                }
                            }

                            if (!this._tweenColor) {
                                if (this._currentFrame.color) {
                                    this._bone._updateColor(this._currentFrame.color.alphaOffset, this._currentFrame.color.redOffset, this._currentFrame.color.greenOffset, this._currentFrame.color.blueOffset, this._currentFrame.color.alphaMultiplier, this._currentFrame.color.redMultiplier, this._currentFrame.color.greenMultiplier, this._currentFrame.color.blueMultiplier, true);
                                } else if (this._bone._isColorChanged) {
                                    this._bone._updateColor(0, 0, 0, 0, 1, 1, 1, 1, false);
                                }
                            }
                            this._bone._arriveAtFrame(this._currentFrame, this, this._animationState, false);
                        }

                        if (this._tweenTransform || this._tweenColor) {
                            progress = (playedTime - this._currentFramePosition) / this._currentFrameDuration;
                            if (this._tweenEasing) {
                                progress = TimelineState.getEaseValue(progress, this._tweenEasing);
                            }
                        }

                        if (this._tweenTransform) {
                            var currentTransform = this._currentFrame.transform;
                            var currentPivot = this._currentFrame.pivot;
                            if (this._animationState.blend) {
                                this.transform.x = this._originTransform.x + currentTransform.x + this._durationTransform.x * progress;
                                this.transform.y = this._originTransform.y + currentTransform.y + this._durationTransform.y * progress;
                                this.transform.skewX = this._originTransform.skewX + currentTransform.skewX + this._durationTransform.skewX * progress;
                                this.transform.skewY = this._originTransform.skewY + currentTransform.skewY + this._durationTransform.skewY * progress;
                                this.transform.scaleX = this._originTransform.scaleX + currentTransform.scaleX + this._durationTransform.scaleX * progress;
                                this.transform.scaleY = this._originTransform.scaleY + currentTransform.scaleY + this._durationTransform.scaleY * progress;

                                this.pivot.x = this._originPivot.x + currentPivot.x + this._durationPivot.x * progress;
                                this.pivot.y = this._originPivot.y + currentPivot.y + this._durationPivot.y * progress;
                            } else {
                                this.transform.x = currentTransform.x + this._durationTransform.x * progress;
                                this.transform.y = currentTransform.y + this._durationTransform.y * progress;
                                this.transform.skewX = currentTransform.skewX + this._durationTransform.skewX * progress;
                                this.transform.skewY = currentTransform.skewY + this._durationTransform.skewY * progress;
                                this.transform.scaleX = currentTransform.scaleX + this._durationTransform.scaleX * progress;
                                this.transform.scaleY = currentTransform.scaleY + this._durationTransform.scaleY * progress;

                                this.pivot.x = currentPivot.x + this._durationPivot.x * progress;
                                this.pivot.y = currentPivot.y + this._durationPivot.y * progress;
                            }
                        }

                        if (this._tweenColor) {
                            if (this._currentFrame.color) {
                                this._bone._updateColor(this._currentFrame.color.alphaOffset + this._durationColor.alphaOffset * progress, this._currentFrame.color.redOffset + this._durationColor.redOffset * progress, this._currentFrame.color.greenOffset + this._durationColor.greenOffset * progress, this._currentFrame.color.blueOffset + this._durationColor.blueOffset * progress, this._currentFrame.color.alphaMultiplier + this._durationColor.alphaMultiplier * progress, this._currentFrame.color.redMultiplier + this._durationColor.redMultiplier * progress, this._currentFrame.color.greenMultiplier + this._durationColor.greenMultiplier * progress, this._currentFrame.color.blueMultiplier + this._durationColor.blueMultiplier * progress, true);
                            } else {
                                this._bone._updateColor(this._durationColor.alphaOffset * progress, this._durationColor.redOffset * progress, this._durationColor.greenOffset * progress, this._durationColor.blueOffset * progress, 1 + this._durationColor.alphaMultiplier * progress, 1 + this._durationColor.redMultiplier * progress, 1 + this._durationColor.greenMultiplier * progress, 1 + this._durationColor.blueMultiplier * progress, true);
                            }
                        }
                    } else {
                        this._updateState = 0;
                        if (this._animationState.blend) {
                            this.transform.copy(this._originTransform);

                            this.pivot.x = this._originPivot.x;
                            this.pivot.y = this._originPivot.y;
                        } else {
                            this.transform.x = this.transform.y = this.transform.skewX = this.transform.skewY = this.transform.scaleX = this.transform.scaleY = 0;

                            this.pivot.x = 0;
                            this.pivot.y = 0;
                        }

                        this._currentFrame = this._timeline.getFrameList()[0];

                        this.tweenActive = this._currentFrame.displayIndex >= 0;

                        if (this._currentFrame.color) {
                            this._bone._updateColor(this._currentFrame.color.alphaOffset, this._currentFrame.color.redOffset, this._currentFrame.color.greenOffset, this._currentFrame.color.blueOffset, this._currentFrame.color.alphaMultiplier, this._currentFrame.color.redMultiplier, this._currentFrame.color.greenMultiplier, this._currentFrame.color.blueMultiplier, true);
                        } else {
                            this._bone._updateColor(0, 0, 0, 0, 1, 1, 1, 1, false);
                        }

                        this._bone._arriveAtFrame(this._currentFrame, this, this._animationState, false);
                    }
                }
            };

            TimelineState.prototype.clear = function () {
                this._updateState = 0;
                this._bone = null;
                this._animationState = null;
                this._timeline = null;
                this._currentFrame = null;
                this._originTransform = null;
                this._originPivot = null;
            };
            TimelineState.HALF_PI = Math.PI * 0.5;

            TimelineState._pool = [];
            return TimelineState;
        })();
        animation.TimelineState = TimelineState;

        var AnimationState = (function () {
            function AnimationState() {
                this.loop = 0;
                this.layer = 0;
                this._timelineStates = {};
            }
            /** @private */
            AnimationState._borrowObject = function () {
                if (AnimationState._pool.length == 0) {
                    return new AnimationState();
                }
                return AnimationState._pool.pop();
            };

            /** @private */
            AnimationState._returnObject = function (animationState) {
                if (AnimationState._pool.indexOf(animationState) < 0) {
                    AnimationState._pool[AnimationState._pool.length] = animationState;
                }

                animationState.clear();
            };

            /** @private */
            AnimationState._clear = function () {
                var i = AnimationState._pool.length;
                while (i--) {
                    AnimationState._pool[i].clear();
                }
                AnimationState._pool.length = 0;
            };

            AnimationState.prototype.fadeIn = function (armature, clip, fadeInTime, timeScale, loop, layer, displayControl, pauseBeforeFadeInComplete) {
                this.layer = layer;
                this.clip = clip;
                this.name = this.clip.name;
                this.totalTime = this.clip.duration;

                this._armature = armature;

                if (Math.round(this.clip.duration * this.clip.frameRate) < 2 || timeScale == Infinity) {
                    this.timeScale = 1;
                    this.currentTime = this.totalTime;
                    if (this.loop >= 0) {
                        this.loop = 1;
                    } else {
                        this.loop = -1;
                    }
                } else {
                    this.timeScale = timeScale;
                    this.currentTime = 0;
                    this.loop = loop;
                }

                this._pauseBeforeFadeInComplete = pauseBeforeFadeInComplete;

                this._fadeInTime = fadeInTime * this.timeScale;
                this._fadeState = 1;
                this._fadeOutBeginTime = 0;
                this._fadeOutWeight = -1;
                this._fadeWeight = 0;
                this._fadeIn = true;
                this._fadeOut = false;

                this.loopCount = -1;
                this.displayControl = displayControl;
                this.isPlaying = true;
                this.isComplete = false;

                this.weight = 1;
                this.blend = true;
                this.enabled = true;
                this.tweenEnabled = true;

                this.updateTimelineStates();
            };

            AnimationState.prototype.fadeOut = function (fadeOutTime, pause) {
                if (typeof pause === "undefined") { pause = false; }
                if (!this._armature || this._fadeOutWeight >= 0) {
                    return;
                }
                this._fadeState = -1;
                this._fadeOutWeight = this._fadeWeight;
                this._fadeOutTime = fadeOutTime * this.timeScale;
                this._fadeOutBeginTime = this.currentTime;
                this._fadeOut = true;

                this.isPlaying = !pause;
                this.displayControl = false;

                for (var index in this._timelineStates) {
                    this._timelineStates[index].fadeOut();
                }

                this.enabled = true;
            };

            AnimationState.prototype.play = function () {
                this.isPlaying = true;
            };

            AnimationState.prototype.stop = function () {
                this.isPlaying = false;
            };

            AnimationState.prototype.getMixingTransform = function (timelineName) {
                if (this._mixingTransforms) {
                    return Number(this._mixingTransforms[timelineName]);
                }
                return -1;
            };

            AnimationState.prototype.addMixingTransform = function (timelineName, type, recursive) {
                if (typeof type === "undefined") { type = 2; }
                if (typeof recursive === "undefined") { recursive = true; }
                if (this.clip && this.clip.getTimeline(timelineName)) {
                    if (!this._mixingTransforms) {
                        this._mixingTransforms = {};
                    }
                    if (recursive) {
                        var i = this._armature._boneList.length;
                        var bone;
                        var currentBone;
                        while (i--) {
                            bone = this._armature._boneList[i];
                            if (bone.name == timelineName) {
                                currentBone = bone;
                            }
                            if (currentBone && (currentBone == bone || currentBone.contains(bone))) {
                                this._mixingTransforms[bone.name] = type;
                            }
                        }
                    } else {
                        this._mixingTransforms[timelineName] = type;
                    }

                    this.updateTimelineStates();
                } else {
                    throw new Error();
                }
            };

            AnimationState.prototype.removeMixingTransform = function (timelineName, recursive) {
                if (typeof timelineName === "undefined") { timelineName = null; }
                if (typeof recursive === "undefined") { recursive = true; }
                if (timelineName) {
                    if (recursive) {
                        var i = this._armature._boneList.length;
                        var bone;
                        var currentBone;
                        while (i--) {
                            bone = this._armature._boneList[i];
                            if (bone.name == timelineName) {
                                currentBone = bone;
                            }
                            if (currentBone && (currentBone == bone || currentBone.contains(bone))) {
                                delete this._mixingTransforms[bone.name];
                            }
                        }
                    } else {
                        delete this._mixingTransforms[timelineName];
                    }

                    for (var index in this._mixingTransforms) {
                        var hasMixing = true;
                        break;
                    }
                    if (!hasMixing) {
                        this._mixingTransforms = null;
                    }
                } else {
                    this._mixingTransforms = null;
                }

                this.updateTimelineStates();
            };

            AnimationState.prototype.advanceTime = function (passedTime) {
                if (!this.enabled) {
                    return false;
                }
                var event;
                var isComplete;

                if (this._fadeIn) {
                    this._fadeIn = false;
                    if (this._armature.hasEventListener(events.AnimationEvent.FADE_IN)) {
                        event = new events.AnimationEvent(events.AnimationEvent.FADE_IN);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }

                if (this._fadeOut) {
                    this._fadeOut = false;
                    if (this._armature.hasEventListener(events.AnimationEvent.FADE_OUT)) {
                        event = new events.AnimationEvent(events.AnimationEvent.FADE_OUT);
                        event.animationState = this;
                        this._armature._eventList.push(event);
                    }
                }

                this.currentTime += passedTime * this.timeScale;

                if (this.isPlaying && !this.isComplete) {
                    var progress;
                    var currentLoopCount;
                    if (this._pauseBeforeFadeInComplete) {
                        this._pauseBeforeFadeInComplete = false;
                        this.isPlaying = false;
                        progress = 0;
                        currentLoopCount = Math.floor(progress);
                    } else {
                        progress = this.currentTime / this.totalTime;

                        //update loopCount
                        currentLoopCount = Math.floor(progress);
                        if (currentLoopCount != this.loopCount) {
                            if (this.loopCount == -1) {
                                if (this._armature.hasEventListener(events.AnimationEvent.START)) {
                                    event = new events.AnimationEvent(events.AnimationEvent.START);
                                    event.animationState = this;
                                    this._armature._eventList.push(event);
                                }
                            }
                            this.loopCount = currentLoopCount;
                            if (this.loopCount) {
                                if (this.loop && this.loopCount * this.loopCount >= this.loop * this.loop - 1) {
                                    isComplete = true;
                                    progress = 1;
                                    currentLoopCount = 0;
                                    if (this._armature.hasEventListener(events.AnimationEvent.COMPLETE)) {
                                        event = new events.AnimationEvent(events.AnimationEvent.COMPLETE);
                                        event.animationState = this;
                                        this._armature._eventList.push(event);
                                    }
                                } else {
                                    if (this._armature.hasEventListener(events.AnimationEvent.LOOP_COMPLETE)) {
                                        event = new events.AnimationEvent(events.AnimationEvent.LOOP_COMPLETE);
                                        event.animationState = this;
                                        this._armature._eventList.push(event);
                                    }
                                }
                            }
                        }
                    }

                    for (var index in this._timelineStates) {
                        this._timelineStates[index].update(progress);
                    }
                    var frameList = this.clip.getFrameList();
                    if (frameList.length > 0) {
                        var playedTime = this.totalTime * (progress - currentLoopCount);
                        var isArrivedFrame = false;
                        var frameIndex;
                        while (!this._currentFrame || playedTime > this._currentFrame.position + this._currentFrame.duration || playedTime < this._currentFrame.position) {
                            if (isArrivedFrame) {
                                this._armature._arriveAtFrame(this._currentFrame, null, this, true);
                            }
                            isArrivedFrame = true;
                            if (this._currentFrame) {
                                frameIndex = frameList.indexOf(this._currentFrame);
                                frameIndex++;
                                if (frameIndex >= frameList.length) {
                                    frameIndex = 0;
                                }
                                this._currentFrame = frameList[frameIndex];
                            } else {
                                this._currentFrame = frameList[0];
                            }
                        }

                        if (isArrivedFrame) {
                            this._armature._arriveAtFrame(this._currentFrame, null, this, false);
                        }
                    }
                }

                //update weight and fadeState
                if (this._fadeState > 0) {
                    if (this._fadeInTime == 0) {
                        this._fadeWeight = 1;
                        this._fadeState = 0;
                        this.isPlaying = true;
                        if (this._armature.hasEventListener(events.AnimationEvent.FADE_IN_COMPLETE)) {
                            event = new events.AnimationEvent(events.AnimationEvent.FADE_IN_COMPLETE);
                            event.animationState = this;
                            this._armature._eventList.push(event);
                        }
                    } else {
                        this._fadeWeight = this.currentTime / this._fadeInTime;
                        if (this._fadeWeight >= 1) {
                            this._fadeWeight = 1;
                            this._fadeState = 0;
                            if (!this.isPlaying) {
                                this.currentTime -= this._fadeInTime;
                            }
                            this.isPlaying = true;
                            if (this._armature.hasEventListener(events.AnimationEvent.FADE_IN_COMPLETE)) {
                                event = new events.AnimationEvent(events.AnimationEvent.FADE_IN_COMPLETE);
                                event.animationState = this;
                                this._armature._eventList.push(event);
                            }
                        }
                    }
                } else if (this._fadeState < 0) {
                    if (this._fadeOutTime == 0) {
                        this._fadeWeight = 0;
                        this._fadeState = 0;
                        if (this._armature.hasEventListener(events.AnimationEvent.FADE_OUT_COMPLETE)) {
                            event = new events.AnimationEvent(events.AnimationEvent.FADE_OUT_COMPLETE);
                            event.animationState = this;
                            this._armature._eventList.push(event);
                        }
                        return true;
                    } else {
                        this._fadeWeight = (1 - (this.currentTime - this._fadeOutBeginTime) / this._fadeOutTime) * this._fadeOutWeight;
                        if (this._fadeWeight <= 0) {
                            this._fadeWeight = 0;
                            this._fadeState = 0;
                            if (this._armature.hasEventListener(events.AnimationEvent.FADE_OUT_COMPLETE)) {
                                event = new events.AnimationEvent(events.AnimationEvent.FADE_OUT_COMPLETE);
                                event.animationState = this;
                                this._armature._eventList.push(event);
                            }
                            return true;
                        }
                    }
                }

                if (isComplete) {
                    this.isComplete = true;
                    if (this.loop < 0) {
                        this.fadeOut((this._fadeOutWeight || this._fadeInTime) / this.timeScale, true);
                    }
                }

                return false;
            };

            AnimationState.prototype.updateTimelineStates = function () {
                if (this._mixingTransforms) {
                    for (var timelineName in this._timelineStates) {
                        if (this._mixingTransforms[timelineName] == null) {
                            this.removeTimelineState(timelineName);
                        }
                    }

                    for (timelineName in this._mixingTransforms) {
                        if (!this._timelineStates[timelineName]) {
                            this.addTimelineState(timelineName);
                        }
                    }
                } else {
                    for (timelineName in this.clip.getTimelines()) {
                        if (!this._timelineStates[timelineName]) {
                            this.addTimelineState(timelineName);
                        }
                    }
                }
            };

            AnimationState.prototype.addTimelineState = function (timelineName) {
                var bone = this._armature.getBone(timelineName);
                if (bone) {
                    var timelineState = TimelineState._borrowObject();
                    var timeline = this.clip.getTimeline(timelineName);
                    timelineState.fadeIn(bone, this, timeline);
                    this._timelineStates[timelineName] = timelineState;
                }
            };

            AnimationState.prototype.removeTimelineState = function (timelineName) {
                TimelineState._returnObject(this._timelineStates[timelineName]);
                delete this._timelineStates[timelineName];
            };

            AnimationState.prototype.clear = function () {
                this.clip = null;
                this.enabled = false;

                this._armature = null;
                this._currentFrame = null;
                this._mixingTransforms = null;

                for (var timelineName in this._timelineStates) {
                    this.removeTimelineState(timelineName);
                }
            };
            AnimationState._pool = [];
            return AnimationState;
        })();
        animation.AnimationState = AnimationState;

        var Animation = (function () {
            function Animation(armature) {
                this._armature = armature;
                this._animationLayer = [];
                this._isPlaying = false;

                this.animationNameList = [];
                this.tweenEnabled = true;
                this.timeScale = 1;
            }
            Animation.prototype.getLastAnimationName = function () {
                return this._lastAnimationState ? this._lastAnimationState.name : null;
            };

            Animation.prototype.getLastAnimationState = function () {
                return this._lastAnimationState;
            };

            Animation.prototype.getAnimationDataList = function () {
                return this._animationDataList;
            };

            Animation.prototype.setAnimationDataList = function (value) {
                this._animationDataList = value;
                this.animationNameList.length = 0;
                for (var index in this._animationDataList) {
                    this.animationNameList[this.animationNameList.length] = this._animationDataList[index].name;
                }
            };

            Animation.prototype.getIsPlaying = function () {
                return this._isPlaying && !this.getIsComplete();
            };

            Animation.prototype.getIsComplete = function () {
                if (this._lastAnimationState) {
                    if (!this._lastAnimationState.isComplete) {
                        return false;
                    }
                    var j = this._animationLayer.length;
                    while (j--) {
                        var animationStateList = this._animationLayer[j];
                        var i = animationStateList.length;
                        while (i--) {
                            if (!animationStateList[i].isComplete) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                return false;
            };

            Animation.prototype.dispose = function () {
                if (!this._armature) {
                    return;
                }
                this.stop();
                var i = this._animationLayer.length;
                while (i--) {
                    var animationStateList = this._animationLayer[i];
                    var j = animationStateList.length;
                    while (j--) {
                        AnimationState._returnObject(animationStateList[j]);
                    }
                    animationStateList.length = 0;
                }
                this._animationLayer.length = 0;
                this.animationNameList.length = 0;

                this._armature = null;
                this._animationLayer = null;
                this._animationDataList = null;
                this.animationNameList = null;
            };

            Animation.prototype.gotoAndPlay = function (animationName, fadeInTime, duration, loop, layer, group, fadeOutMode, displayControl, pauseFadeOut, pauseFadeIn) {
                if (typeof fadeInTime === "undefined") { fadeInTime = -1; }
                if (typeof duration === "undefined") { duration = -1; }
                if (typeof loop === "undefined") { loop = NaN; }
                if (typeof layer === "undefined") { layer = 0; }
                if (typeof group === "undefined") { group = null; }
                if (typeof fadeOutMode === "undefined") { fadeOutMode = Animation.SAME_LAYER_AND_GROUP; }
                if (typeof displayControl === "undefined") { displayControl = true; }
                if (typeof pauseFadeOut === "undefined") { pauseFadeOut = true; }
                if (typeof pauseFadeIn === "undefined") { pauseFadeIn = true; }
                if (!this._animationDataList) {
                    return null;
                }
                var i = this._animationDataList.length;
                var animationData;
                while (i--) {
                    if (this._animationDataList[i].name == animationName) {
                        animationData = this._animationDataList[i];
                        break;
                    }
                }
                if (!animationData) {
                    return null;
                }

                this._isPlaying = true;

                //
                fadeInTime = fadeInTime < 0 ? (animationData.fadeInTime < 0 ? 0.3 : animationData.fadeInTime) : fadeInTime;

                var durationScale;
                if (duration < 0) {
                    durationScale = animationData.scale < 0 ? 1 : animationData.scale;
                } else {
                    durationScale = duration / animationData.duration;
                }

                loop = isNaN(loop) ? animationData.loop : loop;
                layer = this.addLayer(layer);

                //autoSync = autoSync && !pauseFadeOut && !pauseFadeIn;
                var animationState;
                var animationStateList;
                switch (fadeOutMode) {
                    case Animation.NONE:
                        break;
                    case Animation.SAME_LAYER:
                        animationStateList = this._animationLayer[layer];
                        i = animationStateList.length;
                        while (i--) {
                            animationState = animationStateList[i];
                            animationState.fadeOut(fadeInTime, pauseFadeOut);
                        }
                        break;
                    case Animation.SAME_GROUP:
                        j = this._animationLayer.length;
                        while (j--) {
                            animationStateList = this._animationLayer[j];
                            i = animationStateList.length;
                            while (i--) {
                                animationState = animationStateList[i];
                                if (animationState.group == group) {
                                    animationState.fadeOut(fadeInTime, pauseFadeOut);
                                }
                            }
                        }
                        break;
                    case Animation.ALL:
                        var j = this._animationLayer.length;
                        while (j--) {
                            animationStateList = this._animationLayer[j];
                            i = animationStateList.length;
                            while (i--) {
                                animationState = animationStateList[i];
                                animationState.fadeOut(fadeInTime, pauseFadeOut);
                            }
                        }
                        break;
                    case Animation.SAME_LAYER_AND_GROUP:
                    default:
                        animationStateList = this._animationLayer[layer];
                        i = animationStateList.length;
                        while (i--) {
                            animationState = animationStateList[i];
                            if (animationState.group == group) {
                                animationState.fadeOut(fadeInTime, pauseFadeOut);
                            }
                        }
                        break;
                }

                this._lastAnimationState = AnimationState._borrowObject();
                this._lastAnimationState.group = group;
                this._lastAnimationState.tweenEnabled = this.tweenEnabled;
                this._lastAnimationState.fadeIn(this._armature, animationData, fadeInTime, 1 / durationScale, loop, layer, displayControl, pauseFadeIn);

                this.addState(this._lastAnimationState);

                var slotList = this._armature._slotList;
                var slot;
                var childArmature;
                i = slotList.length;
                while (i--) {
                    slot = slotList[i];
                    childArmature = slot.getChildArmature();
                    if (childArmature) {
                        childArmature.animation.gotoAndPlay(animationName, fadeInTime);
                    }
                }

                return this._lastAnimationState;
            };

            Animation.prototype.play = function () {
                if (!this._animationDataList || this._animationDataList.length == 0) {
                    return;
                }
                if (!this._lastAnimationState) {
                    this.gotoAndPlay(this._animationDataList[0].name);
                } else if (!this._isPlaying) {
                    this._isPlaying = true;
                } else {
                    this.gotoAndPlay(this._lastAnimationState.name);
                }
            };

            Animation.prototype.stop = function () {
                this._isPlaying = false;
            };

            Animation.prototype.getState = function (name, layer) {
                if (typeof layer === "undefined") { layer = 0; }
                var l = this._animationLayer.length;
                if (l == 0) {
                    return null;
                } else if (layer >= l) {
                    layer = l - 1;
                }

                var animationStateList = this._animationLayer[layer];
                if (!animationStateList) {
                    return null;
                }
                var i = animationStateList.length;
                while (i--) {
                    if (animationStateList[i].name == name) {
                        return animationStateList[i];
                    }
                }

                return null;
            };

            Animation.prototype.hasAnimation = function (animationName) {
                var i = this._animationDataList.length;
                while (i--) {
                    if (this._animationDataList[i].name == animationName) {
                        return true;
                    }
                }

                return false;
            };

            Animation.prototype.advanceTime = function (passedTime) {
                if (!this._isPlaying) {
                    return;
                }
                passedTime *= this.timeScale;

                var l = this._armature._boneList.length;
                var i;
                var j;
                var k = l;
                var stateListLength;
                var bone;
                var boneName;
                var weigthLeft;

                var x;
                var y;
                var skewX;
                var skewY;
                var scaleX;
                var scaleY;
                var pivotX;
                var pivotY;

                var layerTotalWeight;
                var animationStateList;
                var animationState;
                var timelineState;
                var weight;
                var transform;
                var pivot;

                l--;
                while (k--) {
                    bone = this._armature._boneList[k];
                    boneName = bone.name;
                    weigthLeft = 1;

                    x = 0;
                    y = 0;
                    skewX = 0;
                    skewY = 0;
                    scaleX = 0;
                    scaleY = 0;
                    pivotX = 0;
                    pivotY = 0;

                    i = this._animationLayer.length;
                    while (i--) {
                        layerTotalWeight = 0;
                        animationStateList = this._animationLayer[i];
                        stateListLength = animationStateList.length;
                        for (j = 0; j < stateListLength; j++) {
                            animationState = animationStateList[j];
                            if (k == l) {
                                if (animationState.advanceTime(passedTime)) {
                                    this.removeState(animationState);
                                    j--;
                                    stateListLength--;
                                    continue;
                                }
                            }

                            timelineState = animationState._timelineStates[boneName];
                            if (timelineState && timelineState.tweenActive) {
                                weight = animationState._fadeWeight * animationState.weight * weigthLeft;
                                transform = timelineState.transform;
                                pivot = timelineState.pivot;
                                x += transform.x * weight;
                                y += transform.y * weight;
                                skewX += transform.skewX * weight;
                                skewY += transform.skewY * weight;
                                scaleX += transform.scaleX * weight;
                                scaleY += transform.scaleY * weight;
                                pivotX += pivot.x * weight;
                                pivotY += pivot.y * weight;

                                layerTotalWeight += weight;
                            }
                        }

                        if (layerTotalWeight >= weigthLeft) {
                            break;
                        } else {
                            weigthLeft -= layerTotalWeight;
                        }
                    }
                    transform = bone.tween;
                    pivot = bone._tweenPivot;

                    transform.x = x;
                    transform.y = y;
                    transform.skewX = skewX;
                    transform.skewY = skewY;
                    transform.scaleX = scaleX;
                    transform.scaleY = scaleY;
                    pivot.x = pivotX;
                    pivot.y = pivotY;
                }
            };

            Animation.prototype.addLayer = function (layer) {
                if (layer >= this._animationLayer.length) {
                    layer = this._animationLayer.length;
                    this._animationLayer[layer] = [];
                }
                return layer;
            };

            Animation.prototype.addState = function (animationState) {
                var animationStateList = this._animationLayer[animationState.layer];
                animationStateList.push(animationState);
            };

            Animation.prototype.removeState = function (animationState) {
                var layer = animationState.layer;
                var animationStateList = this._animationLayer[layer];
                animationStateList.splice(animationStateList.indexOf(animationState), 1);

                AnimationState._returnObject(animationState);

                if (animationStateList.length == 0 && layer == this._animationLayer.length - 1) {
                    this._animationLayer.length--;
                }
            };
            Animation.NONE = "none";
            Animation.SAME_LAYER = "sameLayer";
            Animation.SAME_GROUP = "sameGroup";
            Animation.SAME_LAYER_AND_GROUP = "sameLayerAndGroup";
            Animation.ALL = "all";
            return Animation;
        })();
        animation.Animation = Animation;
    })(dragonBones.animation || (dragonBones.animation = {}));
    var animation = dragonBones.animation;

    (function (objects) {
        var DBTransform = (function () {
            function DBTransform() {
                this.x = 0;
                this.y = 0;
                this.skewX = 0;
                this.skewY = 0;
                this.scaleX = 1;
                this.scaleY = 1;
            }
            DBTransform.prototype.getRotation = function () {
                return this.skewX;
            };

            DBTransform.prototype.setRotation = function (value) {
                this.skewX = this.skewY = value;
            };

            DBTransform.prototype.copy = function (transform) {
                this.x = transform.x;
                this.y = transform.y;
                this.skewX = transform.skewX;
                this.skewY = transform.skewY;
                this.scaleX = transform.scaleX;
                this.scaleY = transform.scaleY;
            };

            DBTransform.prototype.toString = function () {
                return "[DBTransform (x=" + this.x + " y=" + this.y + " skewX=" + this.skewX + " skewY=" + this.skewY + " scaleX=" + this.scaleX + " scaleY=" + this.scaleY + ")]";
            };
            return DBTransform;
        })();
        objects.DBTransform = DBTransform;

        var Frame = (function () {
            function Frame() {
                this.position = 0;
                this.duration = 0;
            }
            Frame.prototype.dispose = function () {
            };
            return Frame;
        })();
        objects.Frame = Frame;

        var TransformFrame = (function (_super) {
            __extends(TransformFrame, _super);
            function TransformFrame() {
                _super.call(this);

                this.tweenEasing = 0;
                this.tweenRotate = 0;
                this.displayIndex = 0;
                this.zOrder = NaN;
                this.visible = true;

                this.global = new DBTransform();
                this.transform = new DBTransform();
                this.pivot = new geom.Point();
            }
            TransformFrame.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.global = null;
                this.transform = null;

                //SkeletonData pivots
                this.pivot = null;
                this.color = null;
            };
            return TransformFrame;
        })(Frame);
        objects.TransformFrame = TransformFrame;

        var Timeline = (function () {
            function Timeline() {
                this._frameList = [];
                this.duration = 0;
                this.scale = 1;
            }
            Timeline.prototype.getFrameList = function () {
                return this._frameList;
            };

            Timeline.prototype.dispose = function () {
                var i = this._frameList.length;
                while (i--) {
                    this._frameList[i].dispose();
                }
                this._frameList.length = 0;
                this._frameList = null;
            };

            Timeline.prototype.addFrame = function (frame) {
                if (!frame) {
                    throw new Error();
                }

                if (this._frameList.indexOf(frame) < 0) {
                    this._frameList[this._frameList.length] = frame;
                } else {
                    throw new Error();
                }
            };
            return Timeline;
        })();
        objects.Timeline = Timeline;

        var TransformTimeline = (function (_super) {
            __extends(TransformTimeline, _super);
            function TransformTimeline() {
                _super.call(this);
                this.originTransform = new DBTransform();
                this.originPivot = new geom.Point();
                this.offset = 0;
                this.transformed = false;
            }
            TransformTimeline.prototype.dispose = function () {
                if (this == TransformTimeline.HIDE_TIMELINE) {
                    return;
                }
                _super.prototype.dispose.call(this);
                this.originTransform = null;
                this.originPivot = null;
            };
            TransformTimeline.HIDE_TIMELINE = new TransformTimeline();
            return TransformTimeline;
        })(Timeline);
        objects.TransformTimeline = TransformTimeline;

        var AnimationData = (function (_super) {
            __extends(AnimationData, _super);
            function AnimationData() {
                _super.call(this);
                this.frameRate = 0;
                this.loop = 0;
                this.tweenEasing = NaN;
                this.fadeInTime = 0;

                this._timelines = {};
            }
            AnimationData.prototype.getTimelines = function () {
                return this._timelines;
            };

            AnimationData.prototype.dispose = function () {
                _super.prototype.dispose.call(this);

                for (var timelineName in this._timelines) {
                    this._timelines[timelineName].dispose();
                }
                this._timelines = null;
            };

            AnimationData.prototype.getTimeline = function (timelineName) {
                return this._timelines[timelineName];
            };

            AnimationData.prototype.addTimeline = function (timeline, timelineName) {
                if (!timeline) {
                    throw new Error();
                }

                this._timelines[timelineName] = timeline;
            };
            return AnimationData;
        })(Timeline);
        objects.AnimationData = AnimationData;

        var DisplayData = (function () {
            function DisplayData() {
                this.transform = new DBTransform();
            }
            DisplayData.prototype.dispose = function () {
                this.transform = null;
                this.pivot = null;
            };
            DisplayData.ARMATURE = "armature";
            DisplayData.IMAGE = "image";
            return DisplayData;
        })();
        objects.DisplayData = DisplayData;

        var SlotData = (function () {
            function SlotData() {
                this._displayDataList = [];
                this.zOrder = 0;
                this.blendMode = "normal";
            }
            SlotData.prototype.getDisplayDataList = function () {
                return this._displayDataList;
            };

            SlotData.prototype.dispose = function () {
                var i = this._displayDataList.length;
                while (i--) {
                    this._displayDataList[i].dispose();
                }
                this._displayDataList.length = 0;
                this._displayDataList = null;
            };

            SlotData.prototype.addDisplayData = function (displayData) {
                if (!displayData) {
                    throw new Error();
                }
                if (this._displayDataList.indexOf(displayData) < 0) {
                    this._displayDataList[this._displayDataList.length] = displayData;
                } else {
                    throw new Error();
                }
            };

            SlotData.prototype.getDisplayData = function (displayName) {
                var i = this._displayDataList.length;
                while (i--) {
                    if (this._displayDataList[i].name == displayName) {
                        return this._displayDataList[i];
                    }
                }

                return null;
            };
            return SlotData;
        })();
        objects.SlotData = SlotData;

        var BoneData = (function () {
            function BoneData() {
                this.length = 0;
                this.global = new DBTransform();
                this.transform = new DBTransform();
                this.scaleMode = 1;
                this.fixedRotation = false;
            }
            BoneData.prototype.dispose = function () {
                this.global = null;
                this.transform = null;
            };
            return BoneData;
        })();
        objects.BoneData = BoneData;

        var SkinData = (function () {
            function SkinData() {
                this._slotDataList = [];
            }
            SkinData.prototype.getSlotDataList = function () {
                return this._slotDataList;
            };

            SkinData.prototype.dispose = function () {
                var i = this._slotDataList.length;
                while (i--) {
                    this._slotDataList[i].dispose();
                }
                this._slotDataList.length = 0;
                this._slotDataList = null;
            };

            SkinData.prototype.getSlotData = function (slotName) {
                var i = this._slotDataList.length;
                while (i--) {
                    if (this._slotDataList[i].name == slotName) {
                        return this._slotDataList[i];
                    }
                }
                return null;
            };

            SkinData.prototype.addSlotData = function (slotData) {
                if (!slotData) {
                    throw new Error();
                }

                if (this._slotDataList.indexOf(slotData) < 0) {
                    this._slotDataList[this._slotDataList.length] = slotData;
                } else {
                    throw new Error();
                }
            };
            return SkinData;
        })();
        objects.SkinData = SkinData;

        var ArmatureData = (function () {
            function ArmatureData() {
                this._boneDataList = [];
                this._skinDataList = [];
                this._animationDataList = [];
            }
            ArmatureData.prototype.getBoneDataList = function () {
                return this._boneDataList;
            };

            ArmatureData.prototype.getSkinDataList = function () {
                return this._skinDataList;
            };

            ArmatureData.prototype.getAnimationDataList = function () {
                return this._animationDataList;
            };

            ArmatureData.prototype.dispose = function () {
                var i = this._boneDataList.length;
                while (i--) {
                    this._boneDataList[i].dispose();
                }
                i = this._skinDataList.length;
                while (i--) {
                    this._skinDataList[i].dispose();
                }
                i = this._animationDataList.length;
                while (i--) {
                    this._animationDataList[i].dispose();
                }
                this._boneDataList.length = 0;
                this._skinDataList.length = 0;
                this._animationDataList.length = 0;
                this._boneDataList = null;
                this._skinDataList = null;
                this._animationDataList = null;
            };

            ArmatureData.prototype.getBoneData = function (boneName) {
                var i = this._boneDataList.length;
                while (i--) {
                    if (this._boneDataList[i].name == boneName) {
                        return this._boneDataList[i];
                    }
                }
                return null;
            };

            ArmatureData.prototype.getSkinData = function (skinName) {
                if (!skinName) {
                    return this._skinDataList[0];
                }
                var i = this._skinDataList.length;
                while (i--) {
                    if (this._skinDataList[i].name == skinName) {
                        return this._skinDataList[i];
                    }
                }

                return null;
            };

            ArmatureData.prototype.getAnimationData = function (animationName) {
                var i = this._animationDataList.length;
                while (i--) {
                    if (this._animationDataList[i].name == animationName) {
                        return this._animationDataList[i];
                    }
                }
                return null;
            };

            ArmatureData.prototype.addBoneData = function (boneData) {
                if (!boneData) {
                    throw new Error();
                }

                if (this._boneDataList.indexOf(boneData) < 0) {
                    this._boneDataList[this._boneDataList.length] = boneData;
                } else {
                    throw new Error();
                }
            };

            ArmatureData.prototype.addSkinData = function (skinData) {
                if (!skinData) {
                    throw new Error();
                }

                if (this._skinDataList.indexOf(skinData) < 0) {
                    this._skinDataList[this._skinDataList.length] = skinData;
                } else {
                    throw new Error();
                }
            };

            ArmatureData.prototype.addAnimationData = function (animationData) {
                if (!animationData) {
                    throw new Error();
                }

                if (this._animationDataList.indexOf(animationData) < 0) {
                    this._animationDataList[this._animationDataList.length] = animationData;
                }
            };

            ArmatureData.prototype.sortBoneDataList = function () {
                var i = this._boneDataList.length;
                if (i == 0) {
                    return;
                }

                var helpArray = [];
                while (i--) {
                    var boneData = this._boneDataList[i];
                    var level = 0;
                    var parentData = boneData;
                    while (parentData && parentData.parent) {
                        level++;
                        parentData = this.getBoneData(parentData.parent);
                    }
                    helpArray[i] = { level: level, boneData: boneData };
                }

                helpArray.sort(this.sortBoneData);

                i = helpArray.length;
                while (i--) {
                    this._boneDataList[i] = helpArray[i].boneData;
                }
            };

            ArmatureData.prototype.sortBoneData = function (object1, object2) {
                return object1.level > object2.level ? 1 : -1;
            };
            return ArmatureData;
        })();
        objects.ArmatureData = ArmatureData;

        var SkeletonData = (function () {
            function SkeletonData() {
                this._armatureDataList = [];
                this._subTexturePivots = {};
            }
            SkeletonData.prototype.getArmatureNames = function () {
                var nameList = [];
                for (var armatureDataIndex in this._armatureDataList) {
                    nameList[nameList.length] = this._armatureDataList[armatureDataIndex].name;
                }
                return nameList;
            };

            SkeletonData.prototype.getArmatureDataList = function () {
                return this._armatureDataList;
            };

            SkeletonData.prototype.dispose = function () {
                for (var armatureDataIndex in this._armatureDataList) {
                    this._armatureDataList[armatureDataIndex].dispose();
                }
                this._armatureDataList.length = 0;

                this._armatureDataList = null;
                this._subTexturePivots = null;
            };

            SkeletonData.prototype.getArmatureData = function (armatureName) {
                var i = this._armatureDataList.length;
                while (i--) {
                    if (this._armatureDataList[i].name == armatureName) {
                        return this._armatureDataList[i];
                    }
                }

                return null;
            };

            SkeletonData.prototype.addArmatureData = function (armatureData) {
                if (!armatureData) {
                    throw new Error();
                }

                if (this._armatureDataList.indexOf(armatureData) < 0) {
                    this._armatureDataList[this._armatureDataList.length] = armatureData;
                } else {
                    throw new Error();
                }
            };

            SkeletonData.prototype.removeArmatureData = function (armatureData) {
                var index = this._armatureDataList.indexOf(armatureData);
                if (index >= 0) {
                    this._armatureDataList.splice(index, 1);
                }
            };

            SkeletonData.prototype.removeArmatureDataByName = function (armatureName) {
                var i = this._armatureDataList.length;
                while (i--) {
                    if (this._armatureDataList[i].name == armatureName) {
                        this._armatureDataList.splice(i, 1);
                    }
                }
            };

            SkeletonData.prototype.getSubTexturePivot = function (subTextureName) {
                return this._subTexturePivots[subTextureName];
            };

            SkeletonData.prototype.addSubTexturePivot = function (x, y, subTextureName) {
                var point = this._subTexturePivots[subTextureName];
                if (point) {
                    point.x = x;
                    point.y = y;
                } else {
                    this._subTexturePivots[subTextureName] = point = new geom.Point(x, y);
                }

                return point;
            };

            SkeletonData.prototype.removeSubTexturePivot = function (subTextureName) {
                if (subTextureName) {
                    delete this._subTexturePivots[subTextureName];
                } else {
                    for (subTextureName in this._subTexturePivots) {
                        delete this._subTexturePivots[subTextureName];
                    }
                }
            };
            return SkeletonData;
        })();
        objects.SkeletonData = SkeletonData;

        var DataParser = (function () {
            function DataParser() {
            }
            DataParser.parseTextureAtlasData = function (rawData, scale) {
                if (typeof scale === "undefined") { scale = 1; }
                if (!rawData) {
                    throw new Error();
                }

                var textureAtlasData = {};
                textureAtlasData.__name = rawData[utils.ConstValues.A_NAME];
                var subTextureList = rawData[utils.ConstValues.SUB_TEXTURE];
                for (var index in subTextureList) {
                    var subTextureObject = subTextureList[index];
                    var subTextureName = subTextureObject[utils.ConstValues.A_NAME];
                    var subTextureData = new geom.Rectangle(Number(subTextureObject[utils.ConstValues.A_X]) / scale, Number(subTextureObject[utils.ConstValues.A_Y]) / scale, Number(subTextureObject[utils.ConstValues.A_WIDTH]) / scale, Number(subTextureObject[utils.ConstValues.A_HEIGHT]) / scale);
                    textureAtlasData[subTextureName] = subTextureData;
                }

                return textureAtlasData;
            };

            DataParser.parseSkeletonData = function (rawData) {
                if (!rawData) {
                    throw new Error();
                }

                /*var version:string = rawData[utils.ConstValues.A_VERSION];
                switch (version)
                {
                case dragonBones:
                break;
                default:
                throw new Error("Nonsupport version!");
                }*/
                var frameRate = Number(rawData[utils.ConstValues.A_FRAME_RATE]);
                var data = new SkeletonData();
                data.name = rawData[utils.ConstValues.A_NAME];

                var armatureObjectList = rawData[utils.ConstValues.ARMATURE];
                for (var index in armatureObjectList) {
                    var armatureObject = armatureObjectList[index];
                    data.addArmatureData(DataParser.parseArmatureData(armatureObject, data, frameRate));
                }

                return data;
            };

            DataParser.parseArmatureData = function (armatureObject, data, frameRate) {
                var armatureData = new ArmatureData();
                armatureData.name = armatureObject[utils.ConstValues.A_NAME];

                var boneObjectList = armatureObject[utils.ConstValues.BONE];
                for (var index in boneObjectList) {
                    var boneObject = boneObjectList[index];
                    armatureData.addBoneData(DataParser.parseBoneData(boneObject));
                }

                var skinObjectList = armatureObject[utils.ConstValues.SKIN];
                for (var index in skinObjectList) {
                    var skinObject = skinObjectList[index];
                    armatureData.addSkinData(DataParser.parseSkinData(skinObject, data));
                }

                utils.DBDataUtil.transformArmatureData(armatureData);
                armatureData.sortBoneDataList();

                var animationObjectList = armatureObject[utils.ConstValues.ANIMATION];

                for (var index in animationObjectList) {
                    var animationObject = animationObjectList[index];
                    armatureData.addAnimationData(DataParser.parseAnimationData(animationObject, armatureData, frameRate));
                }

                return armatureData;
            };

            DataParser.parseBoneData = function (boneObject) {
                var boneData = new BoneData();
                boneData.name = boneObject[utils.ConstValues.A_NAME];
                boneData.parent = boneObject[utils.ConstValues.A_PARENT];
                boneData.length = Number(boneObject[utils.ConstValues.A_LENGTH]) || 0;
                var scaleMode = Number(boneObject[utils.ConstValues.A_SCALE_MODE]);
                if (!isNaN(scaleMode) && scaleMode) {
                    boneData.scaleMode = scaleMode;
                }
                var inheritRotation = boneObject[utils.ConstValues.A_FIXED_ROTATION];
                if (inheritRotation) {
                    boneData.fixedRotation = inheritRotation;
                }

                DataParser.parseTransform(boneObject[utils.ConstValues.TRANSFORM], boneData.global);
                boneData.transform.copy(boneData.global);

                return boneData;
            };

            DataParser.parseSkinData = function (skinObject, data) {
                var skinData = new SkinData();
                skinData.name = skinObject[utils.ConstValues.A_NAME];
                var slotObjectList = skinObject[utils.ConstValues.SLOT];
                for (var index in slotObjectList) {
                    var slotObject = slotObjectList[index];
                    skinData.addSlotData(DataParser.parseSlotData(slotObject, data));
                }

                return skinData;
            };

            DataParser.parseSlotData = function (slotObject, data) {
                var slotData = new SlotData();
                slotData.name = slotObject[utils.ConstValues.A_NAME];
                slotData.parent = slotObject[utils.ConstValues.A_PARENT];
                slotData.zOrder = Number(slotObject[utils.ConstValues.A_Z_ORDER]);

                slotData.blendMode = slotObject[utils.ConstValues.A_BLENDMODE];
                if (!slotData.blendMode) {
                    slotData.blendMode = "normal";
                }

                var displayObjectList = slotObject[utils.ConstValues.DISPLAY];
                for (var index in displayObjectList) {
                    var displayObject = displayObjectList[index];
                    slotData.addDisplayData(DataParser.parseDisplayData(displayObject, data));
                }

                return slotData;
            };

            DataParser.parseDisplayData = function (displayObject, data) {
                var displayData = new DisplayData();
                displayData.name = displayObject[utils.ConstValues.A_NAME];
                displayData.type = displayObject[utils.ConstValues.A_TYPE];

                displayData.pivot = data.addSubTexturePivot(0, 0, displayData.name);

                DataParser.parseTransform(displayObject[utils.ConstValues.TRANSFORM], displayData.transform, displayData.pivot);

                return displayData;
            };

            DataParser.parseAnimationData = function (animationObject, armatureData, frameRate) {
                var animationData = new AnimationData();
                animationData.name = animationObject[utils.ConstValues.A_NAME];
                animationData.frameRate = frameRate;
                animationData.loop = Number(animationObject[utils.ConstValues.A_LOOP]) || 0;
                animationData.fadeInTime = Number(animationObject[utils.ConstValues.A_FADE_IN_TIME]);
                animationData.duration = Number(animationObject[utils.ConstValues.A_DURATION]) / frameRate;
                animationData.scale = Number(animationObject[utils.ConstValues.A_SCALE]);

                if (animationObject.hasOwnProperty(utils.ConstValues.A_TWEEN_EASING)) {
                    var tweenEase = animationObject[utils.ConstValues.A_TWEEN_EASING];
                    if (tweenEase == undefined || tweenEase == null) {
                        animationData.tweenEasing = NaN;
                    } else {
                        animationData.tweenEasing = Number(tweenEase);
                    }
                } else {
                    animationData.tweenEasing = NaN;
                }

                DataParser.parseTimeline(animationObject, animationData, DataParser.parseMainFrame, frameRate);

                var timeline;
                var timelineName;
                var timelineObjectList = animationObject[utils.ConstValues.TIMELINE];
                for (var index in timelineObjectList) {
                    var timelineObject = timelineObjectList[index];
                    timeline = DataParser.parseTransformTimeline(timelineObject, animationData.duration, frameRate);
                    timelineName = timelineObject[utils.ConstValues.A_NAME];
                    animationData.addTimeline(timeline, timelineName);
                }

                utils.DBDataUtil.addHideTimeline(animationData, armatureData);
                utils.DBDataUtil.transformAnimationData(animationData, armatureData);

                return animationData;
            };

            DataParser.parseTimeline = function (timelineObject, timeline, frameParser, frameRate) {
                var position = 0;
                var frame;
                var frameObjectList = timelineObject[utils.ConstValues.FRAME];
                for (var index in frameObjectList) {
                    var frameObject = frameObjectList[index];
                    frame = frameParser(frameObject, frameRate);
                    frame.position = position;
                    timeline.addFrame(frame);
                    position += frame.duration;
                }
                if (frame) {
                    frame.duration = timeline.duration - frame.position;
                }
            };

            DataParser.parseTransformTimeline = function (timelineObject, duration, frameRate) {
                var timeline = new TransformTimeline();
                timeline.duration = duration;

                DataParser.parseTimeline(timelineObject, timeline, DataParser.parseTransformFrame, frameRate);

                timeline.scale = Number(timelineObject[utils.ConstValues.A_SCALE]);
                timeline.offset = Number(timelineObject[utils.ConstValues.A_OFFSET]);

                return timeline;
            };

            DataParser.parseFrame = function (frameObject, frame, frameRate) {
                frame.duration = Number(frameObject[utils.ConstValues.A_DURATION]) / frameRate;
                frame.action = frameObject[utils.ConstValues.A_ACTION];
                frame.event = frameObject[utils.ConstValues.A_EVENT];
                frame.sound = frameObject[utils.ConstValues.A_SOUND];
            };

            DataParser.parseMainFrame = function (frameObject, frameRate) {
                var frame = new Frame();
                DataParser.parseFrame(frameObject, frame, frameRate);
                return frame;
            };

            DataParser.parseTransformFrame = function (frameObject, frameRate) {
                var frame = new TransformFrame();
                DataParser.parseFrame(frameObject, frame, frameRate);

                frame.visible = Number(frameObject[utils.ConstValues.A_HIDE]) != 1;

                if (frameObject.hasOwnProperty(utils.ConstValues.A_TWEEN_EASING)) {
                    var tweenEase = frameObject[utils.ConstValues.A_TWEEN_EASING];
                    if (tweenEase == undefined || tweenEase == null) {
                        frame.tweenEasing = NaN;
                    } else {
                        frame.tweenEasing = Number(tweenEase);
                    }
                } else {
                    frame.tweenEasing = 0;
                }

                frame.tweenRotate = Number(frameObject[utils.ConstValues.A_TWEEN_ROTATE]) || 0;
                frame.displayIndex = Number(frameObject[utils.ConstValues.A_DISPLAY_INDEX]) || 0;

                //
                frame.zOrder = Number(frameObject[utils.ConstValues.A_Z_ORDER]) || 0;

                DataParser.parseTransform(frameObject[utils.ConstValues.TRANSFORM], frame.global, frame.pivot);
                frame.transform.copy(frame.global);

                var colorTransformObject = frameObject[utils.ConstValues.COLOR_TRANSFORM];
                if (colorTransformObject) {
                    frame.color = new geom.ColorTransform();
                    frame.color.alphaOffset = Number(colorTransformObject[utils.ConstValues.A_ALPHA_OFFSET]);
                    frame.color.redOffset = Number(colorTransformObject[utils.ConstValues.A_RED_OFFSET]);
                    frame.color.greenOffset = Number(colorTransformObject[utils.ConstValues.A_GREEN_OFFSET]);
                    frame.color.blueOffset = Number(colorTransformObject[utils.ConstValues.A_BLUE_OFFSET]);

                    frame.color.alphaMultiplier = Number(colorTransformObject[utils.ConstValues.A_ALPHA_MULTIPLIER]) * 0.01;
                    frame.color.redMultiplier = Number(colorTransformObject[utils.ConstValues.A_RED_MULTIPLIER]) * 0.01;
                    frame.color.greenMultiplier = Number(colorTransformObject[utils.ConstValues.A_GREEN_MULTIPLIER]) * 0.01;
                    frame.color.blueMultiplier = Number(colorTransformObject[utils.ConstValues.A_BLUE_MULTIPLIER]) * 0.01;
                }

                return frame;
            };

            DataParser.parseTransform = function (transformObject, transform, pivot) {
                if (typeof pivot === "undefined") { pivot = null; }
                if (transformObject) {
                    if (transform) {
                        transform.x = Number(transformObject[utils.ConstValues.A_X]);
                        transform.y = Number(transformObject[utils.ConstValues.A_Y]);
                        transform.skewX = Number(transformObject[utils.ConstValues.A_SKEW_X]) * utils.ConstValues.ANGLE_TO_RADIAN;
                        transform.skewY = Number(transformObject[utils.ConstValues.A_SKEW_Y]) * utils.ConstValues.ANGLE_TO_RADIAN;
                        transform.scaleX = Number(transformObject[utils.ConstValues.A_SCALE_X]);
                        transform.scaleY = Number(transformObject[utils.ConstValues.A_SCALE_Y]);
                    }
                    if (pivot) {
                        pivot.x = Number(transformObject[utils.ConstValues.A_PIVOT_X]);
                        pivot.y = Number(transformObject[utils.ConstValues.A_PIVOT_Y]);
                    }
                }
            };
            return DataParser;
        })();
        objects.DataParser = DataParser;
    })(dragonBones.objects || (dragonBones.objects = {}));
    var objects = dragonBones.objects;

    (function (factorys) {
        var BaseFactory = (function (_super) {
            __extends(BaseFactory, _super);
            function BaseFactory() {
                _super.call(this);

                this._dataDic = {};
                this._textureAtlasDic = {};
                this._textureAtlasLoadingDic = {};
            }
            BaseFactory.prototype.getSkeletonData = function (name) {
                return this._dataDic[name];
            };

            BaseFactory.prototype.addSkeletonData = function (data, name) {
                if (typeof name === "undefined") { name = null; }
                if (!data) {
                    throw new Error();
                }
                name = name || data.name;
                if (!name) {
                    throw new Error("Unnamed data!");
                }
                if (this._dataDic[name]) {
                }
                this._dataDic[name] = data;
            };

            BaseFactory.prototype.removeSkeletonData = function (name) {
                delete this._dataDic[name];
            };

            BaseFactory.prototype.getTextureAtlas = function (name) {
                return this._textureAtlasDic[name];
            };

            BaseFactory.prototype.addTextureAtlas = function (textureAtlas, name) {
                if (typeof name === "undefined") { name = null; }
                if (!textureAtlas) {
                    throw new Error();
                }

                name = name || textureAtlas.name;
                if (!name) {
                    throw new Error("Unnamed data!");
                }
                if (this._textureAtlasDic[name]) {
                }
                this._textureAtlasDic[name] = textureAtlas;
            };

            BaseFactory.prototype.removeTextureAtlas = function (name) {
                delete this._textureAtlasDic[name];
            };

            BaseFactory.prototype.dispose = function (disposeData) {
                if (typeof disposeData === "undefined") { disposeData = true; }
                if (disposeData) {
                    for (var i in this._dataDic) {
                        this._dataDic[i].dispose();
                    }
                    for (var i in this._textureAtlasDic) {
                        this._textureAtlasDic[i].dispose();
                    }
                }
                this._dataDic = null;
                this._textureAtlasDic = null;
                this._textureAtlasLoadingDic = null;
                this._currentDataName = null;
                this._currentTextureAtlasName = null;
            };

            BaseFactory.prototype.buildArmature = function (armatureName, animationName, skeletonName, textureAtlasName, skinName) {
                if (skeletonName) {
                    var data = this._dataDic[skeletonName];
                    if (data) {
                        var armatureData = data.getArmatureData(armatureName);
                    }
                } else {
                    for (skeletonName in this._dataDic) {
                        data = this._dataDic[skeletonName];
                        armatureData = data.getArmatureData(armatureName);
                        if (armatureData) {
                            break;
                        }
                    }
                }

                if (!armatureData) {
                    return null;
                }

                this._currentDataName = skeletonName;
                this._currentTextureAtlasName = textureAtlasName || skeletonName;

                var armature = this._generateArmature();
                armature.name = armatureName;
                var bone;
                var boneData;
                var boneDataList = armatureData.getBoneDataList();
                for (var index in boneDataList) {
                    boneData = boneDataList[index];
                    bone = new Bone();
                    bone.name = boneData.name;
                    bone.fixedRotation = boneData.fixedRotation;
                    bone.scaleMode = boneData.scaleMode;
                    bone.origin.copy(boneData.transform);
                    if (armatureData.getBoneData(boneData.parent)) {
                        armature.addChild(bone, boneData.parent);
                    } else {
                        armature.addChild(bone, null);
                    }
                }

                if (animationName && animationName != armatureName) {
                    var animationArmatureData = data.getArmatureData(animationName);
                    if (!animationArmatureData) {
                        for (skeletonName in this._dataDic) {
                            data = this._dataDic[skeletonName];
                            animationArmatureData = data.getArmatureData(animationName);
                            if (animationArmatureData) {
                                break;
                            }
                        }
                    }
                }

                if (animationArmatureData) {
                    armature.animation.setAnimationDataList(animationArmatureData.getAnimationDataList());
                } else {
                    armature.animation.setAnimationDataList(armatureData.getAnimationDataList());
                }

                var skinData = armatureData.getSkinData(skinName);
                if (!skinData) {
                    throw new Error();
                }

                var slot;
                var displayData;
                var childArmature;
                var i;
                var helpArray = [];
                var slotData;
                var slotDataList = skinData.getSlotDataList();
                var displayDataList;
                for (var index in slotDataList) {
                    slotData = slotDataList[index];
                    bone = armature.getBone(slotData.parent);
                    if (!bone) {
                        continue;
                    }
                    displayDataList = slotData.getDisplayDataList();
                    slot = this._generateSlot();
                    slot.name = slotData.name;
                    slot._blendMode = slotData.blendMode;
                    slot._originZOrder = slotData.zOrder;
                    slot._dislayDataList = displayDataList;

                    helpArray.length = 0;
                    i = displayDataList.length;
                    while (i--) {
                        displayData = displayDataList[i];
                        switch (displayData.type) {
                            case objects.DisplayData.ARMATURE:
                                childArmature = this.buildArmature(displayData.name, null, this._currentDataName, this._currentTextureAtlasName, null);
                                if (childArmature) {
                                    helpArray[i] = childArmature;
                                }
                                break;
                            case objects.DisplayData.IMAGE:
                            default:
                                helpArray[i] = this._generateDisplay(this._textureAtlasDic[this._currentTextureAtlasName], displayData.name, displayData.pivot.x, displayData.pivot.y);
                                break;
                        }
                    }
                    slot.setDisplayList(helpArray);
                    slot._changeDisplay(0);
                    bone.addChild(slot);
                }

                armature._slotsZOrderChanged = true;
                armature.advanceTime(0);
                return armature;
            };

            BaseFactory.prototype.getTextureDisplay = function (textureName, textureAtlasName, pivotX, pivotY) {
                if (textureAtlasName) {
                    var textureAtlas = this._textureAtlasDic[textureAtlasName];
                }
                if (!textureAtlas && !textureAtlasName) {
                    for (textureAtlasName in this._textureAtlasDic) {
                        textureAtlas = this._textureAtlasDic[textureAtlasName];
                        if (textureAtlas.getRegion(textureName)) {
                            break;
                        }
                        textureAtlas = null;
                    }
                }
                if (textureAtlas) {
                    if (isNaN(pivotX) || isNaN(pivotY)) {
                        var data = this._dataDic[textureAtlasName];
                        if (data) {
                            var pivot = data.getSubTexturePivot(textureName);
                            if (pivot) {
                                pivotX = pivot.x;
                                pivotY = pivot.y;
                            }
                        }
                    }

                    return this._generateDisplay(textureAtlas, textureName, pivotX, pivotY);
                }
                return null;
            };

            /** @private */
            BaseFactory.prototype._generateArmature = function () {
                return null;
            };

            /** @private */
            BaseFactory.prototype._generateSlot = function () {
                return null;
            };

            /** @private */
            BaseFactory.prototype._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) {
                return null;
            };
            return BaseFactory;
        })(events.EventDispatcher);
        factorys.BaseFactory = BaseFactory;
    })(dragonBones.factorys || (dragonBones.factorys = {}));
    var factorys = dragonBones.factorys;

    (function (utils) {
        var ConstValues = (function () {
            function ConstValues() {
            }
            ConstValues.ANGLE_TO_RADIAN = Math.PI / 180;

            ConstValues.DRAGON_BONES = "dragonBones";
            ConstValues.ARMATURE = "armature";
            ConstValues.SKIN = "skin";
            ConstValues.BONE = "bone";
            ConstValues.SLOT = "slot";
            ConstValues.DISPLAY = "display";
            ConstValues.ANIMATION = "animation";
            ConstValues.TIMELINE = "timeline";
            ConstValues.FRAME = "frame";
            ConstValues.TRANSFORM = "transform";
            ConstValues.COLOR_TRANSFORM = "colorTransform";

            ConstValues.TEXTURE_ATLAS = "TextureAtlas";
            ConstValues.SUB_TEXTURE = "SubTexture";

            ConstValues.A_VERSION = "version";
            ConstValues.A_IMAGE_PATH = "imagePath";
            ConstValues.A_FRAME_RATE = "frameRate";
            ConstValues.A_NAME = "name";
            ConstValues.A_PARENT = "parent";
            ConstValues.A_LENGTH = "length";
            ConstValues.A_TYPE = "type";
            ConstValues.A_FADE_IN_TIME = "fadeInTime";
            ConstValues.A_DURATION = "duration";
            ConstValues.A_SCALE = "scale";
            ConstValues.A_OFFSET = "offset";
            ConstValues.A_LOOP = "loop";
            ConstValues.A_EVENT = "event";
            ConstValues.A_SOUND = "sound";
            ConstValues.A_ACTION = "action";
            ConstValues.A_HIDE = "hide";
            ConstValues.A_TWEEN_EASING = "tweenEasing";
            ConstValues.A_TWEEN_ROTATE = "tweenRotate";
            ConstValues.A_DISPLAY_INDEX = "displayIndex";
            ConstValues.A_Z_ORDER = "z";
            ConstValues.A_BLENDMODE = "blendMode";
            ConstValues.A_WIDTH = "width";
            ConstValues.A_HEIGHT = "height";
            ConstValues.A_SCALE_MODE = "scaleMode";
            ConstValues.A_FIXED_ROTATION = "fixedRotation";
            ConstValues.A_X = "x";
            ConstValues.A_Y = "y";
            ConstValues.A_SKEW_X = "skX";
            ConstValues.A_SKEW_Y = "skY";
            ConstValues.A_SCALE_X = "scX";
            ConstValues.A_SCALE_Y = "scY";
            ConstValues.A_PIVOT_X = "pX";
            ConstValues.A_PIVOT_Y = "pY";
            ConstValues.A_ALPHA_OFFSET = "aO";
            ConstValues.A_RED_OFFSET = "rO";
            ConstValues.A_GREEN_OFFSET = "gO";
            ConstValues.A_BLUE_OFFSET = "bO";
            ConstValues.A_ALPHA_MULTIPLIER = "aM";
            ConstValues.A_RED_MULTIPLIER = "rM";
            ConstValues.A_GREEN_MULTIPLIER = "gM";
            ConstValues.A_BLUE_MULTIPLIER = "bM";
            return ConstValues;
        })();
        utils.ConstValues = ConstValues;

        var TransformUtil = (function () {
            function TransformUtil() {
            }
            TransformUtil.transformPointWithParent = function (transform, parent) {
                var helpMatrix = TransformUtil._helpMatrix;
                TransformUtil.transformToMatrix(parent, helpMatrix);
                helpMatrix.invert();

                var x = transform.x;
                var y = transform.y;

                transform.x = helpMatrix.a * x + helpMatrix.c * y + helpMatrix.tx;
                transform.y = helpMatrix.d * y + helpMatrix.b * x + helpMatrix.ty;

                transform.skewX = TransformUtil.formatRadian(transform.skewX - parent.skewX);
                transform.skewY = TransformUtil.formatRadian(transform.skewY - parent.skewY);
            };

            TransformUtil.transformToMatrix = function (transform, matrix) {
                matrix.a = transform.scaleX * Math.cos(transform.skewY);
                matrix.b = transform.scaleX * Math.sin(transform.skewY);
                matrix.c = -transform.scaleY * Math.sin(transform.skewX);
                matrix.d = transform.scaleY * Math.cos(transform.skewX);
                matrix.tx = transform.x;
                matrix.ty = transform.y;
            };

            TransformUtil.formatRadian = function (radian) {
                radian %= TransformUtil.DOUBLE_PI;
                if (radian > Math.PI) {
                    radian -= TransformUtil.DOUBLE_PI;
                }
                if (radian < -Math.PI) {
                    radian += TransformUtil.DOUBLE_PI;
                }
                return radian;
            };
            TransformUtil.DOUBLE_PI = Math.PI * 2;
            TransformUtil._helpMatrix = new geom.Matrix();
            return TransformUtil;
        })();
        utils.TransformUtil = TransformUtil;

        var DBDataUtil = (function () {
            function DBDataUtil() {
            }
            DBDataUtil.transformArmatureData = function (armatureData) {
                var boneDataList = armatureData.getBoneDataList();
                var i = boneDataList.length;
                var boneData;
                var parentBoneData;
                while (i--) {
                    boneData = boneDataList[i];
                    if (boneData.parent) {
                        parentBoneData = armatureData.getBoneData(boneData.parent);
                        if (parentBoneData) {
                            boneData.transform.copy(boneData.global);
                            TransformUtil.transformPointWithParent(boneData.transform, parentBoneData.global);
                        }
                    }
                }
            };

            DBDataUtil.transformArmatureDataAnimations = function (armatureData) {
                var animationDataList = armatureData.getAnimationDataList();
                var i = animationDataList.length;
                while (i--) {
                    DBDataUtil.transformAnimationData(animationDataList[i], armatureData);
                }
            };

            DBDataUtil.transformAnimationData = function (animationData, armatureData) {
                var skinData = armatureData.getSkinData(null);
                var boneDataList = armatureData.getBoneDataList();
                var slotDataList = skinData.getSlotDataList();
                var i = boneDataList.length;

                var boneData;
                var timeline;
                var slotData;
                var displayData;
                var parentTimeline;
                var frameList;
                var originTransform;
                var originPivot;
                var prevFrame;
                var frame;
                var frameListLength;

                while (i--) {
                    boneData = boneDataList[i];
                    timeline = animationData.getTimeline(boneData.name);
                    if (!timeline) {
                        continue;
                    }

                    slotData = null;

                    for (var slotIndex in slotDataList) {
                        slotData = slotDataList[slotIndex];
                        if (slotData.parent == boneData.name) {
                            break;
                        }
                    }

                    parentTimeline = boneData.parent ? animationData.getTimeline(boneData.parent) : null;

                    frameList = timeline.getFrameList();

                    originTransform = null;
                    originPivot = null;
                    prevFrame = null;
                    frameListLength = frameList.length;
                    for (var j = 0; j < frameListLength; j++) {
                        frame = frameList[j];
                        if (parentTimeline) {
                            //tweenValues to transform.
                            DBDataUtil._helpTransform1.copy(frame.global);

                            //get transform from parent timeline.
                            DBDataUtil.getTimelineTransform(parentTimeline, frame.position, DBDataUtil._helpTransform2);
                            TransformUtil.transformPointWithParent(DBDataUtil._helpTransform1, DBDataUtil._helpTransform2);

                            //transform to tweenValues.
                            frame.transform.copy(DBDataUtil._helpTransform1);
                        } else {
                            frame.transform.copy(frame.global);
                        }

                        frame.transform.x -= boneData.transform.x;
                        frame.transform.y -= boneData.transform.y;
                        frame.transform.skewX -= boneData.transform.skewX;
                        frame.transform.skewY -= boneData.transform.skewY;
                        frame.transform.scaleX -= boneData.transform.scaleX;
                        frame.transform.scaleY -= boneData.transform.scaleY;

                        if (!timeline.transformed) {
                            if (slotData) {
                                frame.zOrder -= slotData.zOrder;
                            }
                        }

                        if (!originTransform) {
                            originTransform = timeline.originTransform;
                            originTransform.copy(frame.transform);
                            originTransform.skewX = TransformUtil.formatRadian(originTransform.skewX);
                            originTransform.skewY = TransformUtil.formatRadian(originTransform.skewY);
                            originPivot = timeline.originPivot;
                            originPivot.x = frame.pivot.x;
                            originPivot.y = frame.pivot.y;
                        }

                        frame.transform.x -= originTransform.x;
                        frame.transform.y -= originTransform.y;
                        frame.transform.skewX = TransformUtil.formatRadian(frame.transform.skewX - originTransform.skewX);
                        frame.transform.skewY = TransformUtil.formatRadian(frame.transform.skewY - originTransform.skewY);
                        frame.transform.scaleX -= originTransform.scaleX;
                        frame.transform.scaleY -= originTransform.scaleY;

                        if (!timeline.transformed) {
                            frame.pivot.x -= originPivot.x;
                            frame.pivot.y -= originPivot.y;
                        }

                        if (prevFrame) {
                            var dLX = frame.transform.skewX - prevFrame.transform.skewX;

                            if (prevFrame.tweenRotate) {
                                if (prevFrame.tweenRotate > 0) {
                                    if (dLX < 0) {
                                        frame.transform.skewX += Math.PI * 2;
                                        frame.transform.skewY += Math.PI * 2;
                                    }

                                    if (prevFrame.tweenRotate > 1) {
                                        frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate - 1);
                                        frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate - 1);
                                    }
                                } else {
                                    if (dLX > 0) {
                                        frame.transform.skewX -= Math.PI * 2;
                                        frame.transform.skewY -= Math.PI * 2;
                                    }

                                    if (prevFrame.tweenRotate < 1) {
                                        frame.transform.skewX += Math.PI * 2 * (prevFrame.tweenRotate + 1);
                                        frame.transform.skewY += Math.PI * 2 * (prevFrame.tweenRotate + 1);
                                    }
                                }
                            } else {
                                frame.transform.skewX = prevFrame.transform.skewX + TransformUtil.formatRadian(frame.transform.skewX - prevFrame.transform.skewX);
                                frame.transform.skewY = prevFrame.transform.skewY + TransformUtil.formatRadian(frame.transform.skewY - prevFrame.transform.skewY);
                            }
                        }

                        prevFrame = frame;
                    }
                    timeline.transformed = true;
                }
            };

            DBDataUtil.getTimelineTransform = function (timeline, position, retult) {
                var frameList = timeline.getFrameList();
                var i = frameList.length;

                var currentFrame;
                var tweenEasing;
                var progress;
                var nextFrame;
                while (i--) {
                    currentFrame = frameList[i];
                    if (currentFrame.position <= position && currentFrame.position + currentFrame.duration > position) {
                        tweenEasing = currentFrame.tweenEasing;
                        if (i == frameList.length - 1 || isNaN(tweenEasing) || position == currentFrame.position) {
                            retult.copy(currentFrame.global);
                        } else {
                            progress = (position - currentFrame.position) / currentFrame.duration;
                            if (tweenEasing) {
                                progress = animation.TimelineState.getEaseValue(progress, tweenEasing);
                            }

                            nextFrame = frameList[i + 1];

                            retult.x = currentFrame.global.x + (nextFrame.global.x - currentFrame.global.x) * progress;
                            retult.y = currentFrame.global.y + (nextFrame.global.y - currentFrame.global.y) * progress;
                            retult.skewX = TransformUtil.formatRadian(currentFrame.global.skewX + (nextFrame.global.skewX - currentFrame.global.skewX) * progress);
                            retult.skewY = TransformUtil.formatRadian(currentFrame.global.skewY + (nextFrame.global.skewY - currentFrame.global.skewY) * progress);
                            retult.scaleX = currentFrame.global.scaleX + (nextFrame.global.scaleX - currentFrame.global.scaleX) * progress;
                            retult.scaleY = currentFrame.global.scaleY + (nextFrame.global.scaleY - currentFrame.global.scaleY) * progress;
                        }
                        break;
                    }
                }
            };

            DBDataUtil.addHideTimeline = function (animationData, armatureData) {
                var boneDataList = armatureData.getBoneDataList();
                var i = boneDataList.length;

                var boneData;
                var boneName;
                while (i--) {
                    boneData = boneDataList[i];
                    boneName = boneData.name;
                    if (!animationData.getTimeline(boneName)) {
                        animationData.addTimeline(objects.TransformTimeline.HIDE_TIMELINE, boneName);
                    }
                }
            };
            DBDataUtil._helpTransform1 = new objects.DBTransform();
            DBDataUtil._helpTransform2 = new objects.DBTransform();
            return DBDataUtil;
        })();
        utils.DBDataUtil = DBDataUtil;
    })(dragonBones.utils || (dragonBones.utils = {}));
    var utils = dragonBones.utils;

    /** @private */
    var DBObject = (function () {
        function DBObject() {
            this.global = new objects.DBTransform();
            this.origin = new objects.DBTransform();
            this.offset = new objects.DBTransform();
            this.tween = new objects.DBTransform();
            this.tween.scaleX = this.tween.scaleY = 0;

            this._globalTransformMatrix = new geom.Matrix();

            this._visible = true;
            this._isColorChanged = false;
            this._isDisplayOnStage = false;
            this._scaleType = 0;

            this.fixedRotation = false;
        }
        DBObject.prototype.getVisible = function () {
            return this._visible;
        };

        DBObject.prototype.setVisible = function (value) {
            this._visible = value;
        };

        /** @private */
        DBObject.prototype._setParent = function (value) {
            this.parent = value;
        };

        /** @private */
        DBObject.prototype._setArmature = function (value) {
            if (this.armature) {
                this.armature._removeDBObject(this);
            }
            this.armature = value;
            if (this.armature) {
                this.armature._addDBObject(this);
            }
        };

        DBObject.prototype.dispose = function () {
            this.parent = null;
            this.armature = null;
            this.global = null;
            this.origin = null;
            this.offset = null;
            this.tween = null;
            this._globalTransformMatrix = null;
        };

        /** @private */
        DBObject.prototype._update = function () {
            this.global.scaleX = (this.origin.scaleX + this.tween.scaleX) * this.offset.scaleX;
            this.global.scaleY = (this.origin.scaleY + this.tween.scaleY) * this.offset.scaleY;

            if (this.parent) {
                var x = this.origin.x + this.offset.x + this.tween.x;
                var y = this.origin.y + this.offset.y + this.tween.y;
                var parentMatrix = this.parent._globalTransformMatrix;

                this._globalTransformMatrix.tx = this.global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                this._globalTransformMatrix.ty = this.global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty;

                if (this.fixedRotation) {
                    this.global.skewX = this.origin.skewX + this.offset.skewX + this.tween.skewX;
                    this.global.skewY = this.origin.skewY + this.offset.skewY + this.tween.skewY;
                } else {
                    this.global.skewX = this.origin.skewX + this.offset.skewX + this.tween.skewX + this.parent.global.skewX;
                    this.global.skewY = this.origin.skewY + this.offset.skewY + this.tween.skewY + this.parent.global.skewY;
                }

                if (this.parent.scaleMode >= this._scaleType) {
                    this.global.scaleX *= this.parent.global.scaleX;
                    this.global.scaleY *= this.parent.global.scaleY;
                }
            } else {
                this._globalTransformMatrix.tx = this.global.x = this.origin.x + this.offset.x + this.tween.x;
                this._globalTransformMatrix.ty = this.global.y = this.origin.y + this.offset.y + this.tween.y;

                this.global.skewX = this.origin.skewX + this.offset.skewX + this.tween.skewX;
                this.global.skewY = this.origin.skewY + this.offset.skewY + this.tween.skewY;
            }
            this._globalTransformMatrix.a = this.global.scaleX * Math.cos(this.global.skewY);
            this._globalTransformMatrix.b = this.global.scaleX * Math.sin(this.global.skewY);
            this._globalTransformMatrix.c = -this.global.scaleY * Math.sin(this.global.skewX);
            this._globalTransformMatrix.d = this.global.scaleY * Math.cos(this.global.skewX);
        };
        return DBObject;
    })();
    dragonBones.DBObject = DBObject;

    var Slot = (function (_super) {
        __extends(Slot, _super);
        function Slot(displayBrideg) {
            _super.call(this);
            this._displayBridge = displayBrideg;
            this._displayList = [];
            this._displayIndex = -1;
            this._scaleType = 1;

            this._originZOrder = 0;
            this._tweenZorder = 0;
            this._offsetZOrder = 0;

            this._isDisplayOnStage = false;
            this._isHideDisplay = false;

            this._blendMode = "normal";
            this._displayBridge.updateBlendMode(this._blendMode);
        }
        Slot.prototype.getZOrder = function () {
            return this._originZOrder + this._tweenZorder + this._offsetZOrder;
        };

        Slot.prototype.setZOrder = function (value) {
            if (this.getZOrder() != value) {
                this._offsetZOrder = value - this._originZOrder - this._tweenZorder;
                if (this.armature) {
                    this.armature._slotsZOrderChanged = true;
                }
            }
        };

        Slot.prototype.getDisplay = function () {
            var display = this._displayList[this._displayIndex];
            if (display instanceof Armature) {
                return display.getDisplay();
            }
            return display;
        };

        Slot.prototype.setDisplay = function (value) {
            this._displayList[this._displayIndex] = value;
            this._setDisplay(value);
        };

        Slot.prototype.getBlendMode = function () {
            return this._blendMode;
        };

        Slot.prototype.setBlendMode = function (value) {
            if (this._blendMode != value) {
                this._blendMode = value;
                if (this._displayBridge.getDisplay()) {
                    this._displayBridge.updateBlendMode(this._blendMode);
                }
            }
        };

        Slot.prototype.getChildArmature = function () {
            var display = this._displayList[this._displayIndex];
            if (display instanceof Armature) {
                return display;
            }
            return null;
        };

        Slot.prototype.setChildArmature = function (value) {
            this._displayList[this._displayIndex] = value;
            if (value) {
                this._setDisplay(value.getDisplay());
            }
        };

        Slot.prototype.getDisplayList = function () {
            return this._displayList;
        };

        Slot.prototype.setDisplayList = function (value) {
            if (!value) {
                throw new Error();
            }
            var i = this._displayList.length = value.length;
            while (i--) {
                this._displayList[i] = value[i];
            }
            if (this._displayIndex >= 0) {
                var displayIndexBackup = this._displayIndex;
                this._displayIndex = -1;
                this._changeDisplay(displayIndexBackup);
            }
        };

        Slot.prototype._setDisplay = function (display) {
            if (this._displayBridge.getDisplay()) {
                this._displayBridge.setDisplay(display);
            } else {
                this._displayBridge.setDisplay(display);
                if (this.armature) {
                    this._displayBridge.addDisplay(this.armature.getDisplay(), -1);
                    this.armature._slotsZOrderChanged = true;
                }
            }

            this.updateChildArmatureAnimation();
            if (display) {
                this._displayBridge.updateBlendMode(this._blendMode);
            }

            if (!this._isHideDisplay && this._displayBridge.getDisplay()) {
                this._isDisplayOnStage = true;
            } else {
                this._isDisplayOnStage = false;
            }
        };

        /** @private */
        Slot.prototype._changeDisplay = function (displayIndex) {
            if (displayIndex < 0) {
                if (!this._isHideDisplay) {
                    this._isHideDisplay = true;
                    this._displayBridge.removeDisplay();
                    this.updateChildArmatureAnimation();
                }
            } else {
                if (this._isHideDisplay) {
                    this._isHideDisplay = false;
                    var changeShowState = true;
                    if (this.armature) {
                        this._displayBridge.addDisplay(this.armature.getDisplay(), -1);
                        this.armature._slotsZOrderChanged = true;
                    }
                }

                var length = this._displayList.length;
                if (displayIndex >= length && length > 0) {
                    displayIndex = length - 1;
                }
                if (this._displayIndex != displayIndex) {
                    this._displayIndex = displayIndex;

                    var display = this._displayList[this._displayIndex];
                    if (display instanceof Armature) {
                        this._setDisplay(display.getDisplay());
                    } else {
                        this._setDisplay(display);
                    }

                    if (this._dislayDataList && this._displayIndex <= this._dislayDataList.length) {
                        this.origin.copy(this._dislayDataList[this._displayIndex].transform);
                    }
                } else if (changeShowState) {
                    this.updateChildArmatureAnimation();
                }
            }

            if (!this._isHideDisplay && this._displayBridge.getDisplay()) {
                this._isDisplayOnStage = true;
            } else {
                this._isDisplayOnStage = false;
            }
        };

        Slot.prototype.setVisible = function (value) {
            if (value != this._visible) {
                this._visible = value;
                this._updateVisible(this._visible);
            }
        };

        /** @private */
        Slot.prototype._setArmature = function (value) {
            _super.prototype._setArmature.call(this, value);
            if (this.armature) {
                this.armature._slotsZOrderChanged = true;
                this._displayBridge.addDisplay(this.armature.getDisplay(), -1);
            } else {
                this._displayBridge.removeDisplay();
            }
        };

        Slot.prototype.dispose = function () {
            if (!this._displayBridge) {
                return;
            }
            _super.prototype.dispose.call(this);

            this._displayBridge.dispose();
            this._displayList.length = 0;

            this._displayBridge = null;
            this._displayList = null;
            this._dislayDataList = null;
        };

        /** @private */
        Slot.prototype._update = function () {
            _super.prototype._update.call(this);
            if (this._isDisplayOnStage) {
                var pivotX = this.parent._tweenPivot.x;
                var pivotY = this.parent._tweenPivot.y;
                if (pivotX || pivotY) {
                    var parentMatrix = this.parent._globalTransformMatrix;
                    this._globalTransformMatrix.tx += parentMatrix.a * pivotX + parentMatrix.c * pivotY;
                    this._globalTransformMatrix.ty += parentMatrix.b * pivotX + parentMatrix.d * pivotY;
                }

                this._displayBridge.updateTransform(this._globalTransformMatrix, this.global);
            }
        };

        /** @private */
        Slot.prototype._updateVisible = function (value) {
            this._displayBridge.setVisible(this.parent.getVisible() && this._visible && value);
        };

        Slot.prototype.updateChildArmatureAnimation = function () {
            var childArmature = this.getChildArmature();

            if (childArmature) {
                if (this._isHideDisplay) {
                    childArmature.animation.stop();
                    childArmature.animation._lastAnimationState = null;
                } else {
                    var lastAnimationName = this.armature ? this.armature.animation.getLastAnimationName() : null;
                    if (lastAnimationName && childArmature.animation.hasAnimation(lastAnimationName)) {
                        childArmature.animation.gotoAndPlay(lastAnimationName);
                    } else {
                        childArmature.animation.play();
                    }
                }
            }
        };
        return Slot;
    })(DBObject);
    dragonBones.Slot = Slot;

    var Bone = (function (_super) {
        __extends(Bone, _super);
        function Bone() {
            _super.call(this);
            this._children = [];
            this._scaleType = 2;

            this._tweenPivot = new geom.Point();

            this.scaleMode = 1;
        }
        Bone.prototype.setVisible = function (value) {
            if (this._visible != value) {
                this._visible = value;
                var i = this._children.length;
                while (i--) {
                    var child = this._children[i];
                    if (child instanceof Slot) {
                        child._updateVisible(this._visible);
                    }
                }
            }
        };

        /** @private */
        Bone.prototype._setArmature = function (value) {
            _super.prototype._setArmature.call(this, value);
            var i = this._children.length;
            while (i--) {
                this._children[i]._setArmature(this.armature);
            }
        };

        Bone.prototype.dispose = function () {
            if (!this._children) {
                return;
            }
            _super.prototype.dispose.call(this);

            var i = this._children.length;
            while (i--) {
                this._children[i].dispose();
            }
            this._children.length = 0;

            this._children = null;
            this._tweenPivot = null;

            this.slot = null;
        };

        Bone.prototype.contains = function (child) {
            if (!child) {
                throw new Error();
            }
            if (child == this) {
                return false;
            }
            var ancestor = child;
            while (!(ancestor == this || ancestor == null)) {
                ancestor = ancestor.parent;
            }
            return ancestor == this;
        };

        Bone.prototype.addChild = function (child) {
            if (!child) {
                throw new Error();
            }

            if (child == this || (child instanceof Bone && child.contains(this))) {
                throw new Error("An Bone cannot be added as a child to itself or one of its children (or children's children, etc.)");
            }

            if (child.parent) {
                child.parent.removeChild(child);
            }
            this._children[this._children.length] = child;
            child._setParent(this);
            child._setArmature(this.armature);

            if (!this.slot && child instanceof Slot) {
                this.slot = child;
            }
        };

        Bone.prototype.removeChild = function (child) {
            if (!child) {
                throw new Error();
            }

            var index = this._children.indexOf(child);
            if (index >= 0) {
                this._children.splice(index, 1);
                child._setParent(null);
                child._setArmature(null);

                if (child == this.slot) {
                    this.slot = null;
                }
            } else {
                throw new Error();
            }
        };

        Bone.prototype.getSlots = function () {
            var slotList = [];
            var i = this._children.length;
            while (i--) {
                if (this._children[i] instanceof Slot) {
                    slotList.unshift(this._children[i]);
                }
            }
            return slotList;
        };

        /** @private */
        Bone.prototype._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            if (frame) {
                var mixingType = animationState.getMixingTransform(this.name);
                if (animationState.displayControl && (mixingType == 2 || mixingType == -1)) {
                    if (!this.displayController || this.displayController == animationState.name) {
                        var tansformFrame = frame;
                        if (this.slot) {
                            var displayIndex = tansformFrame.displayIndex;
                            if (displayIndex >= 0) {
                                if (!isNaN(tansformFrame.zOrder) && tansformFrame.zOrder != this.slot._tweenZorder) {
                                    this.slot._tweenZorder = tansformFrame.zOrder;
                                    this.armature._slotsZOrderChanged = true;
                                }
                            }
                            this.slot._changeDisplay(displayIndex);
                            this.slot._updateVisible(tansformFrame.visible);
                        }
                    }
                }

                if (frame.event && this.armature.hasEventListener(events.FrameEvent.BONE_FRAME_EVENT)) {
                    var frameEvent = new events.FrameEvent(events.FrameEvent.BONE_FRAME_EVENT);
                    frameEvent.bone = this;
                    frameEvent.animationState = animationState;
                    frameEvent.frameLabel = frame.event;
                    this.armature._eventList.push(frameEvent);
                }

                if (frame.sound && Bone._soundManager.hasEventListener(events.SoundEvent.SOUND)) {
                    var soundEvent = new events.SoundEvent(events.SoundEvent.SOUND);
                    soundEvent.armature = this.armature;
                    soundEvent.animationState = animationState;
                    soundEvent.sound = frame.sound;
                    Bone._soundManager.dispatchEvent(soundEvent);
                }

                if (frame.action) {
                    for (var index in this._children) {
                        if (this._children[index] instanceof Slot) {
                            var childArmature = this._children[index].getChildArmature();
                            if (childArmature) {
                                childArmature.animation.gotoAndPlay(frame.action);
                            }
                        }
                    }
                }
            } else {
                if (this.slot) {
                    this.slot._changeDisplay(-1);
                }
            }
        };

        /** @private */
        Bone.prototype._updateColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier, isColorChanged) {
            if (isColorChanged || this._isColorChanged) {
                this.slot._displayBridge.updateColor(aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier);
            }
            this._isColorChanged = isColorChanged;
        };
        Bone._soundManager = events.SoundEventManager.getInstance();
        return Bone;
    })(DBObject);
    dragonBones.Bone = Bone;

    var Armature = (function (_super) {
        __extends(Armature, _super);
        function Armature(display) {
            _super.call(this);

            this.animation = new animation.Animation(this);

            this._display = display;
            this._slotsZOrderChanged = false;
            this._slotList = [];
            this._boneList = [];
            this._eventList = [];
        }
        Armature.prototype.getDisplay = function () {
            return this._display;
        };

        Armature.prototype.dispose = function () {
            if (!this.animation) {
                return;
            }

            this.animation.dispose();

            var i = this._slotList.length;
            while (i--) {
                this._slotList[i].dispose();
            }

            i = this._boneList.length;
            while (i--) {
                this._boneList[i].dispose();
            }

            this._slotList.length = 0;
            this._boneList.length = 0;
            this._eventList.length = 0;

            this._slotList = null;
            this._boneList = null;
            this._eventList = null;
            this._display = null;

            this.animation = null;
        };

        Armature.prototype.advanceTime = function (passedTime) {
            this.animation.advanceTime(passedTime);
            passedTime *= this.animation.timeScale;

            var i = this._boneList.length;
            while (i--) {
                this._boneList[i]._update();
            }
            i = this._slotList.length;
            var slot;
            while (i--) {
                slot = this._slotList[i];
                slot._update();
                if (slot._isDisplayOnStage) {
                    var childArmature = slot.getChildArmature();
                    if (childArmature) {
                        childArmature.advanceTime(passedTime);
                    }
                }
            }

            if (this._slotsZOrderChanged) {
                this.updateSlotsZOrder();
                if (this.hasEventListener(events.ArmatureEvent.Z_ORDER_UPDATED)) {
                    this.dispatchEvent(new events.ArmatureEvent(events.ArmatureEvent.Z_ORDER_UPDATED));
                }
            }

            if (this._eventList.length) {
                var length = this._eventList.length;
                for (i = 0; i < length; i++) {
                    this.dispatchEvent(this._eventList[i]);
                }
                this._eventList.length = 0;
            }
        };

        Armature.prototype.getSlots = function (returnCopy) {
            if (typeof returnCopy === "undefined") { returnCopy = true; }
            return returnCopy ? this._slotList.concat() : this._slotList;
        };

        Armature.prototype.getBones = function (returnCopy) {
            if (typeof returnCopy === "undefined") { returnCopy = true; }
            return returnCopy ? this._boneList.concat() : this._boneList;
        };

        Armature.prototype.getSlot = function (slotName) {
            var i = this._slotList.length;
            while (i--) {
                if (this._slotList[i].name == slotName) {
                    return this._slotList[i];
                }
            }
            return null;
        };

        Armature.prototype.getSlotByDisplay = function (display) {
            if (display) {
                var i = this._slotList.length;
                while (i--) {
                    if (this._slotList[i].getDisplay() == display) {
                        return this._slotList[i];
                    }
                }
            }
            return null;
        };

        Armature.prototype.removeSlot = function (slot) {
            if (!slot) {
                throw new Error();
            }

            if (this._slotList.indexOf(slot) >= 0) {
                slot.parent.removeChild(slot);
            } else {
                throw new Error();
            }
        };

        Armature.prototype.removeSlotByName = function (slotName) {
            if (!slotName) {
                return;
            }

            var slot = this.getSlot(slotName);
            if (slot) {
                this.removeSlot(slot);
            }
        };

        Armature.prototype.getBone = function (boneName) {
            var i = this._boneList.length;
            while (i--) {
                if (this._boneList[i].name == boneName) {
                    return this._boneList[i];
                }
            }
            return null;
        };

        Armature.prototype.getBoneByDisplay = function (display) {
            var slot = this.getSlotByDisplay(display);
            return slot ? slot.parent : null;
        };

        Armature.prototype.removeBone = function (bone) {
            if (!bone) {
                throw new Error();
            }

            if (this._boneList.indexOf(bone) >= 0) {
                if (bone.parent) {
                    bone.parent.removeChild(bone);
                } else {
                    bone._setArmature(null);
                }
            } else {
                throw new Error();
            }
        };

        Armature.prototype.removeBoneByName = function (boneName) {
            if (!boneName) {
                return;
            }

            var bone = this.getBone(boneName);
            if (bone) {
                this.removeBone(bone);
            }
        };

        Armature.prototype.addChild = function (object, parentName) {
            if (!object) {
                throw new Error();
            }
            if (parentName) {
                var boneParent = this.getBone(parentName);
                if (boneParent) {
                    boneParent.addChild(object);
                } else {
                    throw new Error();
                }
            } else {
                if (object.parent) {
                    object.parent.removeChild(object);
                }
                object._setArmature(this);
            }
        };

        Armature.prototype.updateSlotsZOrder = function () {
            this._slotList.sort(this.sortSlot);
            var i = this._slotList.length;
            var slot;
            while (i--) {
                slot = this._slotList[i];
                if (slot._isDisplayOnStage) {
                    slot._displayBridge.addDisplay(this._display, -1);
                }
            }

            this._slotsZOrderChanged = false;
        };

        /** @private */
        Armature.prototype._addDBObject = function (object) {
            if (object instanceof Slot) {
                var slot = object;
                if (this._slotList.indexOf(slot) < 0) {
                    this._slotList[this._slotList.length] = slot;
                }
            } else if (object instanceof Bone) {
                var bone = object;
                if (this._boneList.indexOf(bone) < 0) {
                    this._boneList[this._boneList.length] = bone;
                    this._sortBoneList();
                }
            }
        };

        /** @private */
        Armature.prototype._removeDBObject = function (object) {
            if (object instanceof Slot) {
                var slot = object;
                var index = this._slotList.indexOf(slot);
                if (index >= 0) {
                    this._slotList.splice(index, 1);
                }
            } else if (object instanceof Bone) {
                var bone = object;
                index = this._boneList.indexOf(bone);
                if (index >= 0) {
                    this._boneList.splice(index, 1);
                }
            }
        };

        /** @private */
        Armature.prototype._sortBoneList = function () {
            var i = this._boneList.length;
            if (i == 0) {
                return;
            }
            var helpArray = [];
            var level;
            var bone;
            var boneParent;
            while (i--) {
                level = 0;
                bone = this._boneList[i];
                boneParent = bone;
                while (boneParent) {
                    level++;
                    boneParent = boneParent.parent;
                }
                helpArray[i] = { level: level, bone: bone };
            }

            helpArray.sort(this.sortBone);

            i = helpArray.length;
            while (i--) {
                this._boneList[i] = helpArray[i].bone;
            }
        };

        /** @private */
        Armature.prototype._arriveAtFrame = function (frame, timelineState, animationState, isCross) {
            if (frame.event && this.hasEventListener(events.FrameEvent.ANIMATION_FRAME_EVENT)) {
                var frameEvent = new events.FrameEvent(events.FrameEvent.ANIMATION_FRAME_EVENT);
                frameEvent.animationState = animationState;
                frameEvent.frameLabel = frame.event;
                this._eventList.push(frameEvent);
            }

            if (frame.sound && Armature._soundManager.hasEventListener(events.SoundEvent.SOUND)) {
                var soundEvent = new events.SoundEvent(events.SoundEvent.SOUND);
                soundEvent.armature = this;
                soundEvent.animationState = animationState;
                soundEvent.sound = frame.sound;
                Armature._soundManager.dispatchEvent(soundEvent);
            }

            if (frame.action) {
                if (animationState.isPlaying) {
                    this.animation.gotoAndPlay(frame.action);
                }
            }
        };

        Armature.prototype.sortSlot = function (slot1, slot2) {
            return slot1.getZOrder() < slot2.getZOrder() ? 1 : -1;
        };

        Armature.prototype.sortBone = function (object1, object2) {
            return object1.level < object2.level ? 1 : -1;
        };
        Armature._soundManager = events.SoundEventManager.getInstance();
        return Armature;
    })(events.EventDispatcher);
    dragonBones.Armature = Armature;
})(dragonBones || (dragonBones = {}));

var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var dragonBones;
(function (dragonBones) {
    (function (display) {
        var DragonBonesEgretBridge = (function () {
            function DragonBonesEgretBridge() {
            }
            DragonBonesEgretBridge.prototype.getVisible = function () {
                return this._display ? this._display.visible : false;
            };

            DragonBonesEgretBridge.prototype.setVisible = function (value) {
                if (this._display) {
                    this._display.visible = value;
                }
            };

            DragonBonesEgretBridge.prototype.getDisplay = function () {
                return this._display;
            };

            DragonBonesEgretBridge.prototype.setDisplay = function (value) {
                if (this._display == value) {
                    return;
                }
                if (this._display) {
                    var parent = this._display.parent;
                    if (parent) {
                        var index = parent.getChildIndex(this._display);
                    }
                    this.removeDisplay();
                }
                this._display = value;
                this.addDisplay(parent, index);
            };

            DragonBonesEgretBridge.prototype.dispose = function () {
                this._display = null;
            };

            DragonBonesEgretBridge.prototype.updateTransform = function (matrix, transform) {
                //                this._display.rotation = transform.getRotation() * 180 / Math.PI
                this._display._x = matrix.tx;
                this._display._y = matrix.ty;
                this._display._skewX = transform.skewX * DragonBonesEgretBridge.RADIAN_TO_ANGLE;
                this._display._skewY = transform.skewY * DragonBonesEgretBridge.RADIAN_TO_ANGLE;
                this._display._scaleX = transform.scaleX;
                this._display._scaleY = transform.scaleY;
            };

            DragonBonesEgretBridge.prototype.updateColor = function (aOffset, rOffset, gOffset, bOffset, aMultiplier, rMultiplier, gMultiplier, bMultiplier) {
                if (this._display) {
                    this._display._alpha = aMultiplier;
                    //todo
                }
            };

            DragonBonesEgretBridge.prototype.updateBlendMode = function (blendMode) {
                if (this._display && blendMode) {
                    this._display.blendMode = egret.BlendMode.getBlendMode(blendMode);
                }
            };

            DragonBonesEgretBridge.prototype.addDisplay = function (container, index) {
                var parent = container;
                if (parent && this._display) {
                    if (this._display._parent) {
                        this._display._parent.removeChild(this._display);
                    }

                    if (index < 0) {
                        parent.addChild(this._display);
                    } else {
                        parent.addChildAt(this._display, Math.min(index, parent.numChildren));
                    }
                }
            };

            DragonBonesEgretBridge.prototype.removeDisplay = function () {
                if (this._display && this._display._parent) {
                    this._display._parent.removeChild(this._display);
                }
            };
            DragonBonesEgretBridge.RADIAN_TO_ANGLE = 180 / Math.PI;
            return DragonBonesEgretBridge;
        })();
        display.DragonBonesEgretBridge = DragonBonesEgretBridge;
    })(dragonBones.display || (dragonBones.display = {}));
    var display = dragonBones.display;

    (function (textures) {
        var EgretTextureAtlas = (function () {
            function EgretTextureAtlas(texture, textureAtlasRawData, scale) {
                if (typeof scale === "undefined") { scale = 1; }
                this.texture = texture;
                this.textureAtlasRawData = textureAtlasRawData;
                this._textureData = {};
                this.scale = scale;
                this.name = textureAtlasRawData[dragonBones.utils.ConstValues.A_NAME];
                this.parseData(textureAtlasRawData);
                this.spriteSheet = new egret.SpriteSheet(texture);
            }
            EgretTextureAtlas.prototype.getTexture = function (fullName) {
                var result = this.spriteSheet.getTexture(fullName);
                if (!result) {
                    var data = this._textureData[fullName];
                    result = this.spriteSheet.createTexture(fullName, data.x, data.y, data.width, data.height);
                }
                return result;
            };

            EgretTextureAtlas.prototype.dispose = function () {
                this.texture = null;
            };

            EgretTextureAtlas.prototype.getRegion = function (subTextureName) {
                throw new Error("error");
                //return new geom.Rectangle();
            };

            EgretTextureAtlas.prototype.parseData = function (textureAtlasRawData) {
                var l = textureAtlasRawData.SubTexture.length;
                for (var i = 0; i < l; i++) {
                    var data = textureAtlasRawData.SubTexture[i];
                    this._textureData[data.name] = data;
                }
            };
            return EgretTextureAtlas;
        })();
        textures.EgretTextureAtlas = EgretTextureAtlas;
    })(dragonBones.textures || (dragonBones.textures = {}));
    var textures = dragonBones.textures;

    (function (factorys) {
        var EgretFactory = (function (_super) {
            __extends(EgretFactory, _super);
            function EgretFactory() {
                _super.call(this);
            }
            /** @private */
            EgretFactory.prototype._generateArmature = function () {
                var armature = new dragonBones.Armature(new egret.DisplayObjectContainer());
                return armature;
            };

            /** @private */
            EgretFactory.prototype._generateSlot = function () {
                var slot = new dragonBones.Slot(new display.DragonBonesEgretBridge());
                return slot;
            };

            /** @private */
            EgretFactory.prototype._generateDisplay = function (textureAtlas, fullName, pivotX, pivotY) {
                var bitmap1 = new egret.Bitmap();
                bitmap1.texture = textureAtlas.getTexture(fullName);
                bitmap1.anchorOffsetX = pivotX;
                bitmap1.anchorOffsetY = pivotY;
                return bitmap1;
            };
            return EgretFactory;
        })(factorys.BaseFactory);
        factorys.EgretFactory = EgretFactory;
    })(dragonBones.factorys || (dragonBones.factorys = {}));
    var factorys = dragonBones.factorys;
})(dragonBones || (dragonBones = {}));

/**
 * Copyright (c) 2014,Egret-Labs.org
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Egret-Labs.org nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/// <reference path="../core/Logger.ts"/>
/// <reference path="../core/MainContext.ts"/>
/// <reference path="../core/Ticker.ts"/>
/// <reference path="../texture/Texture.ts"/>
var egret;
(function (egret) {
    var DEBUG = (function () {
        function DEBUG() {
        }

        /**
        * 跟踪渲染主循环过程
        * @param command 0,停止主循环; 1,执行一次主循环 2,正常循环渲染
        * @constructor
        */
        DEBUG.TRACE_RENDER_LOOP = function (command) {
            if (typeof command === "undefined") { command = 0; }
            var ticker = egret.Ticker.getInstance();
            var context = egret.MainContext.instance;
            switch (command) {
                case 0:
                    ticker.unregister(context["renderLoop"], context);
                    break;
                case 1:
                    context["renderLoop"]();
                    break;
                case 2:
                    ticker.register(context["renderLoop"], context);
                    break;
            }
        };
        DEBUG.DRAW_IMAGE = true;

        DEBUG.ADD_EVENT_LISTENER = true;

        DEBUG.SCALE_BITMAP_SET_SCALE_GRID = true;
        return DEBUG;
    })();
    egret.DEBUG = DEBUG;
})(egret || (egret = {}));
/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var NumberUtils = (function () {
        function NumberUtils() {
        }
        NumberUtils.isNumber = function (value) {
            return typeof (value) === "number" && !isNaN(value);
        };
        return NumberUtils;
    })();
    egret.NumberUtils = NumberUtils;
})(egret || (egret = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    /**
    * @class RES.ResourceEvent
    * @classdesc
    * @extends egret.Event
    */
    var ResourceEvent = (function (_super) {
        __extends(ResourceEvent, _super);
        /**
        * 构造函数
        * @method RES.ResourceEvent#constructor
        * @param type {string}
        * @param bubbles {boolean}
        * @param cancelable {boolean}
        */
        function ResourceEvent(type, bubbles, cancelable) {
            if (typeof bubbles === "undefined") { bubbles = false; }
            if (typeof cancelable === "undefined") { cancelable = false; }
            _super.call(this, type, bubbles, cancelable);
            /**
            * 已经加载的文件数
            * @member {number} RES.ResourceEvent#itemsLoaded
            */
            this.itemsLoaded = 0;
            /**
            * 要加载的总文件数
            * @member {number} RES.ResourceEvent#itemsTotal
            */
            this.itemsTotal = 0;
        }
        /**
        * 使用指定的EventDispatcher对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
        * @method RES.ResourceEvent.dispatchResourceEvent
        * @param target {egret.IEventDispatcher}
        * @param type {string}
        * @param groupName {string}
        * @param resItem {egret.ResourceItem}
        * @param itemsLoaded {number}
        * @param itemsTotal {number}
        */
        ResourceEvent.dispatchResourceEvent = function (target, type, groupName, resItem, itemsLoaded, itemsTotal) {
            if (typeof groupName === "undefined") { groupName = ""; }
            if (typeof resItem === "undefined") { resItem = null; }
            if (typeof itemsLoaded === "undefined") { itemsLoaded = 0; }
            if (typeof itemsTotal === "undefined") { itemsTotal = 0; }
            var eventClass = ResourceEvent;
            var props = egret.Event._getPropertyData(eventClass);
            props.groupName = groupName;
            props.resItem = resItem;
            props.itemsLoaded = itemsLoaded;
            props.itemsTotal = itemsTotal;
            egret.Event._dispatchByTarget(eventClass, target, type, props);
        };
        ResourceEvent.ITEM_LOAD_ERROR = "itemLoadError";

        ResourceEvent.CONFIG_COMPLETE = "configComplete";

        ResourceEvent.GROUP_PROGRESS = "groupProgress";

        ResourceEvent.GROUP_COMPLETE = "groupComplete";
        return ResourceEvent;
    })(egret.Event);
    RES.ResourceEvent = ResourceEvent;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var RES;
(function (RES) {
    /**
    * @class RES.ResourceItem
    * @classdesc
    */
    var ResourceItem = (function () {
        /**
        * 构造函数
        * @method RES.ResourceItem#constructor
        * @param name {string} 加载项名称
        * @param url {string} 要加载的文件地址
        * @param type {string} 加载项文件类型
        */
        function ResourceItem(name, url, type) {
            this._loaded = false;
            this.name = name;
            this.url = url;
            this.type = type;
        }
        Object.defineProperty(ResourceItem.prototype, "loaded", {
            /**
            * 加载完成的标志
            * @member {boolean} RES.ResourceItem#loaded
            */
            get: function () {
                return this.data ? this.data.loaded : this._loaded;
            },
            set: function (value) {
                if (this.data)
                    this.data.loaded = value;
                this._loaded = value;
            },
            enumerable: true,
            configurable: true
        });


        /**
        * @method RES.ResourceItem#toString
        * @returns {string}
        */
        ResourceItem.prototype.toString = function () {
            return "[ResourceItem name=\"" + this.name + "\" url=\"" + this.url + "\" type=\"" + this.type + "\"]";
        };
        ResourceItem.TYPE_XML = "xml";

        ResourceItem.TYPE_IMAGE = "image";

        ResourceItem.TYPE_BIN = "bin";

        ResourceItem.TYPE_TEXT = "text";

        ResourceItem.TYPE_JSON = "json";

        ResourceItem.TYPE_SHEET = "sheet";

        ResourceItem.TYPE_FONT = "font";

        ResourceItem.TYPE_SOUND = "sound";
        return ResourceItem;
    })();
    RES.ResourceItem = ResourceItem;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var RES;
(function (RES) {
    /**
    * @class RES.ResourceConfig
    * @classdesc
    */
    var ResourceConfig = (function () {
        function ResourceConfig() {
            /**
            * 一级键名字典
            */
            this.keyMap = {};
            /**
            * 加载组字典
            */
            this.groupDic = {};
        }
        /**
        * 根据组名获取组加载项列表
        * @method RES.ResourceConfig#getGroupByName
        * @param name {string} 组名
        * @returns {Array<egret.ResourceItem>}
        */
        ResourceConfig.prototype.getGroupByName = function (name) {
            var group = new Array();
            if (!this.groupDic[name])
                return group;
            var list = this.groupDic[name];
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var obj = list[i];
                group.push(this.parseResourceItem(obj));
            }
            return group;
        };

        /**
        * 根据组名获取原始的组加载项列表
        * @method RES.ResourceConfig#getRawGroupByName
        * @param name {string} 组名
        * @returns {Array<any>}
        */
        ResourceConfig.prototype.getRawGroupByName = function (name) {
            if (this.groupDic[name])
                return this.groupDic[name];
            return [];
        };

        /**
        * 创建自定义的加载资源组,注意：此方法仅在资源配置文件加载完成后执行才有效。
        * 可以监听ResourceEvent.CONFIG_COMPLETE事件来确认配置加载完成。
        * @method RES.ResourceConfig#createGroup
        * @param name {string} 要创建的加载资源组的组名
        * @param keys {egret.Array<string>} 要包含的键名列表，key对应配置文件里的name属性或一个资源组名。
        * @param override {boolean} 是否覆盖已经存在的同名资源组,默认false。
        * @returns {boolean}
        */
        ResourceConfig.prototype.createGroup = function (name, keys, override) {
            if (typeof override === "undefined") { override = false; }
            if ((!override && this.groupDic[name]) || !keys || keys.length == 0)
                return false;
            var groupDic = this.groupDic;
            var group = [];
            var length = keys.length;
            for (var i = 0; i < length; i++) {
                var key = keys[i];
                var g = groupDic[key];
                if (g) {
                    var len = g.length;
                    for (var j = 0; j < len; j++) {
                        var item = g[j];
                        if (group.indexOf(item) == -1)
                            group.push(item);
                    }
                } else {
                    item = this.keyMap[key];
                    if (item && group.indexOf(item) == -1)
                        group.push(item);
                }
            }
            if (group.length == 0)
                return false;
            this.groupDic[name] = group;
            return true;
        };

        /**
        * 解析一个配置文件
        * @method RES.ResourceConfig#parseConfig
        * @param data {any} 配置文件数据
        * @param folder {string} 加载项的路径前缀。
        */
        ResourceConfig.prototype.parseConfig = function (data, folder) {
            if (!data)
                return;
            var resources = data["resources"];
            if (resources) {
                var length = resources.length;
                for (var i = 0; i < length; i++) {
                    var item = resources[i];
                    item.url = folder + item.url;
                    if (!this.keyMap[item.name])
                        this.keyMap[item.name] = item;
                }
            }
            var groups = data["groups"];
            if (groups) {
                length = groups.length;
                for (i = 0; i < length; i++) {
                    var group = groups[i];
                    var list = [];
                    var keys = group.keys.split(",");
                    var l = keys.length;
                    for (var j = 0; j < l; j++) {
                        var name = keys[j].trim();
                        item = this.keyMap[name];
                        if (item && list.indexOf(item) == -1) {
                            list.push(item);
                        }
                    }
                    this.groupDic[group.name] = list;
                }
            }
        };

        /**
        * 获取加载项类型。
        * @method RES.ResourceConfig#getType
        * @param name {string} 对应配置文件里的name属性。
        * @returns {string}
        */
        ResourceConfig.prototype.getType = function (name) {
            var data = this.keyMap[name];
            return data ? data.type : "";
        };

        ResourceConfig.prototype.getRawResourceItem = function (name) {
            return this.keyMap[name];
        };

        /**
        * 获取加载项信息对象
        * @method RES.ResourceConfig#getResourceItem
        * @param name {string} 对应配置文件里的name属性。
        * @returns {egret.ResourceItem}
        */
        ResourceConfig.prototype.getResourceItem = function (name) {
            var data = this.keyMap[name];
            if (data)
                return this.parseResourceItem(data);
            return null;
        };

        /**
        * 转换Object数据为ResourceItem对象
        */
        ResourceConfig.prototype.parseResourceItem = function (data) {
            var resItem = new RES.ResourceItem(data.name, data.url, data.type);
            resItem.data = data;
            return resItem;
        };
        return ResourceConfig;
    })();
    RES.ResourceConfig = ResourceConfig;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    /**
    * @class RES.ResourceLoader
    * @classdesc
    * @extends egret.EventDispatcher
    */
    var ResourceLoader = (function (_super) {
        __extends(ResourceLoader, _super);
        /**
        * 构造函数
        * @method RES.ResourceLoader#constructor
        */
        function ResourceLoader() {
            _super.call(this);
            /**
            * 当前组加载的项总个数,key为groupName
            */
            this.groupTotalDic = {};
            /**
            * 已经加载的项个数,key为groupName
            */
            this.numLoadedDic = {};
            /**
            * 正在加载的组列表,key为groupName
            */
            this.itemListDic = {};
            /**
            * 优先级队列,key为priority，value为groupName列表
            */
            this.priorityQueue = {};
            /**
            * 延迟加载队列
            */
            this.lazyLoadList = new Array();
            /**
            * 资源解析库字典类
            */
            this.analyzerDic = {};
            /**
            * 当前应该加载同优先级队列的第几列
            */
            this.queueIndex = 0;
        }
        /**
        * 检查指定的组是否正在加载中
        * @method RES.ResourceLoader#isGroupInLoading
        * @param groupName {string}
        * @returns {boolean}
        */
        ResourceLoader.prototype.isGroupInLoading = function (groupName) {
            return this.itemListDic[groupName] !== undefined;
        };

        /**
        * 开始加载一组文件
        * @method RES.ResourceLoader#loadGroup
        * @param list {egret.Array<ResourceItem>} 加载项列表
        * @param groupName {string} 组名
        * @param priority {number} 加载优先级
        */
        ResourceLoader.prototype.loadGroup = function (list, groupName, priority) {
            if (typeof priority === "undefined") { priority = 0; }
            if (this.itemListDic[groupName] || !groupName)
                return;
            if (!list || list.length == 0) {
                var event = new RES.ResourceEvent(RES.ResourceEvent.GROUP_COMPLETE);
                event.groupName = groupName;
                this.dispatchEvent(event);
                return;
            }
            if (this.priorityQueue[priority])
                this.priorityQueue[priority].push(groupName);
            else
                this.priorityQueue[priority] = [groupName];
            this.itemListDic[groupName] = list;
            var length = list.length;
            for (var i = 0; i < length; i++) {
                var resItem = list[i];
                resItem.groupName = groupName;
            }
            this.groupTotalDic[groupName] = list.length;
            this.numLoadedDic[groupName] = 0;
            this.next();
        };

        /**
        * 加载一个文件
        * @method RES.ResourceLoader#loadItem
        * @param resItem {egret.ResourceItem} 要加载的项
        */
        ResourceLoader.prototype.loadItem = function (resItem) {
            this.lazyLoadList.push(resItem);
            resItem.groupName = "";
            this.next();
        };

        /**
        * 加载下一项
        */
        ResourceLoader.prototype.next = function () {
            var resItem = this.getOneResourceItem();
            if (!resItem)
                return;
            if (resItem.loaded) {
                this.onItemComplete(resItem);
            } else {
                var analyzer = this.analyzerDic[resItem.type];
                if (!analyzer) {
                    analyzer = this.analyzerDic[resItem.type] = egret.Injector.getInstance(RES.AnalyzerBase, resItem.type);
                }
                analyzer.loadFile(resItem, this.onItemComplete, this);
            }
        };

        /**
        * 获取下一个待加载项
        */
        ResourceLoader.prototype.getOneResourceItem = function () {
            var maxPriority = Number.NEGATIVE_INFINITY;
            for (var p in this.priorityQueue) {
                maxPriority = Math.max(maxPriority, p);
            }
            var queue = this.priorityQueue[maxPriority];
            if (!queue || queue.length == 0) {
                if (this.lazyLoadList.length == 0)
                    return null;

                //后请求的先加载，以便更快获取当前需要的资源
                return this.lazyLoadList.pop();
            }
            var length = queue.length;
            var list;
            for (var i = 0; i < length; i++) {
                if (this.queueIndex >= length)
                    this.queueIndex = 0;
                list = this.itemListDic[queue[this.queueIndex]];
                if (list.length > 0)
                    break;
                this.queueIndex++;
            }
            if (list.length == 0)
                return null;
            return list.shift();
        };

        /**
        * 加载结束
        */
        ResourceLoader.prototype.onItemComplete = function (resItem) {
            var groupName = resItem.groupName;
            if (!resItem.loaded) {
                RES.ResourceEvent.dispatchResourceEvent(this.resInstance, RES.ResourceEvent.ITEM_LOAD_ERROR, groupName, resItem);
            }

            if (groupName) {
                this.numLoadedDic[groupName]++;
                var itemsLoaded = this.numLoadedDic[groupName];
                var itemsTotal = this.groupTotalDic[groupName];
                RES.ResourceEvent.dispatchResourceEvent(this.resInstance, RES.ResourceEvent.GROUP_PROGRESS, groupName, resItem, itemsLoaded, itemsTotal);
                if (itemsLoaded == itemsTotal) {
                    this.removeGroupName(groupName);
                    delete this.groupTotalDic[groupName];
                    delete this.numLoadedDic[groupName];
                    delete this.itemListDic[groupName];

                    RES.ResourceEvent.dispatchResourceEvent(this, RES.ResourceEvent.GROUP_COMPLETE, groupName);
                }
            } else {
                this.callBack.call(this.resInstance, resItem);
            }
            this.next();
        };

        /**
        * 从优先级队列中移除指定的组名
        */
        ResourceLoader.prototype.removeGroupName = function (groupName) {
            for (var p in this.priorityQueue) {
                var queue = this.priorityQueue[p];
                var length = queue.length;
                var index = 0;
                var found = false;
                var length = queue.length;
                for (var i = 0; i < length; i++) {
                    var name = queue[i];
                    if (name == groupName) {
                        queue.splice(index, 1);
                        found = true;
                        break;
                    }
                    index++;
                }
                if (found) {
                    if (queue.length == 0) {
                        delete this.priorityQueue[p];
                    }
                    break;
                }
            }
        };
        return ResourceLoader;
    })(egret.EventDispatcher);
    RES.ResourceLoader = ResourceLoader;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var AnalyzerBase = (function (_super) {
        __extends(AnalyzerBase, _super);
        function AnalyzerBase() {
            _super.call(this);
        }
        /**
        * 加载一个资源文件
        * @param resItem 加载项信息
        * @param compFunc 加载完成回调函数,示例:compFunc(resItem:ResourceItem):void;
        * @param thisObject 加载完成回调函数的this引用
        */
        AnalyzerBase.prototype.loadFile = function (resItem, compFunc, thisObject) {
        };

        /**
        * 同步方式获取解析完成的数据
        * @param name 对应配置文件里的name属性。
        */
        AnalyzerBase.prototype.getRes = function (name) {
        };

        /**
        * 销毁某个资源文件的二进制数据,返回是否删除成功。
        * @param name 配置文件中加载项的name属性
        */
        AnalyzerBase.prototype.destroyRes = function (name) {
            return false;
        };

        /**
        * 读取一个字符串里第一个点之前的内容。
        * @param name {string} 要读取的字符串
        */
        AnalyzerBase.getStringPrefix = function (name) {
            if (!name) {
                return "";
            }
            var index = name.indexOf(".");
            if (index != -1) {
                return name.substring(0, index);
            }
            return "";
        };

        /**
        * 读取一个字符串里第一个点之后的内容。
        * @param name {string} 要读取的字符串
        */
        AnalyzerBase.getStringTail = function (name) {
            if (!name) {
                return "";
            }
            var index = name.indexOf(".");
            if (index != -1) {
                return name.substring(index + 1);
            }
            return "";
        };
        return AnalyzerBase;
    })(egret.HashObject);
    RES.AnalyzerBase = AnalyzerBase;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var BinAnalyzer = (function (_super) {
        __extends(BinAnalyzer, _super);
        /**
        * 构造函数
        */
        function BinAnalyzer() {
            _super.call(this);
            /**
            * 字节流数据缓存字典
            */
            this.fileDic = {};
            /**
            * 加载项字典
            */
            this.resItemDic = [];
            this._dataFormat = egret.URLLoaderDataFormat.BINARY;
            /**
            * URLLoader对象池
            */
            this.recycler = new egret.Recycler();
        }
        /**
        * @inheritDoc
        */
        BinAnalyzer.prototype.loadFile = function (resItem, compFunc, thisObject) {
            if (this.fileDic[resItem.name]) {
                compFunc.call(thisObject, resItem);
                return;
            }
            var loader = this.getLoader();
            this.resItemDic[loader.hashCode] = { item: resItem, func: compFunc, thisObject: thisObject };
            loader.load(new egret.URLRequest(resItem.url));
        };

        /**
        * 获取一个URLLoader对象
        */
        BinAnalyzer.prototype.getLoader = function () {
            var loader = this.recycler.pop();
            if (!loader) {
                loader = new egret.URLLoader();
                loader.addEventListener(egret.Event.COMPLETE, this.onLoadFinish, this);
                loader.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onLoadFinish, this);
            }
            loader.dataFormat = this._dataFormat;
            return loader;
        };

        /**
        * 一项加载结束
        */
        BinAnalyzer.prototype.onLoadFinish = function (event) {
            var loader = (event.target);
            var data = this.resItemDic[loader.hashCode];
            delete this.resItemDic[loader.hashCode];
            this.recycler.push(loader);
            var resItem = data.item;
            var compFunc = data.func;
            resItem.loaded = (event.type == egret.Event.COMPLETE);
            if (resItem.loaded) {
                this.analyzeData(resItem, loader.data);
            }
            compFunc.call(data.thisObject, resItem);
        };

        /**
        * 解析并缓存加载成功的数据
        */
        BinAnalyzer.prototype.analyzeData = function (resItem, data) {
            var name = resItem.name;
            if (this.fileDic[name] || !data) {
                return;
            }
            this.fileDic[name] = data;
        };

        /**
        * @inheritDoc
        */
        BinAnalyzer.prototype.getRes = function (name) {
            return this.fileDic[name];
        };

        /**
        * @inheritDoc
        */
        BinAnalyzer.prototype.hasRes = function (name) {
            var res = this.getRes(name);
            return res != null;
        };

        /**
        * @inheritDoc
        */
        BinAnalyzer.prototype.destroyRes = function (name) {
            if (this.fileDic[name]) {
                delete this.fileDic[name];
                return true;
            }
            return false;
        };
        return BinAnalyzer;
    })(RES.AnalyzerBase);
    RES.BinAnalyzer = BinAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var ImageAnalyzer = (function (_super) {
        __extends(ImageAnalyzer, _super);
        function ImageAnalyzer() {
            _super.call(this);
            this._dataFormat = egret.URLLoaderDataFormat.TEXTURE;
        }
        /**
        * 解析并缓存加载成功的数据
        */
        ImageAnalyzer.prototype.analyzeData = function (resItem, data) {
            var name = resItem.name;
            if (this.fileDic[name] || !data) {
                return;
            }
            this.fileDic[name] = data;
            var config = resItem.data;
            if (config && config["scale9grid"]) {
                var str = config["scale9grid"];
                var list = str.split(",");
                data["scale9Grid"] = new egret.Rectangle(parseInt(list[0]), parseInt(list[1]), parseInt(list[2]), parseInt(list[3]));
            }
        };
        return ImageAnalyzer;
    })(RES.BinAnalyzer);
    RES.ImageAnalyzer = ImageAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var JsonAnalyzer = (function (_super) {
        __extends(JsonAnalyzer, _super);
        function JsonAnalyzer() {
            _super.call(this);
            this._dataFormat = egret.URLLoaderDataFormat.TEXT;
        }
        /**
        * 解析并缓存加载成功的数据
        */
        JsonAnalyzer.prototype.analyzeData = function (resItem, data) {
            var name = resItem.name;
            if (this.fileDic[name] || !data) {
                return;
            }
            try  {
                var str = data;
                this.fileDic[name] = JSON.parse(str);
            } catch (e) {
            }
        };
        return JsonAnalyzer;
    })(RES.BinAnalyzer);
    RES.JsonAnalyzer = JsonAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var TextAnalyzer = (function (_super) {
        __extends(TextAnalyzer, _super);
        function TextAnalyzer() {
            _super.call(this);
            this._dataFormat = egret.URLLoaderDataFormat.TEXT;
        }
        return TextAnalyzer;
    })(RES.BinAnalyzer);
    RES.TextAnalyzer = TextAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    /**
    * SpriteSheet解析器
    */
    var SheetAnalyzer = (function (_super) {
        __extends(SheetAnalyzer, _super);
        function SheetAnalyzer() {
            _super.call(this);
            this.sheetMap = {};
            this._dataFormat = egret.URLLoaderDataFormat.TEXT;
        }
        /**
        * @inheritDoc
        */
        SheetAnalyzer.prototype.getRes = function (name) {
            var res = this.fileDic[name];
            if (!res) {
                var prefix = RES.AnalyzerBase.getStringPrefix(name);
                res = this.fileDic[prefix];
                if (res) {
                    var tail = RES.AnalyzerBase.getStringTail(name);
                    res = res.getTexture(tail);
                }
            }
            return res;
        };

        /**
        * 一项加载结束
        */
        SheetAnalyzer.prototype.onLoadFinish = function (event) {
            var loader = (event.target);
            var data = this.resItemDic[loader.hashCode];
            delete this.resItemDic[loader.hashCode];
            this.recycler.push(loader);
            var resItem = data.item;
            var compFunc = data.func;
            resItem.loaded = (event.type == egret.Event.COMPLETE);
            if (resItem.loaded) {
                this.analyzeData(resItem, loader.data);
            }
            if (typeof (loader.data) == "string") {
                this._dataFormat = egret.URLLoaderDataFormat.TEXTURE;
                this.loadFile(resItem, compFunc, data.thisObject);
                this._dataFormat = egret.URLLoaderDataFormat.TEXT;
            } else {
                compFunc.call(data.thisObject, resItem);
            }
        };

        /**
        * 解析并缓存加载成功的数据
        */
        SheetAnalyzer.prototype.analyzeData = function (resItem, data) {
            var name = resItem.name;
            if (this.fileDic[name] || !data) {
                return;
            }
            var config;
            if (typeof (data) == "string") {
                try  {
                    var str = data;
                    config = JSON.parse(str);
                } catch (e) {
                }
                if (!config) {
                    return;
                }
                this.sheetMap[name] = config;
                resItem.loaded = false;
                resItem.url = this.getRelativePath(resItem.url, config["file"]);
            } else {
                var texture = data;
                config = this.sheetMap[name];
                delete this.sheetMap[name];
                if (texture) {
                    var spriteSheet = this.parseSpriteSheet(texture, config);
                    this.fileDic[name] = spriteSheet;
                }
            }
        };

        SheetAnalyzer.prototype.getRelativePath = function (url, file) {
            url = url.split("\\").join("/");
            var index = url.lastIndexOf("/");
            if (index != -1) {
                url = url.substring(0, index + 1) + file;
            } else {
                url = file;
            }
            return url;
        };

        SheetAnalyzer.prototype.parseSpriteSheet = function (texture, data) {
            var frames = data.frames;
            if (!frames) {
                return null;
            }
            var spriteSheet = new egret.SpriteSheet(texture);
            for (var name in frames) {
                var config = frames[name];
                spriteSheet.createTexture(name, config.x, config.y, config.w, config.h, config.offX, config.offY, config.sourceW, config.sourceH);
            }
            return spriteSheet;
        };
        return SheetAnalyzer;
    })(RES.BinAnalyzer);
    RES.SheetAnalyzer = SheetAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var FontAnalyzer = (function (_super) {
        __extends(FontAnalyzer, _super);
        function FontAnalyzer() {
            _super.call(this);
        }
        /**
        * 解析并缓存加载成功的数据
        */
        FontAnalyzer.prototype.analyzeData = function (resItem, data) {
            var name = resItem.name;
            if (this.fileDic[name] || !data) {
                return;
            }
            var config;
            if (typeof (data) == "string") {
                config = data;
                this.sheetMap[name] = config;
                resItem.loaded = false;
                resItem.url = this.getTexturePath(resItem.url, config);
            } else {
                var texture = data;
                config = this.sheetMap[name];
                delete this.sheetMap[name];
                if (texture) {
                    var spriteSheet = new egret.BitmapTextSpriteSheet(texture, config);
                    this.fileDic[name] = spriteSheet;
                }
            }
        };

        FontAnalyzer.prototype.getTexturePath = function (url, fntText) {
            var file = "";
            var lines = fntText.split("\n");
            var pngLine = lines[2];
            var index = pngLine.indexOf("file=\"");
            if (index != -1) {
                pngLine = pngLine.substring(index + 6);
                index = pngLine.indexOf("\"");
                file = pngLine.substring(0, index);
            }

            url = url.split("\\").join("/");
            var index = url.lastIndexOf("/");
            if (index != -1) {
                url = url.substring(0, index + 1) + file;
            } else {
                url = file;
            }
            return url;
        };
        return FontAnalyzer;
    })(RES.SheetAnalyzer);
    RES.FontAnalyzer = FontAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var SoundAnalyzer = (function (_super) {
        __extends(SoundAnalyzer, _super);
        function SoundAnalyzer() {
            _super.call(this);
            this._dataFormat = egret.URLLoaderDataFormat.SOUND;
        }
        return SoundAnalyzer;
    })(RES.BinAnalyzer);
    RES.SoundAnalyzer = SoundAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    var XMLAnalyzer = (function (_super) {
        __extends(XMLAnalyzer, _super);
        function XMLAnalyzer() {
            _super.call(this);
            this._dataFormat = egret.URLLoaderDataFormat.TEXT;
        }
        /**
        * 解析并缓存加载成功的数据
        */
        XMLAnalyzer.prototype.analyzeData = function (resItem, data) {
            var name = resItem.name;
            if (this.fileDic[name] || !data) {
                return;
            }
            try  {
                var xmlStr = data;
                var xml = egret.XML.parse(xmlStr);
                this.fileDic[name] = xml;
            } catch (e) {
            }
        };
        return XMLAnalyzer;
    })(RES.BinAnalyzer);
    RES.XMLAnalyzer = XMLAnalyzer;
})(RES || (RES = {}));

/**
* Copyright (c) Egret-Labs.org. Permission is hereby granted, free of charge,
* to any person obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom
* the Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var RES;
(function (RES) {
    /**
    * 加载配置文件并解析
    * @method RES.loadConfig
    * @param url {string} 配置文件路径(resource.json的路径)
    * @param resourceRoot {string} 资源根路径。配置中的所有url都是这个路径的相对值。最终url是这个字符串与配置里资源项的url相加的值。
    */
    function loadConfig(url, resourceRoot) {
        if (typeof resourceRoot === "undefined") { resourceRoot = ""; }
        instance.loadConfig(url, resourceRoot);
    }
    RES.loadConfig = loadConfig;

    /**
    * 根据组名加载一组资源
    * @method RES.loadGroup
    * @param name {string} 要加载资源组的组名
    * @param priority {number} 加载优先级,可以为负数,默认值为0。
    * 低优先级的组必须等待高优先级组完全加载结束才能开始，同一优先级的组会同时加载。
    */
    function loadGroup(name, priority) {
        if (typeof priority === "undefined") { priority = 0; }
        instance.loadGroup(name, priority);
    }
    RES.loadGroup = loadGroup;

    /**
    * 检查某个资源组是否已经加载完成
    * @method RES.isGroupLoaded
    * @param name {string} 组名
    * @returns {boolean}
    */
    function isGroupLoaded(name) {
        return instance.isGroupLoaded(name);
    }
    RES.isGroupLoaded = isGroupLoaded;

    /**
    * 根据组名获取组加载项列表
    * @method RES.getGroupByName
    * @param name {string} 组名
    * @returns {egret.ResourceItem}
    */
    function getGroupByName(name) {
        return instance.getGroupByName(name);
    }
    RES.getGroupByName = getGroupByName;

    /**
    * 创建自定义的加载资源组,注意：此方法仅在资源配置文件加载完成后执行才有效。
    * 可以监听ResourceEvent.CONFIG_COMPLETE事件来确认配置加载完成。
    * @method RES.createGroup
    * @param name {string} 要创建的加载资源组的组名
    * @param keys {egret.Array<string>} 要包含的键名列表，key对应配置文件里的name属性或一个资源组名。
    * @param override {boolean} 是否覆盖已经存在的同名资源组,默认false。
    * @returns {boolean}
    */
    function createGroup(name, keys, override) {
        if (typeof override === "undefined") { override = false; }
        return instance.createGroup(name, keys, override);
    }
    RES.createGroup = createGroup;

    /**
    * 检查配置文件里是否含有指定的资源
    * @method RES.hasRes
    * @param name {string} 对应配置文件里的name属性。
    * @returns {boolean}
    */
    function hasRes(name) {
        return instance.hasRes(name);
    }
    RES.hasRes = hasRes;

    /**
    * 同步方式获取缓存的已经加载成功的资源。<br/>
    * @method RES.getRes
    * @param name {string} 对应配置文件里的name属性。
    * @returns {any}
    */
    function getRes(name) {
        return instance.getRes(name);
    }
    RES.getRes = getRes;

    /**
    * 异步方式获取配置里的资源。只要是配置文件里存在的资源，都可以通过异步方式获取。
    * @method RES.getResAsync
    * @param name {string} 对应配置文件里的name属性。
    * @param compFunc {Function} 回调函数。示例：compFunc(data):void,若设置了other参数则为:compFunc(data,other):void。
    * @param thisObject {any} 回调函数的this引用
    */
    function getResAsync(name, compFunc, thisObject) {
        instance.getResAsync(name, compFunc, thisObject);
    }
    RES.getResAsync = getResAsync;

    /**
    * 通过完整URL方式获取外部资源。
    * @method RES.getResByUrl
    * @param url {string} 要加载文件的外部路径。
    * @param compFunc {Function} 回调函数。示例：compFunc(data):void,若设置了other参数则为:compFunc(data,other):void。
    * @param thisObject {any} 回调函数的this引用
    * @param type {string} 文件类型(可选)。请使用ResourceItem类中定义的静态常量。若不设置将根据文件扩展名生成。
    */
    function getResByUrl(url, compFunc, thisObject, type) {
        if (typeof type === "undefined") { type = ""; }
        instance.getResByUrl(url, compFunc, thisObject, type);
    }
    RES.getResByUrl = getResByUrl;

    /**
    * 销毁单个资源文件或一组资源的缓存数据,返回是否删除成功。
    * @method RES.destroyRes
    * @param name {string} 配置文件中加载项的name属性或资源组名
    * @returns {boolean}
    */
    function destroyRes(name) {
        return instance.destroyRes(name);
    }
    RES.destroyRes = destroyRes;

    /**
    * 添加事件侦听器,参考ResourceEvent定义的常量。
    * @method RES.addEventListener
    * @param type {string} 事件的类型。
    * @param listener {Function} 处理事件的侦听器函数。此函数必须接受 Event 对象作为其唯一的参数，并且不能返回任何结果，
    * 如下面的示例所示： function(evt:Event):void 函数可以有任何名称。
    * @param thisObject {any} 侦听函数绑定的this对象
    * @param useCapture {boolean} 确定侦听器是运行于捕获阶段还是运行于目标和冒泡阶段。如果将 useCapture 设置为 true，
    * 则侦听器只在捕获阶段处理事件，而不在目标或冒泡阶段处理事件。如果 useCapture 为 false，则侦听器只在目标或冒泡阶段处理事件。
    * 要在所有三个阶段都侦听事件，请调用 addEventListener 两次：一次将 useCapture 设置为 true，一次将 useCapture 设置为 false。
    * @param priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
    * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
    */
    function addEventListener(type, listener, thisObject, useCapture, priority) {
        if (typeof useCapture === "undefined") { useCapture = false; }
        if (typeof priority === "undefined") { priority = 0; }
        instance.addEventListener(type, listener, thisObject, useCapture, priority);
    }
    RES.addEventListener = addEventListener;

    /**
    * 移除事件侦听器,参考ResourceEvent定义的常量。
    * @method RES.removeEventListener
    * @param type {string} 事件名
    * @param listener {Function} 侦听函数
    * @param thisObject {any} 侦听函数绑定的this对象
    * @param useCapture {boolean} 是否使用捕获，这个属性只在显示列表中生效。
    */
    function removeEventListener(type, listener, thisObject, useCapture) {
        if (typeof useCapture === "undefined") { useCapture = false; }
        instance.removeEventListener(type, listener, thisObject, useCapture);
    }
    RES.removeEventListener = removeEventListener;

    var Resource = (function (_super) {
        __extends(Resource, _super);
        /**
        * 构造函数
        * @method RES.constructor
        */
        function Resource() {
            _super.call(this);
            /**
            * 解析器字典
            */
            this.analyzerDic = {};
            /**
            * 配置文件加载解析完成标志
            */
            this.configComplete = false;
            /**
            * 已经加载过组名列表
            */
            this.loadedGroups = [];
            this.groupNameList = [];
            /**
            * 异步获取资源参数缓存字典
            */
            this.asyncDic = {};
            this.init();
        }
        /**
        * 根据type获取对应的文件解析库
        */
        Resource.prototype.getAnalyzerByType = function (type) {
            var analyzer = this.analyzerDic[type];
            if (!analyzer) {
                analyzer = this.analyzerDic[type] = egret.Injector.getInstance(RES.AnalyzerBase, type);
            }
            return analyzer;
        };

        /**
        * 初始化
        */
        Resource.prototype.init = function () {
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_BIN))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.BinAnalyzer, RES.ResourceItem.TYPE_BIN);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_IMAGE))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.ImageAnalyzer, RES.ResourceItem.TYPE_IMAGE);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_TEXT))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.TextAnalyzer, RES.ResourceItem.TYPE_TEXT);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_JSON))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.JsonAnalyzer, RES.ResourceItem.TYPE_JSON);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_SHEET))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.SheetAnalyzer, RES.ResourceItem.TYPE_SHEET);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_FONT))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.FontAnalyzer, RES.ResourceItem.TYPE_FONT);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_SOUND))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.SoundAnalyzer, RES.ResourceItem.TYPE_SOUND);
            if (!egret.Injector.hasMapRule(RES.AnalyzerBase, RES.ResourceItem.TYPE_XML))
                egret.Injector.mapClass(RES.AnalyzerBase, RES.XMLAnalyzer, RES.ResourceItem.TYPE_XML);
            this.resConfig = new RES.ResourceConfig();
            this.resLoader = new RES.ResourceLoader();
            this.resLoader.callBack = this.onResourceItemComp;
            this.resLoader.resInstance = this;
            this.resLoader.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onGroupComp, this);
        };

        /**
        * 开始加载配置
        * @method RES.loadConfig
        * @param url {string}
        * @param resourceRoot {string}
        */
        Resource.prototype.loadConfig = function (url, resourceRoot) {
            this.configURL = url;
            this.resourceRoot = resourceRoot;
            var resItem = new RES.ResourceItem(url, url, RES.ResourceItem.TYPE_JSON);
            var itemList = [resItem];
            this.resLoader.loadGroup(itemList, Resource.GROUP_CONFIG, Number.MAX_VALUE);
        };

        /**
        * 检查某个资源组是否已经加载完成
        * @method RES.isGroupLoaded
        * @param name {string}
        * @returns {boolean}
        */
        Resource.prototype.isGroupLoaded = function (name) {
            return this.loadedGroups.indexOf(name) != -1;
        };

        /**
        * 根据组名获取组加载项列表
        * @method RES.getGroupByName
        * @param name {string}
        * @returns {Array<egret.ResourceItem>}
        */
        Resource.prototype.getGroupByName = function (name) {
            return this.resConfig.getGroupByName(name);
        };

        /**
        * 根据组名加载一组资源
        * @method RES.loadGroup
        * @param name {string}
        * @param priority {number}
        */
        Resource.prototype.loadGroup = function (name, priority) {
            if (typeof priority === "undefined") { priority = 0; }
            if (this.loadedGroups.indexOf(name) != -1 || this.resLoader.isGroupInLoading(name))
                return;
            if (this.configComplete) {
                var group = this.resConfig.getGroupByName(name);
                this.resLoader.loadGroup(group, name, priority);
            } else {
                this.groupNameList.push({ name: name, priority: priority });
            }
        };

        /**
        * 创建自定义的加载资源组,注意：此方法仅在资源配置文件加载完成后执行才有效。
        * 可以监听ResourceEvent.CONFIG_COMPLETE事件来确认配置加载完成。
        * @method RES.ResourceConfig#createGroup
        * @param name {string} 要创建的加载资源组的组名
        * @param keys {egret.Array<string>} 要包含的键名列表，key对应配置文件里的name属性或一个资源组名。
        * @param override {boolean} 是否覆盖已经存在的同名资源组,默认false。
        * @returns {boolean}
        */
        Resource.prototype.createGroup = function (name, keys, override) {
            if (typeof override === "undefined") { override = false; }
            return this.resConfig.createGroup(name, keys, override);
        };

        /**
        * 队列加载完成事件
        */
        Resource.prototype.onGroupComp = function (event) {
            if (event.groupName == Resource.GROUP_CONFIG) {
                var analyzer = this.getAnalyzerByType(RES.ResourceItem.TYPE_JSON);
                var data = analyzer.getRes(this.configURL);
                analyzer.destroyRes(this.configURL);
                this.resConfig.parseConfig(data, this.resourceRoot);
                this.configComplete = true;
                RES.ResourceEvent.dispatchResourceEvent(this, RES.ResourceEvent.CONFIG_COMPLETE);
                var groupNameList = this.groupNameList;
                var length = groupNameList.length;
                for (var i = 0; i < length; i++) {
                    var item = groupNameList[i];
                    this.loadGroup(item.name, item.priority);
                }
                this.groupNameList = [];
            } else {
                this.loadedGroups.push(event.groupName);
                this.dispatchEvent(event);
            }
        };

        /**
        * 检查配置文件里是否含有指定的资源
        * @method RES.hasRes
        * @param name {string} 对应配置文件里的name属性。
        * @returns {boolean}
        */
        Resource.prototype.hasRes = function (name) {
            var type = this.resConfig.getType(name);
            if (type == "") {
                var prefix = RES.AnalyzerBase.getStringPrefix(name);
                type = this.resConfig.getType(prefix);
                if (type == "") {
                    return false;
                }
            }
            return true;
        };

        /**
        * 通过name同步获取资源
        * @method RES.getRes
        * @param name {string}
        * @returns {any}
        */
        Resource.prototype.getRes = function (name) {
            var type = this.resConfig.getType(name);
            if (type == "") {
                var prefix = RES.AnalyzerBase.getStringPrefix(name);
                type = this.resConfig.getType(prefix);
                if (type == "") {
                    return null;
                }
            }

            var analyzer = this.getAnalyzerByType(type);
            return analyzer.getRes(name);
        };

        /**
        * 通过name异步获取资源
        * @method RES.getResAsync
        * @param name {string}
        * @param compFunc {Function}
        * @param thisObject {any}
        */
        Resource.prototype.getResAsync = function (key, compFunc, thisObject) {
            var type = this.resConfig.getType(key);
            var name = key;
            if (type == "") {
                name = RES.AnalyzerBase.getStringPrefix(key);
                type = this.resConfig.getType(name);
                if (type == "") {
                    compFunc.call(thisObject, null);
                    return;
                }
            }
            var analyzer = this.getAnalyzerByType(type);
            var res = analyzer.getRes(key);
            if (res) {
                compFunc.call(thisObject, res);
                return;
            }
            var args = { name: key, compFunc: compFunc, thisObject: thisObject };
            if (this.asyncDic[name]) {
                this.asyncDic[name].push(args);
            } else {
                this.asyncDic[name] = [args];
                var resItem = this.resConfig.getResourceItem(name);
                this.resLoader.loadItem(resItem);
            }
        };

        /**
        * 通过url获取资源
        * @method RES.getResByUrl
        * @param url {string}
        * @param compFunc {Function}
        * @param thisObject {any}
        * @param type {string}
        */
        Resource.prototype.getResByUrl = function (url, compFunc, thisObject, type) {
            if (typeof type === "undefined") { type = ""; }
            if (!url) {
                compFunc.call(thisObject, null);
                return;
            }
            if (!type)
                type = this.getTypeByUrl(url);
            var analyzer = this.getAnalyzerByType(type);

            var name = url;
            var res = analyzer.getRes(name);
            if (res) {
                compFunc.call(thisObject, res);
                return;
            }
            var args = { name: name, compFunc: compFunc, thisObject: thisObject };
            if (this.asyncDic[name]) {
                this.asyncDic[name].push(args);
            } else {
                this.asyncDic[name] = [args];
                var resItem = new RES.ResourceItem(name, url, type);
                this.resLoader.loadItem(resItem);
            }
        };

        /**
        * 通过url获取文件类型
        */
        Resource.prototype.getTypeByUrl = function (url) {
            var suffix = url.substr(url.lastIndexOf(".") + 1);
            var type;
            switch (suffix) {
                case RES.ResourceItem.TYPE_XML:
                case RES.ResourceItem.TYPE_JSON:
                case RES.ResourceItem.TYPE_SHEET:
                    type = suffix;
                    break;
                case "png":
                case "jpg":
                case "gif":
                    type = RES.ResourceItem.TYPE_IMAGE;
                    break;
                case "fnt":
                    type = RES.ResourceItem.TYPE_FONT;
                    break;
                case "txt":
                    type = RES.ResourceItem.TYPE_TEXT;
                    break;
                default:
                    type = RES.ResourceItem.TYPE_BIN;
                    break;
            }
            return type;
        };

        /**
        * 一个加载项加载完成
        */
        Resource.prototype.onResourceItemComp = function (item) {
            var argsList = this.asyncDic[item.name];
            delete this.asyncDic[item.name];
            var analyzer = this.getAnalyzerByType(item.type);
            var length = argsList.length;
            for (var i = 0; i < length; i++) {
                var args = argsList[i];
                var res = analyzer.getRes(args.name);
                args.compFunc.call(args.thisObject, res);
            }
        };

        /**
        * 销毁单个资源文件或一组资源的缓存数据,返回是否删除成功。
        * @method RES.destroyRes
        * @param name {string} 配置文件中加载项的name属性或资源组名
        * @returns {boolean}
        */
        Resource.prototype.destroyRes = function (name) {
            var group = this.resConfig.getRawGroupByName(name);
            if (group) {
                var index = this.loadedGroups.indexOf(name);
                if (index != -1) {
                    this.loadedGroups.splice(index, 1);
                }
                var length = group.length;
                for (var i = 0; i < length; i++) {
                    var item = group[i];
                    item.loaded = false;
                    var analyzer = this.getAnalyzerByType(item.type);
                    analyzer.destroyRes(item.name);
                }
                return true;
            } else {
                var type = this.resConfig.getType(name);
                if (type == "")
                    return false;
                item = this.resConfig.getRawResourceItem(name);
                item.loaded = false;
                analyzer = this.getAnalyzerByType(type);
                return analyzer.destroyRes(name);
            }
        };
        Resource.GROUP_CONFIG = "RES__CONFIG";
        return Resource;
    })(egret.EventDispatcher);

    /**
    * Resource单例
    */
    var instance = new Resource();
})(RES || (RES = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.HTML5DeviceContext
    * @classdesc
    * @extends egret.DeviceContext
    */
    var HTML5DeviceContext = (function (_super) {
        __extends(HTML5DeviceContext, _super);
        /**
        * @method egret.HTML5DeviceContext#constructor
        */
        function HTML5DeviceContext() {
            _super.call(this);
            this._time = 0;
            /**
            * @member egret.HTML5DeviceContext#frameRate
            */
            this.frameRate = 60;
            HTML5DeviceContext.instance = this;
            this.registerListener();
        }
        HTML5DeviceContext.prototype.enterFrame = function () {
            var context = HTML5DeviceContext.instance;
            var thisObject = HTML5DeviceContext._thisObject;
            var callback = HTML5DeviceContext._callback;
            var thisTime = egret.getTimer();
            var advancedTime = thisTime - context._time;
            callback.call(thisObject, advancedTime);
            context._time = thisTime;
            context._requestAnimationId = HTML5DeviceContext.requestAnimationFrame.call(window, HTML5DeviceContext.prototype.enterFrame);
        };

        /**
        * @method egret.HTML5DeviceContext#executeMainLoop
        * @param callback {Function}
        * @param thisObject {any}
        */
        HTML5DeviceContext.prototype.executeMainLoop = function (callback, thisObject) {
            HTML5DeviceContext._callback = callback;
            HTML5DeviceContext._thisObject = thisObject;
            this.enterFrame();
        };

        HTML5DeviceContext.prototype.reset = function () {
            var context = HTML5DeviceContext.instance;
            if (context._requestAnimationId) {
                context._time = egret.getTimer();
                HTML5DeviceContext.cancelAnimationFrame.call(window, context._requestAnimationId);
                context.enterFrame();
            }
        };

        HTML5DeviceContext.prototype.registerListener = function () {
            var onFocusHandler = function () {
                var context = HTML5DeviceContext.instance;
                context.reset();
            };

            var handleVisibilityChange = function () {
                if (!document[hidden]) {
                    onFocusHandler();
                }
            };

            window.onfocus = onFocusHandler;
            window.onblur = function () {
            };

            var hidden, visibilityChange;
            if (typeof document.hidden !== "undefined") {
                hidden = "hidden";
                visibilityChange = "visibilitychange";
            } else if (typeof document["mozHidden"] !== "undefined") {
                hidden = "mozHidden";
                visibilityChange = "mozvisibilitychange";
            } else if (typeof document["msHidden"] !== "undefined") {
                hidden = "msHidden";
                visibilityChange = "msvisibilitychange";
            } else if (typeof document["webkitHidden"] !== "undefined") {
                hidden = "webkitHidden";
                visibilityChange = "webkitvisibilitychange";
            }
            if ("onpageshow" in window && "onpagehide" in window) {
                window.addEventListener("pageshow", onFocusHandler, false);
                //                window.addEventListener("pagehide", handleBlur, false);
            }
            if (hidden && visibilityChange) {
                document.addEventListener(visibilityChange, handleVisibilityChange, false);
            }
        };
        HTML5DeviceContext.requestAnimationFrame = window["requestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["mozRequestAnimationFrame"] || window["oRequestAnimationFrame"] || window["msRequestAnimationFrame"] || function (callback) {
            return window.setTimeout(callback, 1000 / 60);
        };

        HTML5DeviceContext.cancelAnimationFrame = window["cancelAnimationFrame"] || window["msCancelAnimationFrame"] || window["mozCancelAnimationFrame"] || window["webkitCancelAnimationFrame"] || window["oCancelAnimationFrame"] || window["cancelRequestAnimationFrame"] || window["msCancelRequestAnimationFrame"] || window["mozCancelRequestAnimationFrame"] || window["oCancelRequestAnimationFrame"] || window["webkitCancelRequestAnimationFrame"] || function (id) {
            return window.clearTimeout(id);
        };
        return HTML5DeviceContext;
    })(egret.DeviceContext);
    egret.HTML5DeviceContext = HTML5DeviceContext;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.HTML5CanvasRenderer
    * @classdesc
    * @extends egret.RendererContext
    */
    var HTML5CanvasRenderer = (function (_super) {
        __extends(HTML5CanvasRenderer, _super);
        function HTML5CanvasRenderer(canvas) {
            this.canvas = canvas;
            this.canvasContext = canvas.getContext("2d");
            var f = this.canvasContext.setTransform;
            var that = this;
            this.canvasContext.setTransform = function (a, b, c, d, tx, ty) {
                that._matrixA = a;
                that._matrixB = b;
                that._matrixC = c;
                that._matrixD = d;
                that._matrixTx = tx;
                that._matrixTy = ty;
                f.call(that.canvasContext, a, b, c, d, tx, ty);
            };
            this._matrixA = 1;
            this._matrixB = 0;
            this._matrixC = 0;
            this._matrixD = 1;
            this._matrixTx = 0;
            this._matrixTy = 0;

            this._transformTx = 0;
            this._transformTy = 0;
            _super.call(this);
        }
        HTML5CanvasRenderer.prototype.clearScreen = function () {
            this.setTransform(egret.Matrix.identity.identity());
            var list = egret.RenderFilter.getInstance().getDrawAreaList();
            for (var i = 0, l = list.length; i < l; i++) {
                var area = list[i];
                this.clearRect(area.x + this._transformTx, area.y + this._transformTy, area.width, area.height);
            }
            this.renderCost = 0;
        };

        HTML5CanvasRenderer.prototype.clearRect = function (x, y, w, h) {
            this.canvasContext.clearRect(x, y, w, h);
        };

        HTML5CanvasRenderer.prototype.drawImage = function (texture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
            sourceX = sourceX / egret.MainContext.instance.rendererContext.texture_scale_factor;
            sourceY = sourceY / egret.MainContext.instance.rendererContext.texture_scale_factor;
            sourceWidth = sourceWidth / egret.MainContext.instance.rendererContext.texture_scale_factor;
            sourceHeight = sourceHeight / egret.MainContext.instance.rendererContext.texture_scale_factor;

            //            if (DEBUG && DEBUG.DRAW_IMAGE) {
            //                DEBUG.checkDrawImage(texture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
            //            }
            var image = texture._bitmapData;
            destX += this._transformTx;
            destY += this._transformTy;
            var beforeDraw = egret.getTimer();
            this.canvasContext.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
            _super.prototype.drawImage.call(this, image, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
            this.renderCost += egret.getTimer() - beforeDraw;
        };

        HTML5CanvasRenderer.prototype.setTransform = function (matrix) {
            //在没有旋转缩放斜切的情况下，先不进行矩阵偏移，等下次绘制的时候偏移
            if (matrix.a == 1 && matrix.b == 0 && matrix.c == 0 && matrix.d == 1 && this._matrixA == 1 && this._matrixB == 0 && this._matrixC == 0 && this._matrixD == 1) {
                this._transformTx = matrix.tx - this._matrixTx;
                this._transformTy = matrix.ty - this._matrixTy;
                return;
            }
            this._transformTx = this._transformTy = 0;
            if (this._matrixA != matrix.a || this._matrixB != matrix.b || this._matrixC != matrix.c || this._matrixD != matrix.d || this._matrixTx != matrix.tx || this._matrixTy != matrix.ty) {
                this.canvasContext.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
            }
        };

        HTML5CanvasRenderer.prototype.setAlpha = function (alpha, blendMode) {
            if (alpha != this.canvasContext.globalAlpha) {
                this.canvasContext.globalAlpha = alpha;
            }
            if (blendMode) {
                this.blendValue = blendMode.value;
                this.canvasContext.globalCompositeOperation = blendMode.value;
            } else if (this.blendValue != egret.BlendMode.NORMAL.value) {
                this.blendValue = egret.BlendMode.NORMAL.value;
                this.canvasContext.globalCompositeOperation = egret.BlendMode.NORMAL.value;
            }
        };

        HTML5CanvasRenderer.prototype.setupFont = function (textField) {
            var ctx = this.canvasContext;
            var font = textField.italic ? "italic " : "normal ";
            font += textField.bold ? "bold " : "normal ";
            font += textField.size + "px " + textField.fontFamily;
            ctx.font = font;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
        };

        HTML5CanvasRenderer.prototype.measureText = function (text) {
            var result = this.canvasContext.measureText(text);
            return result.width;
        };

        HTML5CanvasRenderer.prototype.drawText = function (textField, text, x, y, maxWidth) {
            var textColor = textField._textColorString;
            var strokeColor = textField._strokeColorString;
            var outline = textField.stroke;
            var renderContext = this.canvasContext;
            renderContext.fillStyle = textColor;
            renderContext.strokeStyle = strokeColor;
            if (outline) {
                renderContext.lineWidth = outline * 2;
                renderContext.strokeText(text, x + this._transformTx, y + this._transformTy, maxWidth || 0xFFFF);
            }
            renderContext.fillText(text, x + this._transformTx, y + this._transformTy, maxWidth || 0xFFFF);
            _super.prototype.drawText.call(this, textField, text, x, y, maxWidth);
        };

        HTML5CanvasRenderer.prototype.strokeRect = function (x, y, w, h, color) {
            this.canvasContext.strokeStyle = color;
            this.canvasContext.strokeRect(x, y, w, h);
        };

        HTML5CanvasRenderer.prototype.pushMask = function (mask) {
            this.canvasContext.save();
            this.canvasContext.beginPath();
            this.canvasContext.rect(mask.x + this._transformTx, mask.y + this._transformTy, mask.width, mask.height);
            this.canvasContext.clip();
            this.canvasContext.closePath();
        };

        HTML5CanvasRenderer.prototype.popMask = function () {
            this.canvasContext.restore();
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        };
        return HTML5CanvasRenderer;
    })(egret.RendererContext);
    egret.HTML5CanvasRenderer = HTML5CanvasRenderer;
})(egret || (egret = {}));

var egret_h5_graphics;
(function (egret_h5_graphics) {
    function beginFill(color, alpha) {
        if (typeof alpha === "undefined") { alpha = 1; }
        var _colorBlue = color & 0x0000FF;
        var _colorGreen = (color & 0x00ff00) >> 8;
        var _colorRed = color >> 16;
        var _colorStr = "rgba(" + _colorRed + "," + _colorGreen + "," + _colorBlue + "," + alpha + ")";
        this.fillStyleColor = _colorStr;

        this.commandQueue.push(new Command(this._setStyle, this, [_colorStr]));
    }
    egret_h5_graphics.beginFill = beginFill;

    function drawRect(x, y, width, height) {
        this.commandQueue.push(new Command(function (x, y, width, height) {
            var rendererContext = this.renderContext;
            this.canvasContext.beginPath();
            this.canvasContext.rect(rendererContext._transformTx + x, rendererContext._transformTy + y, width, height);
            this.canvasContext.closePath();
        }, this, [x, y, width, height]));
        this._fill();
    }
    egret_h5_graphics.drawRect = drawRect;

    function drawCircle(x, y, r) {
        this.commandQueue.push(new Command(function (x, y, r) {
            var rendererContext = this.renderContext;
            this.canvasContext.beginPath();
            this.canvasContext.arc(rendererContext._transformTx + x, rendererContext._transformTy + y, r, 0, Math.PI * 2);
            this.canvasContext.closePath();
        }, this, [x, y, r]));
        this._fill();
    }
    egret_h5_graphics.drawCircle = drawCircle;

    function lineStyle(thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
        if (typeof thickness === "undefined") { thickness = NaN; }
        if (typeof color === "undefined") { color = 0; }
        if (typeof alpha === "undefined") { alpha = 1.0; }
        if (typeof pixelHinting === "undefined") { pixelHinting = false; }
        if (typeof scaleMode === "undefined") { scaleMode = "normal"; }
        if (typeof caps === "undefined") { caps = null; }
        if (typeof joints === "undefined") { joints = null; }
        if (typeof miterLimit === "undefined") { miterLimit = 3; }
        if (this.strokeStyleColor) {
            this.createEndLineCommand();
            this.commandQueue.push(this.endLineCommand);
        }

        var _colorBlue = color & 0x0000FF;
        var _colorGreen = (color & 0x00ff00) >> 8;
        var _colorRed = color >> 16;
        var _colorStr = "rgba(" + _colorRed + "," + _colorGreen + "," + _colorBlue + "," + alpha + ")";
        this.strokeStyleColor = _colorStr;

        this.commandQueue.push(new Command(function (lineWidth, strokeStyle) {
            this.canvasContext.lineWidth = lineWidth;
            this.canvasContext.strokeStyle = strokeStyle;
            this.canvasContext.beginPath();
        }, this, [thickness, _colorStr]));

        if (typeof (this.lineX) === "undefined") {
            this.lineX = 0;
            this.lineY = 0;
        }
        this.moveTo(this.lineX, this.lineY);
    }
    egret_h5_graphics.lineStyle = lineStyle;

    function lineTo(x, y) {
        this.commandQueue.push(new Command(function (x, y) {
            var rendererContext = this.renderContext;
            var canvasContext = this.canvasContext;
            canvasContext.lineTo(rendererContext._transformTx + x, rendererContext._transformTy + y);
        }, this, [x, y]));
        this.lineX = x;
        this.lineY = y;
    }
    egret_h5_graphics.lineTo = lineTo;

    function curveTo(controlX, controlY, anchorX, anchorY) {
        this.commandQueue.push(new Command(function (x, y, ax, ay) {
            var rendererContext = this.renderContext;
            var canvasContext = this.canvasContext;
            canvasContext.quadraticCurveTo(rendererContext._transformTx + x, rendererContext._transformTy + y, ax, ay);
        }, this, [controlX, controlY, anchorX, anchorY]));
        this.lineX = anchorX;
        this.lineY = anchorY;
    }
    egret_h5_graphics.curveTo = curveTo;

    function moveTo(x, y) {
        this.commandQueue.push(new Command(function (x, y) {
            var rendererContext = this.renderContext;
            var canvasContext = this.canvasContext;
            canvasContext.moveTo(rendererContext._transformTx + x, rendererContext._transformTy + y);
        }, this, [x, y]));
    }
    egret_h5_graphics.moveTo = moveTo;

    function clear() {
        this.commandQueue.length = 0;
        this.lineX = 0;
        this.lineY = 0;
        this.strokeStyleColor = null;
        this.fillStyleColor = null;
    }
    egret_h5_graphics.clear = clear;

    function createEndFillCommand() {
        if (!this.endFillCommand) {
            this.endFillCommand = new Command(function () {
                this.canvasContext.fill();
                this.canvasContext.closePath();
            }, this, null);
        }
    }
    egret_h5_graphics.createEndFillCommand = createEndFillCommand;

    function endFill() {
        if (this.fillStyleColor != null) {
            this._fill();
        }
        this.fillStyleColor = null;
    }
    egret_h5_graphics.endFill = endFill;

    function _fill() {
        if (this.fillStyleColor) {
            this.createEndFillCommand();
            this.commandQueue.push(this.endFillCommand);
        }
    }
    egret_h5_graphics._fill = _fill;

    function createEndLineCommand() {
        if (!this.endLineCommand) {
            this.endLineCommand = new Command(function () {
                this.canvasContext.stroke();
                this.canvasContext.closePath();
            }, this, null);
        }
    }
    egret_h5_graphics.createEndLineCommand = createEndLineCommand;

    function _draw(renderContext) {
        this.renderContext = renderContext;
        this.canvasContext = this.renderContext.canvasContext;
        var canvasContext = this.canvasContext;

        canvasContext.save();
        var length = this.commandQueue.length;
        if (this.strokeStyleColor && length > 0 && this.commandQueue[length - 1] != this.endLineCommand) {
            this.createEndLineCommand();
            this.commandQueue.push(this.endLineCommand);
        }
        for (var i = 0; i < length; i++) {
            var command = this.commandQueue[i];
            command.method.apply(command.thisObject, command.args);
        }
        canvasContext.restore();
    }
    egret_h5_graphics._draw = _draw;

    var Command = (function () {
        function Command(method, thisObject, args) {
            this.method = method;
            this.thisObject = thisObject;
            this.args = args;
        }
        return Command;
    })();

    function _setStyle(colorStr) {
        this.canvasContext.fillStyle = colorStr;
        this.canvasContext.beginPath();
    }
    egret_h5_graphics._setStyle = _setStyle;

    function init() {
        for (var key in egret_h5_graphics) {
            egret.Graphics.prototype[key] = egret_h5_graphics[key];
        }
        egret.RendererContext.createRendererContext = function (canvas) {
            return new egret.HTML5CanvasRenderer(canvas);
        };
    }
    egret_h5_graphics.init = init;
})(egret_h5_graphics || (egret_h5_graphics = {}));

egret_h5_graphics.init();

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.WebGLRenderer
    * @classdesc
    * @extends egret.RendererContext
    */
    var WebGLRenderer = (function (_super) {
        __extends(WebGLRenderer, _super);
        function WebGLRenderer(canvas) {
            _super.call(this);
            this.size = 2000;
            this.vertSize = 6;
            this.contextLost = false;
            this.glContextId = 0;
            this.currentBlendMode = "";
            this.currentBaseTexture = null;
            this.currentBatchSize = 0;
            this.maskList = [];
            this.maskDataFreeList = [];
            this.canvasContext = document.createElement("canvas").getContext("2d");
            console.log("使用WebGL模式");
            this.canvas = canvas;
            canvas.addEventListener("webglcontextlost", this.handleContextLost.bind(this), false);
            canvas.addEventListener("webglcontextrestored", this.handleContextRestored.bind(this), false);

            this.projectionX = canvas.width / 2;
            this.projectionY = -canvas.height / 2;

            var numVerts = this.size * 4 * this.vertSize;
            var numIndices = this.size * 6;

            this.vertices = new Float32Array(numVerts);
            this.indices = new Uint16Array(numIndices);

            for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
                this.indices[i + 0] = j + 0;
                this.indices[i + 1] = j + 1;
                this.indices[i + 2] = j + 2;
                this.indices[i + 3] = j + 0;
                this.indices[i + 4] = j + 2;
                this.indices[i + 5] = j + 3;
            }
            this.initWebGL();

            this.shaderManager = new egret.WebGLShaderManager(this.gl);

            this.worldTransform = new egret.Matrix();

            this.initBlendMode();

            egret.MainContext.instance.addEventListener(egret.Event.FINISH_RENDER, this._draw, this);

            egret.TextField.prototype._draw = function (renderContext) {
                var textField = this;
                if (textField._textDirty) {
                    textField.cacheAsBitmap = true;
                }
                egret.DisplayObject.prototype._draw.call(textField, renderContext);
            };
        }
        WebGLRenderer.prototype.handleContextLost = function () {
            this.contextLost = true;
        };

        WebGLRenderer.prototype.handleContextRestored = function () {
            this.initWebGL();
            this.shaderManager.setContext(this.gl);
            this.contextLost = false;
        };

        WebGLRenderer.prototype.initWebGL = function () {
            var options = {
                stencil: true
            };
            var gl;
            var names = ["experimental-webgl", "webgl"];
            for (var i = 0; i < names.length; i++) {
                try  {
                    gl = this.canvas.getContext(names[i], options);
                } catch (e) {
                }
                if (gl) {
                    break;
                }
            }
            if (!gl) {
                throw new Error("当前浏览器不支持webgl");
            }
            this.setContext(gl);
        };

        WebGLRenderer.prototype.setContext = function (gl) {
            this.gl = gl;
            gl.id = this.glContextId++;
            this.vertexBuffer = gl.createBuffer();
            this.indexBuffer = gl.createBuffer();

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.enable(gl.BLEND);
            gl.colorMask(true, true, true, true);
        };

        WebGLRenderer.prototype.initBlendMode = function () {
            WebGLRenderer.blendModesWebGL[egret.BlendMode.NORMAL.value] = [this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA];
            WebGLRenderer.blendModesWebGL[egret.BlendMode.ADD.value] = [this.gl.SRC_ALPHA, this.gl.DST_ALPHA];
        };

        WebGLRenderer.prototype.start = function () {
            if (this.contextLost) {
                return;
            }
            var gl = this.gl;

            gl.activeTexture(gl.TEXTURE0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

            var shader = this.shaderManager.defaultShader;
            gl.uniform2f(shader.projectionVector, this.projectionX, this.projectionY);

            var stride = this.vertSize * 4;
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
            gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);

            this.setBlendMode(egret.BlendMode.NORMAL.value);
        };

        WebGLRenderer.prototype.clearScreen = function () {
            var gl = this.gl;
            gl.colorMask(true, true, true, true);
            var list = egret.RenderFilter.getInstance().getDrawAreaList();
            for (var i = 0, l = list.length; i < l; i++) {
                var area = list[i];
                gl.viewport(area.x, area.y, area.width, area.height);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
            this.renderCost = 0;
        };

        WebGLRenderer.prototype.setBlendMode = function (blendMode) {
            if (this.currentBlendMode != blendMode) {
                this.currentBlendMode = blendMode;
                var blendModeWebGL = WebGLRenderer.blendModesWebGL[this.currentBlendMode];
                this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
            }
        };

        WebGLRenderer.prototype.drawImage = function (texture, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
            if (this.contextLost) {
                return;
            }

            var texture_scale_factor = egret.MainContext.instance.rendererContext.texture_scale_factor;
            sourceX = sourceX / texture_scale_factor;
            sourceY = sourceY / texture_scale_factor;
            sourceWidth = sourceWidth / texture_scale_factor;
            sourceHeight = sourceHeight / texture_scale_factor;

            this.createWebGLTexture(texture);

            if (texture.webGLTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size) {
                this._draw();
                this.currentBaseTexture = texture.webGLTexture;
            }

            //计算出绘制矩阵，之后把矩阵还原回之前的
            var locWorldTransform = this.worldTransform;
            var originalA = locWorldTransform.a;
            var originalB = locWorldTransform.b;
            var originalC = locWorldTransform.c;
            var originalD = locWorldTransform.d;
            var originalTx = locWorldTransform.tx;
            var originalTy = locWorldTransform.ty;
            if (destX != 0 || destY != 0) {
                locWorldTransform.append(1, 0, 0, 1, destX, destY);
            }
            if (sourceWidth / destWidth != 1 || sourceHeight / destHeight != 1) {
                locWorldTransform.append(destWidth / sourceWidth, 0, 0, destHeight / sourceHeight, 0, 0);
            }
            var a = locWorldTransform.a;
            var b = locWorldTransform.b;
            var c = locWorldTransform.c;
            var d = locWorldTransform.d;
            var tx = locWorldTransform.tx;
            var ty = locWorldTransform.ty;

            locWorldTransform.a = originalA;
            locWorldTransform.b = originalB;
            locWorldTransform.c = originalC;
            locWorldTransform.d = originalD;
            locWorldTransform.tx = originalTx;
            locWorldTransform.ty = originalTy;

            var width = texture._sourceWidth;
            var height = texture._sourceHeight;

            var w = sourceWidth;
            var h = sourceHeight;

            sourceX = sourceX / width;
            sourceY = sourceY / height;
            sourceWidth = sourceWidth / width;
            sourceHeight = sourceHeight / height;

            var vertices = this.vertices;
            var index = this.currentBatchSize * 4 * this.vertSize;
            var alpha = this.worldAlpha;
            var tint = 0xFFFFFF;

            // xy
            vertices[index++] = tx;
            vertices[index++] = ty;

            // uv
            vertices[index++] = sourceX;
            vertices[index++] = sourceY;

            // color
            vertices[index++] = alpha;
            vertices[index++] = tint;

            // xy
            vertices[index++] = a * w + tx;
            vertices[index++] = b * w + ty;

            // uv
            vertices[index++] = sourceWidth + sourceX;
            vertices[index++] = sourceY;

            // color
            vertices[index++] = alpha;
            vertices[index++] = tint;

            // xy
            vertices[index++] = a * w + c * h + tx;
            vertices[index++] = d * h + b * w + ty;

            // uv
            vertices[index++] = sourceWidth + sourceX;
            vertices[index++] = sourceHeight + sourceY;

            // color
            vertices[index++] = alpha;
            vertices[index++] = tint;

            // xy
            vertices[index++] = c * h + tx;
            vertices[index++] = d * h + ty;

            // uv
            vertices[index++] = sourceX;
            vertices[index++] = sourceHeight + sourceY;

            // color
            vertices[index++] = alpha;
            vertices[index++] = tint;

            this.currentBatchSize++;
        };

        WebGLRenderer.prototype._draw = function () {
            if (this.currentBatchSize == 0 || this.contextLost) {
                return;
            }
            var beforeDraw = egret.getTimer();
            this.start();
            var gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture);
            var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
            gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
            this.currentBatchSize = 0;
            this.renderCost += egret.getTimer() - beforeDraw;
            egret.Profiler.getInstance().onDrawImage();
        };

        WebGLRenderer.prototype.setTransform = function (matrix) {
            var locWorldTransform = this.worldTransform;
            locWorldTransform.a = matrix.a;
            locWorldTransform.b = matrix.b;
            locWorldTransform.c = matrix.c;
            locWorldTransform.d = matrix.d;
            locWorldTransform.tx = matrix.tx;
            locWorldTransform.ty = matrix.ty;
        };

        WebGLRenderer.prototype.setAlpha = function (value, blendMode) {
            this.worldAlpha = value;
            if (blendMode) {
                this.setBlendMode(blendMode.value);
            }
        };

        WebGLRenderer.prototype.createWebGLTexture = function (texture) {
            if (!texture.webGLTexture) {
                var gl = this.gl;
                texture.webGLTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture.webGLTexture);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture._bitmapData);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.bindTexture(gl.TEXTURE_2D, null);
            }
        };

        WebGLRenderer.prototype.pushMask = function (mask) {
            this._draw();
            var gl = this.gl;
            if (this.maskList.length == 0) {
                gl.enable(gl.STENCIL_TEST);
                gl.stencilFunc(gl.ALWAYS, 1, 1);
            }

            var maskData = this.maskDataFreeList.pop();
            if (!maskData) {
                maskData = { x: mask.x, y: mask.y, w: mask.width, h: mask.height };
            } else {
                maskData.x = mask.x;
                maskData.y = mask.y;
                maskData.w = mask.width;
                maskData.h = mask.height;
            }
            this.maskList.push(maskData);

            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

            this.renderGraphics(maskData);

            gl.colorMask(true, true, true, true);
            gl.stencilFunc(gl.NOTEQUAL, 0, this.maskList.length);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        };

        WebGLRenderer.prototype.popMask = function () {
            this._draw();
            var gl = this.gl;
            var maskData = this.maskList.pop();
            if (maskData) {
                gl.colorMask(false, false, false, false);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                this.renderGraphics(maskData);
                gl.colorMask(true, true, true, true);
                gl.stencilFunc(gl.NOTEQUAL, 0, this.maskList.length);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                this.maskDataFreeList.push(maskData);
            }
            if (this.maskList.length == 0) {
                gl.disable(gl.STENCIL_TEST);
            }
        };

        WebGLRenderer.prototype.setupFont = function (textField) {
            var ctx = this.canvasContext;
            var font = textField.italic ? "italic " : "normal ";
            font += textField.bold ? "bold " : "normal ";
            font += textField.size + "px " + textField.fontFamily;
            ctx.font = font;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
        };

        WebGLRenderer.prototype.measureText = function (text) {
            var result = this.canvasContext.measureText(text);
            return result.width;
        };

        WebGLRenderer.prototype.renderGraphics = function (graphics) {
            var gl = this.gl;
            var shader = this.shaderManager.primitiveShader;

            if (!this.graphicsPoints) {
                this.graphicsPoints = [];
                this.graphicsIndices = [];
                this.graphicsBuffer = gl.createBuffer();
                this.graphicsIndexBuffer = gl.createBuffer();
            } else {
                this.graphicsPoints.length = 0;
                this.graphicsIndices.length = 0;
            }

            this.updateGraphics(graphics);

            this.shaderManager.activateShader(shader);
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));

            gl.uniform2f(shader.projectionVector, this.projectionX, -this.projectionY);
            gl.uniform2f(shader.offsetVector, 0, 0);

            gl.uniform3fv(shader.tintColor, [1, 1, 1]);

            gl.uniform1f(shader.alpha, this.worldAlpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.graphicsBuffer);

            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.graphicsIndexBuffer);

            gl.drawElements(gl.TRIANGLE_STRIP, this.graphicsIndices.length, gl.UNSIGNED_SHORT, 0);

            this.shaderManager.activateShader(this.shaderManager.defaultShader);
        };

        WebGLRenderer.prototype.updateGraphics = function (graphics) {
            var gl = this.gl;

            this.buildRectangle(graphics);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.graphicsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.graphicsPoints), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.graphicsIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.graphicsIndices), gl.STATIC_DRAW);
        };

        WebGLRenderer.prototype.buildRectangle = function (graphicsData) {
            var x = graphicsData.x;
            var y = graphicsData.y;
            var width = graphicsData.w;
            var height = graphicsData.h;

            var r = 0;
            var g = 0;
            var b = 0;
            var alpha = 1;

            var verts = this.graphicsPoints;
            var indices = this.graphicsIndices;
            var vertPos = verts.length / 6;

            verts.push(x, y);
            verts.push(r, g, b, alpha);

            verts.push(x + width, y);
            verts.push(r, g, b, alpha);

            verts.push(x, y + height);
            verts.push(r, g, b, alpha);

            verts.push(x + width, y + height);
            verts.push(r, g, b, alpha);

            indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        };
        WebGLRenderer.blendModesWebGL = {};
        return WebGLRenderer;
    })(egret.RendererContext);
    egret.WebGLRenderer = WebGLRenderer;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var WebGLUtils = (function () {
        function WebGLUtils() {
        }
        WebGLUtils.compileProgram = function (gl, vertexSrc, fragmentSrc) {
            var fragmentShader = WebGLUtils.compileFragmentShader(gl, fragmentSrc);
            var vertexShader = WebGLUtils.compileVertexShader(gl, vertexSrc);

            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.log("无法初始化着色器");
            }
            return shaderProgram;
        };

        WebGLUtils.compileFragmentShader = function (gl, shaderSrc) {
            return WebGLUtils._compileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
        };

        WebGLUtils.compileVertexShader = function (gl, shaderSrc) {
            return WebGLUtils._compileShader(gl, shaderSrc, gl.VERTEX_SHADER);
        };

        WebGLUtils._compileShader = function (gl, shaderSrc, shaderType) {
            var shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSrc);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.log(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        };

        WebGLUtils.checkCanUseWebGL = function () {
            if (WebGLUtils.canUseWebGL == undefined) {
                try  {
                    var canvas = document.createElement("canvas");
                    WebGLUtils.canUseWebGL = !!window["WebGLRenderingContext"] && !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
                } catch (e) {
                    WebGLUtils.canUseWebGL = false;
                }
            }
            return WebGLUtils.canUseWebGL;
        };
        return WebGLUtils;
    })();
    egret.WebGLUtils = WebGLUtils;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var egret;
(function (egret) {
    var WebGLShaderManager = (function () {
        function WebGLShaderManager(gl) {
            this.maxAttibs = 10;
            this.attribState = [];
            this.tempAttribState = [];
            for (var i = 0; i < this.maxAttibs; i++) {
                this.attribState[i] = false;
            }
            this.setContext(gl);
        }
        WebGLShaderManager.prototype.setContext = function (gl) {
            this.gl = gl;
            this.primitiveShader = new PrimitiveShader(gl);
            this.defaultShader = new EgretShader(gl);
            this.activateShader(this.defaultShader);
        };

        WebGLShaderManager.prototype.activateShader = function (shader) {
            this.gl.useProgram(shader.program);
            this.setAttribs(shader.attributes);
        };

        WebGLShaderManager.prototype.setAttribs = function (attribs) {
            var i;
            var l;

            l = this.tempAttribState.length;
            for (i = 0; i < l; i++) {
                this.tempAttribState[i] = false;
            }

            l = attribs.length;
            for (i = 0; i < l; i++) {
                var attribId = attribs[i];
                this.tempAttribState[attribId] = true;
            }

            var gl = this.gl;
            l = this.attribState.length;
            for (i = 0; i < l; i++) {
                if (this.attribState[i] !== this.tempAttribState[i]) {
                    this.attribState[i] = this.tempAttribState[i];

                    if (this.tempAttribState[i]) {
                        gl.enableVertexAttribArray(i);
                    } else {
                        gl.disableVertexAttribArray(i);
                    }
                }
            }
        };
        return WebGLShaderManager;
    })();
    egret.WebGLShaderManager = WebGLShaderManager;

    var EgretShader = (function () {
        function EgretShader(gl) {
            this.defaultVertexSrc = "attribute vec2 aVertexPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec2 aColor;\n" + "uniform vec2 projectionVector;\n" + "uniform vec2 offsetVector;\n" + "varying vec2 vTextureCoord;\n" + "varying vec4 vColor;\n" + "const vec2 center = vec2(-1.0, 1.0);\n" + "void main(void) {\n" + "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);\n" + "   vTextureCoord = aTextureCoord;\n" + "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;\n" + "   vColor = vec4(color * aColor.x, aColor.x);\n" + "}";
            this.program = null;
            this.fragmentSrc = "precision lowp float;\n" + "varying vec2 vTextureCoord;\n" + "varying vec4 vColor;\n" + "uniform sampler2D uSampler;\n" + "void main(void) {\n" + "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;\n" + "}";
            this.gl = gl;
            this.init();
        }
        EgretShader.prototype.init = function () {
            var gl = this.gl;

            var program = egret.WebGLUtils.compileProgram(gl, this.defaultVertexSrc, this.fragmentSrc);
            gl.useProgram(program);

            this.uSampler = gl.getUniformLocation(program, "uSampler");
            this.projectionVector = gl.getUniformLocation(program, "projectionVector");
            this.offsetVector = gl.getUniformLocation(program, "offsetVector");
            this.dimensions = gl.getUniformLocation(program, "dimensions");

            this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
            this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
            this.colorAttribute = gl.getAttribLocation(program, "aColor");

            if (this.colorAttribute === -1) {
                this.colorAttribute = 2;
            }
            this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
            this.program = program;
        };
        return EgretShader;
    })();
    egret.EgretShader = EgretShader;

    var PrimitiveShader = (function () {
        function PrimitiveShader(gl) {
            this.program = null;
            this.projectionVector = null;
            this.offsetVector = null;
            this.tintColor = null;
            this.aVertexPosition = null;
            this.colorAttribute = null;
            this.attributes = null;
            this.translationMatrix = null;
            this.alpha = null;
            this.fragmentSrc = "precision mediump float;\n" + "varying vec4 vColor;\n" + "void main(void) {\n" + "   gl_FragColor = vColor;\n" + "}";
            this.vertexSrc = "attribute vec2 aVertexPosition;\n" + "attribute vec4 aColor;\n" + "uniform mat3 translationMatrix;\n" + "uniform vec2 projectionVector;\n" + "uniform vec2 offsetVector;\n" + "uniform float alpha;\n" + "uniform vec3 tint;\n" + "varying vec4 vColor;\n" + "void main(void) {\n" + "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);\n" + "   v -= offsetVector.xyx;\n" + "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);\n" + "   vColor = aColor * vec4(tint * alpha, alpha);\n" + "}";
            this.gl = gl;
            this.init();
        }
        PrimitiveShader.prototype.init = function () {
            var gl = this.gl;

            var program = egret.WebGLUtils.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
            gl.useProgram(program);

            this.projectionVector = gl.getUniformLocation(program, "projectionVector");
            this.offsetVector = gl.getUniformLocation(program, "offsetVector");
            this.tintColor = gl.getUniformLocation(program, "tint");

            this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
            this.colorAttribute = gl.getAttribLocation(program, "aColor");

            this.attributes = [this.aVertexPosition, this.colorAttribute];

            this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
            this.alpha = gl.getUniformLocation(program, "alpha");

            this.program = program;
        };
        return PrimitiveShader;
    })();
    egret.PrimitiveShader = PrimitiveShader;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @class egret.HTML5NetContext
    * @classdesc
    * @extends egret.NetContext
    */
    var HTML5NetContext = (function (_super) {
        __extends(HTML5NetContext, _super);
        function HTML5NetContext() {
            _super.call(this);
        }
        HTML5NetContext.prototype.proceed = function (loader) {
            if (loader.dataFormat == egret.URLLoaderDataFormat.TEXTURE) {
                this.loadTexture(loader);
                return;
            }
            if (loader.dataFormat == egret.URLLoaderDataFormat.SOUND) {
                this.loadSound(loader);
                return;
            }

            var request = loader._request;
            var xhr = this.getXHR();
            xhr.onerror = onLoadError;
            xhr.onload = onLoadComplete;
            xhr.open(request.method, request.url, true);
            this.setResponseType(xhr, loader.dataFormat);
            if (request.method == egret.URLRequestMethod.GET || !request.data) {
                xhr.send();
            } else if (request.data instanceof egret.URLVariables) {
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                var urlVars = request.data;
                xhr.send(urlVars.toString());
            } else {
                xhr.setRequestHeader("Content-Type", "multipart/form-data");
                xhr.send(request.data);
            }

            function onLoadError(event) {
                egret.IOErrorEvent.dispatchIOErrorEvent(loader);
            }
            ;

            function onLoadComplete(event) {
                switch (loader.dataFormat) {
                    case egret.URLLoaderDataFormat.TEXT:
                        loader.data = xhr.responseText;
                        break;

                    case egret.URLLoaderDataFormat.VARIABLES:
                        loader.data = new egret.URLVariables(xhr.responseText);
                        break;

                    case egret.URLLoaderDataFormat.BINARY:
                        loader.data = xhr.response;
                        break;
                    default:
                        loader.data = xhr.responseText;
                        break;
                }
                egret.callLater(egret.Event.dispatchEvent, egret.Event, loader, egret.Event.COMPLETE);
            }
            ;
        };

        HTML5NetContext.prototype.loadSound = function (loader) {
            var request = loader._request;
            var audio = new Audio(request.url);
            audio.addEventListener('canplaythrough', soundPreloadCanplayHandler, false);
            audio.addEventListener("error", soundPreloadErrorHandler, false);
            audio.load();

            function soundPreloadCanplayHandler(event) {
                audio.removeEventListener('canplaythrough', soundPreloadCanplayHandler, false);
                audio.removeEventListener("error", soundPreloadErrorHandler, false);
                var sound = new egret.Sound();
                sound.audio = audio;
                loader.data = sound;
                egret.callLater(egret.Event.dispatchEvent, egret.Event, loader, egret.Event.COMPLETE);
            }
            ;

            function soundPreloadErrorHandler(event) {
                audio.removeEventListener('canplaythrough', soundPreloadCanplayHandler, false);
                audio.removeEventListener("error", soundPreloadErrorHandler, false);
                egret.IOErrorEvent.dispatchIOErrorEvent(loader);
            }
            ;
        };

        HTML5NetContext.prototype.getXHR = function () {
            if (window["XMLHttpRequest"]) {
                return new window["XMLHttpRequest"]();
            } else {
                return new ActiveXObject("MSXML2.XMLHTTP");
            }
        };

        HTML5NetContext.prototype.setResponseType = function (xhr, responseType) {
            switch (responseType) {
                case egret.URLLoaderDataFormat.TEXT:
                case egret.URLLoaderDataFormat.VARIABLES:
                    xhr.responseType = egret.URLLoaderDataFormat.TEXT;
                    break;

                case egret.URLLoaderDataFormat.BINARY:
                    xhr.responseType = "arraybuffer";
                    break;

                default:
                    xhr.responseType = responseType;
                    break;
            }
        };

        HTML5NetContext.prototype.loadTexture = function (loader) {
            var request = loader._request;
            var image = new Image();
            image.crossOrigin = "Anonymous";
            image.onload = onImageComplete;
            image.onerror = onLoadError;
            image.src = request.url;

            function onImageComplete(event) {
                image.onerror = null;
                image.onload = null;
                var texture = new egret.Texture();
                texture._setBitmapData(image);
                loader.data = texture;
                egret.callLater(egret.Event.dispatchEvent, egret.Event, loader, egret.Event.COMPLETE);
            }
            ;

            function onLoadError(event) {
                image.onerror = null;
                image.onload = null;
                egret.IOErrorEvent.dispatchIOErrorEvent(loader);
            }
            ;
        };
        return HTML5NetContext;
    })(egret.NetContext);
    egret.HTML5NetContext = HTML5NetContext;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    var HTML5TouchContext = (function (_super) {
        __extends(HTML5TouchContext, _super);
        function HTML5TouchContext(canvas) {
            _super.call(this);
            this.canvas = canvas;
            this._isTouchDown = false;
        }
        HTML5TouchContext.prototype.run = function () {
            var that = this;
            if (window.navigator.msPointerEnabled) {
                this.canvas.addEventListener("MSPointerDown", function (event) {
                    that._onTouchBegin(event);
                    event.stopPropagation();
                    event.preventDefault();
                }, false);
                this.canvas.addEventListener("MSPointerMove", function (event) {
                    that._onTouchMove(event);
                    event.stopPropagation();
                    event.preventDefault();
                }, false);
                this.canvas.addEventListener("MSPointerUp", function (event) {
                    that._onTouchEnd(event);
                    event.stopPropagation();
                    event.preventDefault();
                }, false);
            } else {
                //touch事件
                this.canvas.addEventListener("touchstart", function (event) {
                    var l = event.changedTouches.length;
                    for (var i = 0; i < l && i < that.maxTouches; i++) {
                        that._onTouchBegin(event.changedTouches[i]);
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }, false);
                this.canvas.addEventListener("touchmove", function (event) {
                    var l = event.changedTouches.length;
                    for (var i = 0; i < l && i < that.maxTouches; i++) {
                        that._onTouchMove(event.changedTouches[i]);
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }, false);
                this.canvas.addEventListener("touchend", function (event) {
                    var l = event.changedTouches.length;
                    for (var i = 0; i < l && i < that.maxTouches; i++) {
                        that._onTouchEnd(event.changedTouches[i]);
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }, false);
                this.canvas.addEventListener("touchcancel", function (event) {
                    var l = event.changedTouches.length;
                    for (var i = 0; i < l && i < that.maxTouches; i++) {
                        that._onTouchEnd(event.changedTouches[i]);
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }, false);

                //mouse事件
                this.canvas.addEventListener("mousedown", function (event) {
                    that._onTouchBegin(event);
                });
                this.canvas.addEventListener("mousemove", function (event) {
                    that._onTouchMove(event);
                });
                this.canvas.addEventListener("mouseup", function (event) {
                    that._onTouchEnd(event);
                });
            }

            window.addEventListener("mousedown", function (event) {
                if (!that.inOutOfCanvas(event)) {
                    that._isTouchDown = true;
                } else {
                    that.dispatchLeaveStageEvent();
                }
            });

            window.addEventListener("mouseup", function (event) {
                if (that._isTouchDown && that.inOutOfCanvas(event)) {
                    that.dispatchLeaveStageEvent();
                }
                that._isTouchDown = false;
            });
        };

        HTML5TouchContext.prototype.inOutOfCanvas = function (event) {
            var location = this.getLocation(this.canvas, event);
            if (location.x < 0 || location.y < 0 || location.x > this.canvas.width || location.y > this.canvas.height) {
                return true;
            }
            return false;
        };

        HTML5TouchContext.prototype.dispatchLeaveStageEvent = function () {
            egret.MainContext.instance.stage.dispatchEventWith(egret.Event.LEAVE_STAGE);
        };

        HTML5TouchContext.prototype._onTouchBegin = function (event) {
            var location = this.getLocation(this.canvas, event);
            var identifier = -1;
            if (event.hasOwnProperty("identifier")) {
                identifier = event.identifier;
            }
            this.onTouchBegan(location.x, location.y, identifier);
        };

        HTML5TouchContext.prototype._onTouchMove = function (event) {
            var location = this.getLocation(this.canvas, event);
            var identifier = -1;
            if (event.hasOwnProperty("identifier")) {
                identifier = event.identifier;
            }
            this.onTouchMove(location.x, location.y, identifier);
        };

        HTML5TouchContext.prototype._onTouchEnd = function (event) {
            var location = this.getLocation(this.canvas, event);
            var identifier = -1;
            if (event.hasOwnProperty("identifier")) {
                identifier = event.identifier;
            }
            this.onTouchEnd(location.x, location.y, identifier);
        };

        HTML5TouchContext.prototype.getLocation = function (canvas, event) {
            var doc = document.documentElement;
            var win = window;
            var left, top, tx, ty;

            if (typeof canvas.getBoundingClientRect === 'function') {
                var box = canvas.getBoundingClientRect();
                left = box.left;
                top = box.top;
            } else {
                left = 0;
                top = 0;
            }

            left += win.pageXOffset - doc.clientLeft;
            top += win.pageYOffset - doc.clientTop;

            if (event.pageX != null) {
                tx = event.pageX;
                ty = event.pageY;
            } else {
                left -= document.body.scrollLeft;
                top -= document.body.scrollTop;
                tx = event.clientX;
                ty = event.clientY;
            }
            var result = egret.Point.identity;
            result.x = (tx - left) / egret.StageDelegate.getInstance().getScaleX();
            result.y = (ty - top) / egret.StageDelegate.getInstance().getScaleY();
            return result;
        };
        return HTML5TouchContext;
    })(egret.TouchContext);
    egret.HTML5TouchContext = HTML5TouchContext;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var egret;
(function (egret) {
    /**
    * @deprecated
    */
    var SAXParser = (function (_super) {
        __extends(SAXParser, _super);
        function SAXParser() {
            _super.call(this);
            this._parser = null;
            this._xmlDict = null;
            this._isSupportDOMParser = null;
            this._xmlDict = {};
            if (window["DOMParser"]) {
                this._isSupportDOMParser = true;
                this._parser = new DOMParser();
            } else {
                this._isSupportDOMParser = false;
            }
        }
        /**
        * @deprecated
        */
        SAXParser.getInstance = function () {
            if (!SAXParser._instance) {
                SAXParser._instance = new SAXParser();
            }
            return SAXParser._instance;
        };

        /**
        * @deprecated
        */
        SAXParser.prototype.parserXML = function (textxml) {
            var i = 0;
            while (textxml.charAt(i) == "\n" || textxml.charAt(i) == "\t" || textxml.charAt(i) == "\r" || textxml.charAt(i) == " ") {
                i++;
            }

            if (i != 0) {
                textxml = textxml.substring(i, textxml.length);
            }

            var xmlDoc;
            if (this._isSupportDOMParser) {
                xmlDoc = this._parser.parseFromString(textxml, "text/xml");
            } else {
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = "false";
                xmlDoc.loadXML(textxml);
            }

            if (xmlDoc == null) {
                egret.Logger.info("xml not found!");
            }
            return xmlDoc;
        };
        SAXParser._instance = null;
        return SAXParser;
    })(egret.HashObject);
    egret.SAXParser = SAXParser;
})(egret || (egret = {}));

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var LoadingUI = (function (_super) {
    __extends(LoadingUI, _super);
    function LoadingUI() {
        _super.call(this);
        this.createView();
    }
    LoadingUI.prototype.createView = function () {
        this.textField = new egret.TextField();
        this.addChild(this.textField);
        this.textField.y = 300;
        this.textField.width = 480;
        this.textField.height = 100;
        this.textField.textAlign = "center";
    };

    LoadingUI.prototype.setProgress = function (current, total) {
        this.textField.text = "游戏加载中..." + current + "/" + total;
    };
    return LoadingUI;
})(egret.Sprite);

var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TouchEventTest = (function (_super) {
    __extends(TouchEventTest, _super);
    function TouchEventTest() {
        _super.call(this);
        this.count = 0;
        this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddToStage, this);
    }
    TouchEventTest.prototype.onAddToStage = function (event) {
        //添加显示文本
        this.drawText();

        //绘制一个透明度为1的绿色矩形，宽高为100*80
        var spr1 = new egret.Sprite();
        var stageW = this.stage.stageWidth;
        var stageH = this.stage.stageHeight;

        spr1.graphics.beginFill(0x00ff00, 0.8);
        spr1.graphics.drawRect(0, 0, 100, 100);
        spr1.graphics.endFill();
        spr1.width = 100;
        spr1.height = 100;
        this.addChild(spr1);
        spr1.x = stageW / 2 - 50;
        spr1.y = stageH / 2 - 100;

        //spr1.alpha = 0;
        //开启spr1的Touch开关
        spr1.touchEnabled = true;

        //注册事件
        spr1.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouch, this);
        this.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouchTap, this);
        this.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouchTaps, this, true);
    };

    TouchEventTest.prototype.onTouch = function (evt) {
        //this.txt.text += "\n点击了spr1";
        this.count++;
        this.txt.text = "点击了 " + this.count + " 次";
        console.log("\n点击了spr1");
    };

    TouchEventTest.prototype.onTouchTap = function (evt) {
        //this.txt.text += "\n容器冒泡侦听\n---------";
        console.log("\n容器冒泡侦听\n---------");
    };

    TouchEventTest.prototype.onTouchTaps = function (evt) {
        //this.txt.text += "\n容器捕获侦听";
        console.log("\n容器捕获侦听");
    };

    TouchEventTest.prototype.drawText = function () {
        this.txt = new egret.TextField();
        this.txt.size = 12;
        this.txt.x = 250;
        this.txt.width = 200;
        this.txt.height = 200;
        this.txt.text = "点击次数";
        this.addChild(this.txt);
    };
    return TouchEventTest;
})(egret.DisplayObjectContainer);

/**
* Copyright (c) 2014,Egret-Labs.org
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Egret-Labs.org nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY EGRET-LABS.ORG AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL EGRET-LABS.ORG AND CONTRIBUTORS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var GameApp = (function (_super) {
    __extends(GameApp, _super);
    function GameApp() {
        _super.call(this);
        this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddToStage, this);
    }
    GameApp.prototype.onAddToStage = function (event) {
        //设置加载进度界面
        this.loadingView = new LoadingUI();
        this.touchEvent = new TouchEventTest();
        this.stage.addChild(this.loadingView);

        //初始化Resource资源加载库
        RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE, this.onConfigComplete, this);
        RES.loadConfig("resource/resource.json", "resource/");
        //打开性能面板
        //egret.Profiler.getInstance().run();
    };

    /**
    * 配置文件加载完成,开始预加载preload资源组。
    */
    GameApp.prototype.onConfigComplete = function (event) {
        RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE, this.onConfigComplete, this);
        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onResourceLoadComplete, this);
        RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS, this.onResourceProgress, this);
        RES.loadGroup("preload");
    };

    /**
    * preload资源组加载完成
    */
    GameApp.prototype.onResourceLoadComplete = function (event) {
        if (event.groupName == "preload") {
            this.stage.removeChild(this.loadingView);
            RES.removeEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onResourceLoadComplete, this);
            RES.removeEventListener(RES.ResourceEvent.GROUP_PROGRESS, this.onResourceProgress, this);
            this.createGameScene();
        }
    };

    /**
    * preload资源组加载进度
    */
    GameApp.prototype.onResourceProgress = function (event) {
        if (event.groupName == "preload") {
            this.loadingView.setProgress(event.itemsLoaded, event.itemsTotal);
        }
    };

    /**
    * 创建游戏场景
    */
    GameApp.prototype.createGameScene = function () {
        var sky = this.createBitmapByName("bgImage");
        this.addChild(sky);
        var stageW = this.stage.stageWidth;
        var stageH = this.stage.stageHeight;
        sky.width = stageW;
        sky.height = stageH;

        var topMask = new egret.Shape();
        topMask.graphics.beginFill(0xa2a2a2, 0.5);
        topMask.graphics.drawRect(0, 0, stageW, stageH);
        topMask.graphics.endFill();
        topMask.width = stageW;
        topMask.height = stageH;
        this.addChild(topMask);

        var icon = this.createBitmapByName("egretIcon");
        icon.anchorX = icon.anchorY = 0.5;
        this.addChild(icon);
        icon.x = stageW / 2;
        icon.y = stageH / 2 - 60;
        icon.scaleX = 0.55;
        icon.scaleY = 0.55;

        var colorLabel = new egret.TextField();
        colorLabel.x = stageW / 2;
        colorLabel.y = stageH / 2 + 50;
        colorLabel.anchorX = colorLabel.anchorY = 0.5;
        colorLabel.textColor = 0xffffff;
        colorLabel.textAlign = "center";
        colorLabel.text = "Num to Num";
        colorLabel.size = 20;
        this.addChild(colorLabel);

        var textContainer = new egret.Sprite();
        textContainer.anchorX = textContainer.anchorY = 0.5;
        this.addChild(textContainer);
        textContainer.x = stageW / 2;
        textContainer.y = stageH / 2 + 100;
        textContainer.alpha = 0;

        this.textContainer = textContainer;

        this.stage.addChild(this.touchEvent);
    };

    /**
    * 根据name关键字创建一个Bitmap对象。name属性请参考resources/resource.json配置文件的内容。
    */
    GameApp.prototype.createBitmapByName = function (name) {
        var result = new egret.Bitmap();
        var texture = RES.getRes(name);
        result.texture = texture;
        return result;
    };
    return GameApp;
})(egret.DisplayObjectContainer);

